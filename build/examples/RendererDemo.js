/**
 * dat-gui JavaScript Controller Library
 * https://github.com/dataarts/dat.gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color$2 = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color$2.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color$2.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color$2.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color$2.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color$2.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color$2.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color$2.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color$2.prototype, 'r', 2);
defineRGBComponent(Color$2.prototype, 'g', 1);
defineRGBComponent(Color$2.prototype, 'b', 0);
defineHSVComponent(Color$2.prototype, 'h');
defineHSVComponent(Color$2.prototype, 's');
defineHSVComponent(Color$2.prototype, 'v');
Object.defineProperty(Color$2.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color$2.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller$1 = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller$1);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller$1);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller$1);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller$1);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map$1(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map$1(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map$1(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller$1);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color$2(_this2.getValue());
    _this2.__temp = new Color$2(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color$2.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller$1);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css$1 = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css$1.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide$1 = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide$1 = !hide$1;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide$1 ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller$1) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}
var GUI$1 = GUI;

/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '141';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const GLSL3 = '300 es';

const _SRGBAFormat = 1035; // fallback for WebGL 1

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize$1( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

var MathUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize$1
});

class Vector2 {

	constructor( x = 0, y = 0 ) {

		this.isVector2 = true;

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

class Matrix3 {

	constructor() {

		this.isMatrix3 = true;

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] > 65535 ) return true;

	}

	return false;

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const FN = {
	[ SRGBColorSpace ]: { [ LinearSRGBColorSpace ]: SRGBToLinear },
	[ LinearSRGBColorSpace ]: { [ SRGBColorSpace ]: LinearToSRGB },
};

const ColorManagement = {

	legacyMode: true,

	get workingColorSpace() {

		return LinearSRGBColorSpace;

	},

	set workingColorSpace( colorSpace ) {

		console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

	},

	convert: function ( color, sourceColorSpace, targetColorSpace ) {

		if ( this.legacyMode || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

			return color;

		}

		if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {

			const fn = FN[ sourceColorSpace ][ targetColorSpace ];

			color.r = fn( color.r );
			color.g = fn( color.g );
			color.b = fn( color.b );

			return color;

		}

		throw new Error( 'Unsupported color space conversion.' );

	},

	fromWorkingColorSpace: function ( color, targetColorSpace ) {

		return this.convert( color, this.workingColorSpace, targetColorSpace );

	},

	toWorkingColorSpace: function ( color, sourceColorSpace ) {

		return this.convert( color, sourceColorSpace, this.workingColorSpace );

	},

};

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _rgb = { r: 0, g: 0, b: 0 };
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function toComponents( source, target ) {

	target.r = source.r;
	target.g = source.g;
	target.b = source.b;

	return target;

}

class Color$1 {

	constructor( r, g, b ) {

		this.isColor = true;

		this.r = 1;
		this.g = 1;
		this.b = 1;

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = LinearSRGBColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = LinearSRGBColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l, colorSpace );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		return clamp( _rgb.r * 255, 0, 255 ) << 16 ^ clamp( _rgb.g * 255, 0, 255 ) << 8 ^ clamp( _rgb.b * 255, 0, 255 ) << 0;

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

	}

	getHSL( target, colorSpace = LinearSRGBColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		const r = _rgb.r, g = _rgb.g, b = _rgb.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = LinearSRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		target.r = _rgb.r;
		target.g = _rgb.g;
		target.b = _rgb.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ _rgb.r } ${ _rgb.g } ${ _rgb.b })`;

		}

		return `rgb(${( _rgb.r * 255 ) | 0},${( _rgb.g * 255 ) | 0},${( _rgb.b * 255 ) | 0})`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

Color$1.NAMES = _colorKeywords;

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

class Source {

	constructor( data = null ) {

		this.isSource = true;

		this.uuid = generateUUID();

		this.data = data;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.prototype.slice.call( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		super();

		this.isTexture = true;

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isVector4 = true;

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {

	constructor( width, height, options = {} ) {

		super();

		this.isWebGLRenderTarget = true;

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: 1 };

		this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
		this.texture.isRenderTargetTexture = true;

		this.texture.flipY = false;
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		this.samples = options.samples !== undefined ? options.samples : 0;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();
		this.texture.isRenderTargetTexture = true;

		// ensure image object is not shared, see #20328

		const image = Object.assign( {}, source.texture.image );
		this.texture.source = new Source( image );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

class DataArrayTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.isDataArrayTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class Data3DTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.isData3DTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt( 1 - u1 );
		const sqrtu1 = Math.sqrt( u1 );

		const u2 = 2 * Math.PI * Math.random();

		const u3 = 2 * Math.PI * Math.random();

		return this.set(
			sqrt1u1 * Math.cos( u2 ),
			sqrtu1 * Math.sin( u3 ),
			sqrtu1 * Math.cos( u3 ),
			sqrt1u1 * Math.sin( u2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.isVector3 = true;

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = ( Math.random() - 0.5 ) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt( 1 - u ** 2 );

		this.x = f * Math.cos( t );
		this.y = f * Math.sin( t );
		this.z = u;

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.isBox3 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

				const position = geometry.attributes.position;
				for ( let i = 0, l = position.count; i < l; i ++ ) {

					_vector$b.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box$3.copy( geometry.boundingBox );
				_box$3.applyMatrix4( object.matrixWorld );

				this.union( _box$3 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$3.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$3, _v1$7 );
		_f2.subVectors( _v0$2, _v2$3 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$b ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$3 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _toFarthestPoint = /*@__PURE__*/ new Vector3();
const _toPoint = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		_toPoint.subVectors( point, this.center );

		const lengthSq = _toPoint.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			const length = Math.sqrt( lengthSq );
			const missingRadiusHalf = ( length - this.radius ) * 0.5;

			// Nudge this sphere towards the target point. Add half the missing distance to radius,
			// and the other half to position. This gives a tighter enclosure, instead of if
			// the whole missing distance were just added to radius.

			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			this.radius += missingRadiusHalf;

		}

		return this;

	}

	union( sphere ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		// To enclose another sphere into this sphere, we only need to enclose two points:
		// 1) Enclose the farthest point on the other sphere into this sphere.
		// 2) Enclose the opposite point of the farthest point into this sphere.

		 if ( this.center.equals( sphere.center ) === true ) {

			 _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );


		} else {

			_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		}

		this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
		this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		this.isMatrix4 = true;

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$1$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$1$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1$1, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

	// @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53

	toVector3() {

		console.error( 'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead' );

	}

}

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		this.isMaterial = true;

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			// for backward compatibility if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	// @deprecated since r131, f5803c62cc4a29d90744e9dc7811d086e354c1d8

	get vertexTangents() {

		console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );
		return false;

	}

	set vertexTangents( value ) {

		console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );

	}

}

Material.fromType = function ( /*type*/ ) {

	// TODO: Behavior added in Materials.js

	return null;

};

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		this.color = new Color$1( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.isBufferAttribute = true;

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	copyColorsArray( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color$1();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	}

	copyVector2sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	}

	copyVector3sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	}

	copyVector4sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	getX( index ) {

		return this.array[ index * this.itemSize ];

	}

	setX( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		return this.array[ index * this.itemSize + 1 ];

	}

	setY( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	}

	setZ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		return this.array[ index * this.itemSize + 3 ];

	}

	setW( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}


class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$1 = 0;

const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$1 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		this.isBufferGeometry = true;

		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$1.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$1.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$1.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$1.min );
						this.boundingBox.expandByPoint( _box$1.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$1.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
						_box$1.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
						_box$1.expandByPoint( _vector$8 );

					} else {

						_box$1.expandByPoint( _boxMorphTargets.min );
						_box$1.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$1.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = this.getAttribute( 'tangent' ).array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	merge( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		 return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		// geometry generator parameters

		if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere$3 = /*@__PURE__*/ new Sphere();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _tempB = /*@__PURE__*/ new Vector3();
const _tempC = /*@__PURE__*/ new Vector3();

const _morphA = /*@__PURE__*/ new Vector3();
const _morphB = /*@__PURE__*/ new Vector3();
const _morphC = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.isMesh = true;

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;
		const uv = geometry.attributes.uv;
		const uv2 = geometry.attributes.uv2;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkBufferGeometryIntersection$1( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkBufferGeometryIntersection$1( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkBufferGeometryIntersection$1( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkBufferGeometryIntersection$1( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection$1( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA$1.fromBufferAttribute( position, a );
	_vB$1.fromBufferAttribute( position, b );
	_vC$1.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

			}

		}

		_vA$1.add( _morphA );
		_vB$1.add( _morphB );
		_vC$1.add( _morphC );

	}

	if ( object.isSkinnedMesh ) {

		object.boneTransform( a, _vA$1 );
		object.boneTransform( b, _vB$1 );
		object.boneTransform( c, _vC$1 );

	}

	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv2 ) {

			_uvA$1.fromBufferAttribute( uv2, a );
			_uvB$1.fromBufferAttribute( uv2, b );
			_uvC$1.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

class Camera extends Object3D {

	constructor() {

		super();

		this.isCamera = true;

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const fov = 90, aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			return;

		}

		this.renderTarget = renderTarget;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const renderTarget = this.renderTarget;

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();

		const currentToneMapping = renderer.toneMapping;
		const currentXrEnabled = renderer.xr.enabled;

		renderer.toneMapping = NoToneMapping;
		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.toneMapping = currentToneMapping;
		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.isCubeTexture = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size, options = {} ) {

		super( size, size, options );

		this.isWebGLCubeRenderTarget = true;

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSprite( sprite ) {

		_sphere$2.center.set( 0, 0, 0 );
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = 5131;

				} else {

					throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = 5123;

			}

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = 5121;

		} else {

			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();
		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	output_fragment: output_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$g,
	background_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: new Color$1( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },
		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // physical
		refractionRatio: { value: 0.98 } // basic, lambert, phong

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color$1( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: new Color$1( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color$1( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) },
				specular: { value: new Color$1( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color$1( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			iridescence: { value: 0 },
			iridescenceMap: { value: null },
			iridescenceIOR: { value: 1.3 },
			iridescenceThicknessMinimum: { value: 100 },
			iridescenceThicknessMaximum: { value: 400 },
			iridescenceThicknessMap: { value: null },
			sheen: { value: 0 },
			sheenColor: { value: new Color$1( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionSamplerSize: { value: new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: new Color$1( 0x000000 ) },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularColor: { value: new Color$1( 1, 1, 1 ) },
			specularColorMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

function WebGLBackground( renderer, cubemaps, state, objects, alpha, premultipliedAlpha ) {

	const clearColor = new Color$1( 0x000000 );
	let clearAlpha = alpha === true ? 0 : 1;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene ) {

		let forceClear = false;
		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			background = cubemaps.get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			boxMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			planeMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( 34921 );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;
	let forceUpdate = false;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( object, geometry, program, index );

			if ( updateBuffers ) saveCache( object, geometry, program, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		if ( updateBuffers || forceUpdate ) {

			forceUpdate = false;

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( 34963, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( object, geometry, program, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				const cachedAttribute = cachedAttributes[ name ];
				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( object, geometry, program, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let attribute = attributes[ name ];

				if ( attribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

				}

				const data = {};
				data.attribute = attribute;

				if ( attribute && attribute.data ) {

					data.data = attribute.data;

				}

				cache[ name ] = data;

				attributesNum ++;

			}

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data.isInstancedInterleavedBuffer ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								stride * bytesPerElement,
								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement
							);

						}

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								size * bytesPerElement,
								( size / programAttribute.locationSize ) * i * bytesPerElement
							);

						}

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute.location, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute.location, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute.location, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute.location, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();
		forceUpdate = true;

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatibility

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( 34930 );
	const maxVertexTextures = gl.getParameter( 35660 );
	const maxTextureSize = gl.getParameter( 3379 );
	const maxCubemapSize = gl.getParameter( 34076 );

	const maxAttributes = gl.getParameter( 34921 );
	const maxVertexUniforms = gl.getParameter( 36347 );
	const maxVaryings = gl.getParameter( 36348 );
	const maxFragmentUniforms = gl.getParameter( 36349 );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		drawBuffers: drawBuffers,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const _clearColor = /*@__PURE__*/ new Color$1();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();

		this._setSize( 256 );

		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

	}

	// private interface

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

		_oldTarget = this._renderer.getRenderTarget();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			encoding: LinearEncoding,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;

		const backgroundMaterial = new MeshBasicMaterial( {
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false,
		} );

		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor );
			useSolidColor = true;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();

		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();

			}

			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}



function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( lodMax, width, height ) {

	const weights = new Float32Array( MAX_SAMPLES );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new ShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`,
		},

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectMaterial() {

	return new ShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCubemapMaterial() {

	return new ShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'flipEnvMap': { value: - 1 }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function WebGLCubeUVMaps( renderer ) {

	let cubeUVmaps = new WeakMap();

	let pmremGenerator = null;

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

			// equirect/cube map to cubeUV conversion

			if ( isEquirectMap || isCubeMap ) {

				if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

					texture.needsPMREMUpdate = false;

					let renderTarget = cubeUVmaps.get( texture );

					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
					cubeUVmaps.set( texture, renderTarget );

					return renderTarget.texture;

				} else {

					if ( cubeUVmaps.has( texture ) ) {

						return cubeUVmaps.get( texture ).texture;

					} else {

						const image = texture.image;

						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
							cubeUVmaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return renderTarget.texture;

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

		}

		return texture;

	}

	function isCubeTextureComplete( image ) {

		let count = 0;
		const length = 6;

		for ( let i = 0; i < length; i ++ ) {

			if ( image[ i ] !== undefined ) count ++;

		}

		return count === length;


	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemapUV = cubeUVmaps.get( texture );

		if ( cubemapUV !== undefined ) {

			cubeUVmaps.delete( texture );
			cubemapUV.dispose();

		}

	}

	function dispose() {

		cubeUVmaps = new WeakMap();

		if ( pmremGenerator !== null ) {

			pmremGenerator.dispose();
			pmremGenerator = null;

		}

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function ( capabilities ) {

			if ( capabilities.isWebGL2 ) {

				getExtension( 'EXT_color_buffer_float' );

			} else {

				getExtension( 'WEBGL_depth_texture' );
				getExtension( 'OES_texture_float' );
				getExtension( 'OES_texture_half_float' );
				getExtension( 'OES_texture_half_float_linear' );
				getExtension( 'OES_standard_derivatives' );
				getExtension( 'OES_element_index_uint' );
				getExtension( 'OES_vertex_array_object' );
				getExtension( 'ANGLE_instanced_arrays' );

			}

			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );
			getExtension( 'WEBGL_multisampled_render_to_texture' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function denormalize( morph, attribute ) {

	let denominator = 1;
	const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;

	if ( array instanceof Int8Array ) denominator = 127;
	else if ( array instanceof Int16Array ) denominator = 32767;
	else if ( array instanceof Int32Array ) denominator = 2147483647;
	else console.error( 'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array );

	morph.divideScalar( denominator );

}

function WebGLMorphtargets( gl, capabilities, textures ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );
	const morphTextures = new WeakMap();
	const morph = new Vector4();

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		if ( capabilities.isWebGL2 === true ) {

			// instead of using attributes, the WebGL 2 code path encodes morph targets
			// into an array of data textures. Each layer represents a single morph target.

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let entry = morphTextures.get( geometry );

			if ( entry === undefined || entry.count !== morphTargetsCount ) {

				if ( entry !== undefined ) entry.texture.dispose();

				const hasMorphPosition = geometry.morphAttributes.position !== undefined;
				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
				const hasMorphColors = geometry.morphAttributes.color !== undefined;

				const morphTargets = geometry.morphAttributes.position || [];
				const morphNormals = geometry.morphAttributes.normal || [];
				const morphColors = geometry.morphAttributes.color || [];

				let vertexDataCount = 0;

				if ( hasMorphPosition === true ) vertexDataCount = 1;
				if ( hasMorphNormals === true ) vertexDataCount = 2;
				if ( hasMorphColors === true ) vertexDataCount = 3;

				let width = geometry.attributes.position.count * vertexDataCount;
				let height = 1;

				if ( width > capabilities.maxTextureSize ) {

					height = Math.ceil( width / capabilities.maxTextureSize );
					width = capabilities.maxTextureSize;

				}

				const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

				const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
				texture.type = FloatType;
				texture.needsUpdate = true;

				// fill buffer

				const vertexDataStride = vertexDataCount * 4;

				for ( let i = 0; i < morphTargetsCount; i ++ ) {

					const morphTarget = morphTargets[ i ];
					const morphNormal = morphNormals[ i ];
					const morphColor = morphColors[ i ];

					const offset = width * height * 4 * i;

					for ( let j = 0; j < morphTarget.count; j ++ ) {

						const stride = j * vertexDataStride;

						if ( hasMorphPosition === true ) {

							morph.fromBufferAttribute( morphTarget, j );

							if ( morphTarget.normalized === true ) denormalize( morph, morphTarget );

							buffer[ offset + stride + 0 ] = morph.x;
							buffer[ offset + stride + 1 ] = morph.y;
							buffer[ offset + stride + 2 ] = morph.z;
							buffer[ offset + stride + 3 ] = 0;

						}

						if ( hasMorphNormals === true ) {

							morph.fromBufferAttribute( morphNormal, j );

							if ( morphNormal.normalized === true ) denormalize( morph, morphNormal );

							buffer[ offset + stride + 4 ] = morph.x;
							buffer[ offset + stride + 5 ] = morph.y;
							buffer[ offset + stride + 6 ] = morph.z;
							buffer[ offset + stride + 7 ] = 0;

						}

						if ( hasMorphColors === true ) {

							morph.fromBufferAttribute( morphColor, j );

							if ( morphColor.normalized === true ) denormalize( morph, morphColor );

							buffer[ offset + stride + 8 ] = morph.x;
							buffer[ offset + stride + 9 ] = morph.y;
							buffer[ offset + stride + 10 ] = morph.z;
							buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

						}

					}

				}

				entry = {
					count: morphTargetsCount,
					texture: texture,
					size: new Vector2( width, height )
				};

				morphTextures.set( geometry, entry );

				function disposeTexture() {

					texture.dispose();

					morphTextures.delete( geometry );

					geometry.removeEventListener( 'dispose', disposeTexture );

				}

				geometry.addEventListener( 'dispose', disposeTexture );

			}

			//

			let morphInfluencesSum = 0;

			for ( let i = 0; i < objectInfluences.length; i ++ ) {

				morphInfluencesSum += objectInfluences[ i ];

			}

			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

			program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
			program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


		} else {

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;

			let influences = influencesList[ geometry.id ];

			if ( influences === undefined || influences.length !== length ) {

				// initialise list

				influences = [];

				for ( let i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			// Collect influences

			for ( let i = 0; i < length; i ++ ) {

				const influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			for ( let i = 0; i < 8; i ++ ) {

				if ( i < length && influences[ i ][ 1 ] ) {

					workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
					workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

				} else {

					workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
					workInfluences[ i ][ 1 ] = 0;

				}

			}

			workInfluences.sort( numericalSort );

			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;

			let morphInfluencesSum = 0;

			for ( let i = 0; i < 8; i ++ ) {

				const influence = workInfluences[ i ];
				const index = influence[ 0 ];
				const value = influence[ 1 ];

				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

						geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

					}

					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

						geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					}

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;

				} else {

					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

						geometry.deleteAttribute( 'morphTarget' + i );

					}

					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

						geometry.deleteAttribute( 'morphNormal' + i );

					}

					morphInfluences[ i ] = 0;

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			attributes.update( object.instanceMatrix, 34962 );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, 34962 );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyArrayTexture = new DataArrayTexture();
const empty3dTexture = new Data3DTexture();
const emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4uiv( this.addr, v );

	copyArray( cache, v );

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2D( v || emptyTexture, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || empty3dTexture, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyArrayTexture, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT3DArray( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

function setValueT2DArrayArray( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

	}

}


// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;

	}

}

// --- Uniform Classes ---

class SingleUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class PureArrayUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class StructuredUniform {

	constructor( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	setValue( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	}

}

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

class WebGLUniforms {

	constructor( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, 35718 );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	setValue( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	}

	setOptional( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	}

	static upload( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	}

	static seqWithValue( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	}

}

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

let programIdCount = 0;

function handleSource( string, errorLine ) {

	const lines = string.split( '\n' );
	const lines2 = [];

	const from = Math.max( errorLine - 6, 0 );
	const to = Math.min( errorLine + 6, lines.length );

	for ( let i = from; i < to; i ++ ) {

		const line = i + 1;
		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

	}

	return lines2.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, 35713 );
	const errors = gl.getShaderInfoLog( shader ).trim();

	if ( status && errors === '' ) return '';

	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
	if ( errorMatches ) {

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const errorLine = parseInt( errorMatches[ 1 ] );
		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

	} else {

		return errors;

	}

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, 35721 );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		let locationSize = 1;
		if ( info.type === 35674 ) locationSize = 2;
		if ( info.type === 35675 ) locationSize = 3;
		if ( info.type === 35676 ) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = {
			type: info.type,
			location: gl.getAttribLocation( program, name ),
			locationSize: locationSize
		};

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function generateCubeUVSize( parameters ) {

	const imageHeight = parameters.envMapCubeUVHeight;

	if ( imageHeight === null ) return null;

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
	const envMapCubeUVSize = generateCubeUVSize( parameters );

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaTest ? '#define USE_ALPHATEST' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',
			parameters.opaque ? '#define OPAQUE' : '',

			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'precision mediump sampler2DArray;',
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error(
				'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
				'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' +
				'Program Info Log: ' + programLog + '\n' +
				vertexErrors + '\n' +
				fragmentErrors
			);

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

let _id = 0;

class WebGLShaderCache {

	constructor() {

		this.shaderCache = new Map();
		this.materialCache = new Map();

	}

	update( material ) {

		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;

		const vertexShaderStage = this._getShaderStage( vertexShader );
		const fragmentShaderStage = this._getShaderStage( fragmentShader );

		const materialShaders = this._getShaderCacheForMaterial( material );

		if ( materialShaders.has( vertexShaderStage ) === false ) {

			materialShaders.add( vertexShaderStage );
			vertexShaderStage.usedTimes ++;

		}

		if ( materialShaders.has( fragmentShaderStage ) === false ) {

			materialShaders.add( fragmentShaderStage );
			fragmentShaderStage.usedTimes ++;

		}

		return this;

	}

	remove( material ) {

		const materialShaders = this.materialCache.get( material );

		for ( const shaderStage of materialShaders ) {

			shaderStage.usedTimes --;

			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

		}

		this.materialCache.delete( material );

		return this;

	}

	getVertexShaderID( material ) {

		return this._getShaderStage( material.vertexShader ).id;

	}

	getFragmentShaderID( material ) {

		return this._getShaderStage( material.fragmentShader ).id;

	}

	dispose() {

		this.shaderCache.clear();
		this.materialCache.clear();

	}

	_getShaderCacheForMaterial( material ) {

		const cache = this.materialCache;

		if ( cache.has( material ) === false ) {

			cache.set( material, new Set() );

		}

		return cache.get( material );

	}

	_getShaderStage( code ) {

		const cache = this.shaderCache;

		if ( cache.has( code ) === false ) {

			const stage = new WebGLShaderStage( code );
			cache.set( code, stage );

		}

		return cache.get( code );

	}

}

class WebGLShaderStage {

	constructor( code ) {

		this.id = _id ++;

		this.code = code;
		this.usedTimes = 0;

	}

}

function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const vertexTextures = capabilities.vertexTextures;
	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let morphTextureStride = 0;

		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

			_customShaders.update( material );

			customVertexShaderID = _customShaders.getVertexShaderID( material );
			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const useAlphaTest = material.alphaTest > 0;
		const useClearcoat = material.clearcoat > 0;
		const useIridescence = material.iridescence > 0;

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget === null ) ? renderer.outputEncoding : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding ),
			map: !! material.map,
			matcap: !! material.matcap,
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,

			decodeVideoTexture: !! material.map && ( material.map.isVideoTexture === true ) && ( material.map.encoding === sRGBEncoding ),

			clearcoat: useClearcoat,
			clearcoatMap: useClearcoat && !! material.clearcoatMap,
			clearcoatRoughnessMap: useClearcoat && !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: useClearcoat && !! material.clearcoatNormalMap,

			iridescence: useIridescence,
			iridescenceMap: useIridescence && !! material.iridescenceMap,
			iridescenceThicknessMap: useIridescence && !! material.iridescenceThicknessMap,

			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			specularIntensityMap: !! material.specularIntensityMap,
			specularColorMap: !! material.specularColorMap,

			opaque: material.transparent === false && material.blending === NormalBlending,

			alphaMap: !! material.alphaMap,
			alphaTest: useAlphaTest,

			gradientMap: !! material.gradientMap,

			sheen: material.sheen > 0,
			sheenColorMap: !! material.sheenColorMap,
			sheenRoughnessMap: !! material.sheenRoughnessMap,

			transmission: material.transmission > 0,
			transmissionMap: !! material.transmissionMap,
			thicknessMap: !! material.thicknessMap,

			combine: material.combine,

			vertexTangents: ( !! material.normalMap && !! geometry.attributes.tangent ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheenColorMap || !! material.sheenRoughnessMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || material.transmission > 0 || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || material.sheen > 0 || !! material.sheenColorMap || !! material.sheenRoughnessMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog === true,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: !! material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: object.isSkinnedMesh === true,

			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			useDepthPacking: !! material.depthPacking,
			depthPacking: material.depthPacking || 0,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.customVertexShaderID );
			array.push( parameters.customFragmentShaderID );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			getProgramCacheKeyParameters( array, parameters );
			getProgramCacheKeyBooleans( array, parameters );
			array.push( renderer.outputEncoding );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getProgramCacheKeyParameters( array, parameters ) {

		array.push( parameters.precision );
		array.push( parameters.outputEncoding );
		array.push( parameters.envMapMode );
		array.push( parameters.envMapCubeUVHeight );
		array.push( parameters.combine );
		array.push( parameters.vertexUvs );
		array.push( parameters.fogExp2 );
		array.push( parameters.sizeAttenuation );
		array.push( parameters.morphTargetsCount );
		array.push( parameters.morphAttributeCount );
		array.push( parameters.numDirLights );
		array.push( parameters.numPointLights );
		array.push( parameters.numSpotLights );
		array.push( parameters.numHemiLights );
		array.push( parameters.numRectAreaLights );
		array.push( parameters.numDirLightShadows );
		array.push( parameters.numPointLightShadows );
		array.push( parameters.numSpotLightShadows );
		array.push( parameters.shadowMapType );
		array.push( parameters.toneMapping );
		array.push( parameters.numClippingPlanes );
		array.push( parameters.numClipIntersection );
		array.push( parameters.depthPacking );

	}

	function getProgramCacheKeyBooleans( array, parameters ) {

		_programLayers.disableAll();

		if ( parameters.isWebGL2 )
			_programLayers.enable( 0 );
		if ( parameters.supportsVertexTextures )
			_programLayers.enable( 1 );
		if ( parameters.instancing )
			_programLayers.enable( 2 );
		if ( parameters.instancingColor )
			_programLayers.enable( 3 );
		if ( parameters.map )
			_programLayers.enable( 4 );
		if ( parameters.matcap )
			_programLayers.enable( 5 );
		if ( parameters.envMap )
			_programLayers.enable( 6 );
		if ( parameters.lightMap )
			_programLayers.enable( 7 );
		if ( parameters.aoMap )
			_programLayers.enable( 8 );
		if ( parameters.emissiveMap )
			_programLayers.enable( 9 );
		if ( parameters.bumpMap )
			_programLayers.enable( 10 );
		if ( parameters.normalMap )
			_programLayers.enable( 11 );
		if ( parameters.objectSpaceNormalMap )
			_programLayers.enable( 12 );
		if ( parameters.tangentSpaceNormalMap )
			_programLayers.enable( 13 );
		if ( parameters.clearcoat )
			_programLayers.enable( 14 );
		if ( parameters.clearcoatMap )
			_programLayers.enable( 15 );
		if ( parameters.clearcoatRoughnessMap )
			_programLayers.enable( 16 );
		if ( parameters.clearcoatNormalMap )
			_programLayers.enable( 17 );
		if ( parameters.iridescence )
			_programLayers.enable( 18 );
		if ( parameters.iridescenceMap )
			_programLayers.enable( 19 );
		if ( parameters.iridescenceThicknessMap )
			_programLayers.enable( 20 );
		if ( parameters.displacementMap )
			_programLayers.enable( 21 );
		if ( parameters.specularMap )
			_programLayers.enable( 22 );
		if ( parameters.roughnessMap )
			_programLayers.enable( 23 );
		if ( parameters.metalnessMap )
			_programLayers.enable( 24 );
		if ( parameters.gradientMap )
			_programLayers.enable( 25 );
		if ( parameters.alphaMap )
			_programLayers.enable( 26 );
		if ( parameters.alphaTest )
			_programLayers.enable( 27 );
		if ( parameters.vertexColors )
			_programLayers.enable( 28 );
		if ( parameters.vertexAlphas )
			_programLayers.enable( 29 );
		if ( parameters.vertexUvs )
			_programLayers.enable( 30 );
		if ( parameters.vertexTangents )
			_programLayers.enable( 31 );
		if ( parameters.uvsVertexOnly )
			_programLayers.enable( 32 );
		if ( parameters.fog )
			_programLayers.enable( 33 );

		array.push( _programLayers.mask );
		_programLayers.disableAll();

		if ( parameters.useFog )
			_programLayers.enable( 0 );
		if ( parameters.flatShading )
			_programLayers.enable( 1 );
		if ( parameters.logarithmicDepthBuffer )
			_programLayers.enable( 2 );
		if ( parameters.skinning )
			_programLayers.enable( 3 );
		if ( parameters.morphTargets )
			_programLayers.enable( 4 );
		if ( parameters.morphNormals )
			_programLayers.enable( 5 );
		if ( parameters.morphColors )
			_programLayers.enable( 6 );
		if ( parameters.premultipliedAlpha )
			_programLayers.enable( 7 );
		if ( parameters.shadowMapEnabled )
			_programLayers.enable( 8 );
		if ( parameters.physicallyCorrectLights )
			_programLayers.enable( 9 );
		if ( parameters.doubleSided )
			_programLayers.enable( 10 );
		if ( parameters.flipSided )
			_programLayers.enable( 11 );
		if ( parameters.useDepthPacking )
			_programLayers.enable( 12 );
		if ( parameters.dithering )
			_programLayers.enable( 13 );
		if ( parameters.specularIntensityMap )
			_programLayers.enable( 14 );
		if ( parameters.specularColorMap )
			_programLayers.enable( 15 );
		if ( parameters.transmission )
			_programLayers.enable( 16 );
		if ( parameters.transmissionMap )
			_programLayers.enable( 17 );
		if ( parameters.thicknessMap )
			_programLayers.enable( 18 );
		if ( parameters.sheen )
			_programLayers.enable( 19 );
		if ( parameters.sheenColorMap )
			_programLayers.enable( 20 );
		if ( parameters.sheenRoughnessMap )
			_programLayers.enable( 21 );
		if ( parameters.decodeVideoTexture )
			_programLayers.enable( 22 );
		if ( parameters.opaque )
			_programLayers.enable( 23 );

		array.push( _programLayers.mask );

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	function releaseShaderCache( material ) {

		_customShaders.remove( material );

	}

	function dispose() {

		_customShaders.dispose();

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transmissive = [];
	const transparent = [];

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.push( renderItem );

		} else if ( material.transparent === true ) {

			transparent.push( renderItem );

		} else {

			opaque.push( renderItem );

		}

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.unshift( renderItem );

		} else if ( material.transparent === true ) {

			transparent.unshift( renderItem );

		} else {

			opaque.unshift( renderItem );

		}

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		let list;

		if ( lists.has( scene ) === false ) {

			list = new WebGLRenderList();
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= lists.get( scene ).length ) {

				list = new WebGLRenderList();
				lists.get( scene ).push( list );

			} else {

				list = lists.get( scene )[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color$1()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color$1(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color$1(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color$1(),
						groundColor: new Color$1()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color$1(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights, physicallyCorrectLights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;

		lights.sort( shadowCastingLightsFirst );

		// artist-friendly light intensity scaling factor
		const scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions, capabilities ) {

	const lights = new WebGLLights( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( physicallyCorrectLights ) {

		lights.setup( lightsArray, physicallyCorrectLights );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		let renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStates.get( scene ).length ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.get( scene ).push( renderState );

			} else {

				renderState = renderStates.get( scene )[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDepthMaterial = true;

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDistanceMaterial = true;

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap( _renderer, _objects, _capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
		_distanceMaterial = new MeshDistanceMaterial(),

		_materialCache = {},

		_maxTextureSize = _capabilities.maxTextureSize;

	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vertex,
		fragmentShader: fragment

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;

		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

		if ( customMaterial !== undefined ) {

			result = customMaterial;

		} else {

			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

		}

		if ( ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) ||
			( material.displacementMap && material.displacementScale !== 0 ) ||
			( material.alphaMap && material.alphaTest > 0 ) ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	let enabledCapabilities = {};

	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( 35661 );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const scissorParam = gl.getParameter( 3088 );
	const viewportParam = gl.getParameter( 2978 );

	const currentScissor = new Vector4().fromArray( scissorParam );
	const currentViewport = new Vector4().fromArray( viewportParam );

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			if ( isWebGL2 ) {

				// 36009 is equivalent to 36160

				if ( target === 36009 ) {

					currentBoundFramebuffers[ 36160 ] = framebuffer;

				}

				if ( target === 36160 ) {

					currentBoundFramebuffers[ 36009 ] = framebuffer;

				}

			}

			return true;

		}

		return false;

	}

	function drawBuffers( renderTarget, framebuffer ) {

		let drawBuffers = defaultDrawbuffers;

		let needsUpdate = false;

		if ( renderTarget ) {

			drawBuffers = currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				currentDrawbuffers.set( framebuffer, drawBuffers );

			}

			if ( renderTarget.isWebGLMultipleRenderTargets ) {

				const textures = renderTarget.texture;

				if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== 36064 ) {

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						drawBuffers[ i ] = 36064 + i;

					}

					drawBuffers.length = textures.length;

					needsUpdate = true;

				}

			} else {

				if ( drawBuffers[ 0 ] !== 36064 ) {

					drawBuffers[ 0 ] = 36064;

					needsUpdate = true;

				}

			}

		} else {

			if ( drawBuffers[ 0 ] !== 1029 ) {

				drawBuffers[ 0 ] = 1029;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			if ( capabilities.isWebGL2 ) {

				gl.drawBuffers( drawBuffers );

			} else {

				extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

			}

		}


	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 769, 0, 1 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 769, 0, 1 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( 32926 )
			: disable( 32926 );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		let boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage2D() {

		try {

			gl.texSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage3D() {

		try {

			gl.texSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage2D() {

		try {

			gl.compressedTexSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage2D() {

		try {

			gl.texStorage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage3D() {

		try {

			gl.texStorage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( 3042 );
		gl.disable( 2884 );
		gl.disable( 2929 );
		gl.disable( 32823 );
		gl.disable( 3089 );
		gl.disable( 2960 );
		gl.disable( 32926 );

		gl.blendEquation( 32774 );
		gl.blendFunc( 1, 0 );
		gl.blendFuncSeparate( 1, 0, 1, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( 513 );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( 519, 0, 0xffffffff );
		gl.stencilOp( 7680, 7680, 7680 );
		gl.clearStencil( 0 );

		gl.cullFace( 1029 );
		gl.frontFace( 2305 );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( 33984 );

		gl.bindFramebuffer( 36160, null );

		if ( isWebGL2 === true ) {

			gl.bindFramebuffer( 36009, null );
			gl.bindFramebuffer( 36008, null );

		}

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;
	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
	const supportsInvalidateFramebuffer = /OculusBrowser/g.test( navigator.userAgent );

	const _videoTextures = new WeakMap();
	let _canvas;

	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			// eslint-disable-next-line compat/compat
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			// eslint-disable-next-line compat/compat
			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo$1( image ) {

		return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target ) {

		_gl.generateMipmap( target );

	}

	function getInternalFormat( internalFormatName, glFormat, glType, encoding, isVideoTexture = false ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 33319 ) {

			if ( glType === 5126 ) internalFormat = 33328;
			if ( glType === 5131 ) internalFormat = 33327;
			if ( glType === 5121 ) internalFormat = 33323;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = ( encoding === sRGBEncoding && isVideoTexture === false ) ? 35907 : 32856;
			if ( glType === 32819 ) internalFormat = 32854;
			if ( glType === 32820 ) internalFormat = 32855;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 33327 || internalFormat === 33328 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	function getMipLevels( texture, image, supportsMips ) {

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

			return Math.log2( Math.max( image.width, image.height ) ) + 1;

		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

			// user-defined mipmaps

			return texture.mipmaps.length;

		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

			return image.mipmaps.length;

		} else {

			// texture without mipmaps (only base level)

			return 1;

		}

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get( source );

		if ( webglTextures ) {

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
			webglTexture.usedTimes --;

			// the WebGLTexture object is not used anymore, remove it

			if ( webglTexture.usedTimes === 0 ) {

				deleteTexture( texture );

			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if ( Object.keys( webglTextures ).length === 0 ) {

				_sources.delete( source );

			}

		}

		properties.remove( texture );

	}

	function deleteTexture( texture ) {

		const textureProperties = properties.get( texture );
		_gl.deleteTexture( textureProperties.__webglTexture );

		const source = texture.source;
		const webglTextures = _sources.get( source );
		delete webglTextures[ textureProperties.__cacheKey ];

		info.memory.textures --;

	}

	function deallocateRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

			info.memory.textures --;

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

			if ( renderTargetProperties.__webglColorRenderbuffer ) {

				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

			}

			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		if ( renderTarget.isWebGLMultipleRenderTargets ) {

			for ( let i = 0, il = texture.length; i < il; i ++ ) {

				const attachmentProperties = properties.get( texture[ i ] );

				if ( attachmentProperties.__webglTexture ) {

					_gl.deleteTexture( attachmentProperties.__webglTexture );

					info.memory.textures --;

				}

				properties.remove( texture[ i ] );

			}

		}

		properties.remove( texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	function getTextureCacheKey( texture ) {

		const array = [];

		array.push( texture.wrapS );
		array.push( texture.wrapT );
		array.push( texture.magFilter );
		array.push( texture.minFilter );
		array.push( texture.anisotropy );
		array.push( texture.internalFormat );
		array.push( texture.format );
		array.push( texture.type );
		array.push( texture.generateMipmaps );
		array.push( texture.premultiplyAlpha );
		array.push( texture.flipY );
		array.push( texture.unpackAlignment );
		array.push( texture.encoding );

		return array.join();

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === null ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	const filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		let forceUpload = false;

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get( source );

		if ( webglTextures === undefined ) {

			webglTextures = {};
			_sources.set( source, webglTextures );

		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey( texture );

		if ( textureCacheKey !== textureProperties.__cacheKey ) {

			// if not, create a new instance of WebGLTexture

			if ( webglTextures[ textureCacheKey ] === undefined ) {

				// create new entry

				webglTextures[ textureCacheKey ] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};

				info.memory.textures ++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;

			}

			webglTextures[ textureCacheKey ].usedTimes ++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

			if ( webglTexture !== undefined ) {

				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

		}

		return forceUpload;

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = 3553;

		if ( texture.isDataArrayTexture ) textureType = 35866;
		if ( texture.isData3DTexture ) textureType = 32879;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		if ( source.version !== source.__currentVersion || forceUpload === true ) {

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
			let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
			image = verifyColorSpace( texture, image );

			const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
				glFormat = utils.convert( texture.format, texture.encoding );

			let glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture );

			setTextureParameters( textureType, texture, supportsMips );

			let mipmap;
			const mipmaps = texture.mipmaps;

			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
			const allocateMemory = ( source.__currentVersion === undefined ) || ( forceUpload === true );
			const levels = getMipLevels( texture, image, supportsMips );

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if ( isWebGL2 ) {

					if ( texture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( texture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					} else if ( texture.type === UnsignedInt248Type ) {

						glInternalFormat = 35056;

					} else {

						glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

					}

				} else {

					if ( texture.type === FloatType ) {

						console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

					}

				}

				// validation checks for WebGL 1

				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedIntType;
						glType = utils.convert( texture.type );

					}

				}

				if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				//

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( 3553, 1, glInternalFormat, image.width, image.height );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

					}

				}

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

						}

						state.texSubImage2D( 3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				}

			} else if ( texture.isCompressedTexture ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

				}

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat ) {

						if ( glFormat !== null ) {

							if ( useTexStorage ) {

								state.compressedTexSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

							} else {

								state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							}

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				}

			} else if ( texture.isDataArrayTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( 35866, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					state.texSubImage3D( 35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

				} else {

					state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isData3DTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( 32879, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					state.texSubImage3D( 32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

				} else {

					state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isFramebufferTexture ) {

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

					} else {

						let width = image.width, height = image.height;

						for ( let i = 0; i < levels; i ++ ) {

							state.texImage2D( 3553, i, glInternalFormat, width, height, 0, glFormat, glType, null );

							width >>= 1;
							height >>= 1;

						}

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, glFormat, glType, mipmap );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

						}

						state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( textureType );

			}

			source.__currentVersion = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

		if ( source.version !== source.__currentVersion || forceUpload === true ) {

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

			}

			const image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
				glFormat = utils.convert( texture.format, texture.encoding ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
			const allocateMemory = ( source.__currentVersion === undefined ) || ( forceUpload === true );
			let levels = getMipLevels( texture, image, supportsMips );

			setTextureParameters( 34067, texture, supportsMips );

			let mipmaps;

			if ( isCompressed ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( 34067, levels, glInternalFormat, image.width, image.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									state.compressedTexSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

								} else {

									state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else {

				mipmaps = texture.mipmaps;

				if ( useTexStorage && allocateMemory ) {

					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if ( mipmaps.length > 0 ) levels ++;

					state.texStorage2D( 34067, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						if ( useTexStorage ) {

							state.texSubImage2D( 34069 + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

							} else {

								state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

							}

						}

					} else {

						if ( useTexStorage ) {

							state.texSubImage2D( 34069 + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

						} else {

							state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

							} else {

								state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

							}

						}

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( 34067 );

			}

			source.__currentVersion = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

		const glFormat = utils.convert( texture.format, texture.encoding );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
		const renderTargetProperties = properties.get( renderTarget );

		if ( ! renderTargetProperties.__hasExternalTextures ) {

			if ( textureTarget === 32879 || textureTarget === 35866 ) {

				state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

			}

		}

		state.bindFramebuffer( 36160, framebuffer );

		if ( useMultisampledRTT( renderTarget ) ) {

			multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

		} else {

			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );

		}

		state.bindFramebuffer( 36160, null );

	}


	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = 33189;

			if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			const samples = getRenderTargetSamples( renderTarget );

			if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				const glFormat = utils.convert( texture.format, texture.encoding );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		const samples = getRenderTargetSamples( renderTarget );

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 36096, 3553, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

			}

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 33306, 3553, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

			}

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( 36160, null );

	}

	// rebind framebuffer with external textures
	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( colorTexture !== undefined ) {

			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553 );

		}

		if ( depthTexture !== undefined ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

			if ( textureProperties.__webglTexture === undefined ) {

				textureProperties.__webglTexture = _gl.createTexture();

			}

			textureProperties.__version = texture.version;
			info.memory.textures ++;

		}

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultipleRenderTargets ) {

				if ( capabilities.drawBuffers ) {

					const textures = renderTarget.texture;

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						const attachmentProperties = properties.get( textures[ i ] );

						if ( attachmentProperties.__webglTexture === undefined ) {

							attachmentProperties.__webglTexture = _gl.createTexture();

							info.memory.textures ++;

						}

					}

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

				}

			}

			if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				const textures = isMultipleRenderTargets ? texture : [ texture ];

				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];

				state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];
					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					const glFormat = utils.convert( texture.format, texture.encoding );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

				_gl.bindRenderbuffer( 36161, null );

				if ( renderTarget.depthBuffer ) {

					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

				}

				state.bindFramebuffer( 36160, null );

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 34067 );

			}

			state.unbindTexture();

		} else if ( isMultipleRenderTargets ) {

			const textures = renderTarget.texture;

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachment = textures[ i ];
				const attachmentProperties = properties.get( attachment );

				state.bindTexture( 3553, attachmentProperties.__webglTexture );
				setTextureParameters( 3553, attachment, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

				if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

					generateMipmap( 3553 );

				}

			}

			state.unbindTexture();

		} else {

			let glTextureType = 3553;

			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

				if ( isWebGL2 ) {

					glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;

				} else {

					console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );

				}

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( glTextureType );

			}

			state.unbindTexture();

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target );
				state.unbindTexture();

			}

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

			const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];
			const width = renderTarget.width;
			const height = renderTarget.height;
			let mask = 16384;
			const invalidationArray = [];
			const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
			const renderTargetProperties = properties.get( renderTarget );
			const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );

			// If MRT we need to remove FBO attachments
			if ( isMultipleRenderTargets ) {

				for ( let i = 0; i < textures.length; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, null );

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					_gl.framebufferTexture2D( 36009, 36064 + i, 3553, null, 0 );

				}

			}

			state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
			state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

			for ( let i = 0; i < textures.length; i ++ ) {

				invalidationArray.push( 36064 + i );

				if ( renderTarget.depthBuffer ) {

					invalidationArray.push( depthStyle );

				}

				const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

				if ( ignoreDepthValues === false ) {

					if ( renderTarget.depthBuffer ) mask |= 256;
					if ( renderTarget.stencilBuffer ) mask |= 1024;

				}

				if ( isMultipleRenderTargets ) {

					_gl.framebufferRenderbuffer( 36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

				if ( ignoreDepthValues === true ) {

					_gl.invalidateFramebuffer( 36008, [ depthStyle ] );
					_gl.invalidateFramebuffer( 36009, [ depthStyle ] );

				}

				if ( isMultipleRenderTargets ) {

					const webglTexture = properties.get( textures[ i ] ).__webglTexture;
					_gl.framebufferTexture2D( 36009, 36064, 3553, webglTexture, 0 );

				}

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				if ( supportsInvalidateFramebuffer ) {

					_gl.invalidateFramebuffer( 36008, invalidationArray );

				}


			}

			state.bindFramebuffer( 36008, null );
			state.bindFramebuffer( 36009, null );

			// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
			if ( isMultipleRenderTargets ) {

				for ( let i = 0; i < textures.length; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					const webglTexture = properties.get( textures[ i ] ).__webglTexture;

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					_gl.framebufferTexture2D( 36009, 36064 + i, 3553, webglTexture, 0 );

				}

			}

			state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return Math.min( maxSamples, renderTarget.samples );

	}

	function useMultisampledRTT( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	function verifyColorSpace( texture, image ) {

		const encoding = texture.encoding;
		const format = texture.format;
		const type = texture.type;

		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat ) return image;

		if ( encoding !== LinearEncoding ) {

			// sRGB

			if ( encoding === sRGBEncoding ) {

				if ( isWebGL2 === false ) {

					// in WebGL 1, try to use EXT_sRGB extension and unsized formats

					if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

						texture.format = _SRGBAFormat;

						// it's not possible to generate mips in WebGL 1 with this extension

						texture.minFilter = LinearFilter;
						texture.generateMipmaps = false;

					} else {

						// slow fallback (CPU decode)

						image = ImageUtils.sRGBToLinear( image );

					}

				} else {

					// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

					if ( format !== RGBAFormat || type !== UnsignedByteType ) {

						console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

					}

				}

			} else {

				console.error( 'THREE.WebGLTextures: Unsupported texture encoding:', encoding );

			}

		}

		return image;

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;

}

function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p, encoding = null ) {

		let extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		if ( p === RGBFormat ) {

			console.warn( 'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228' );
			return 6408;

		}

		// WebGL 1 sRGB fallback

		if ( p === _SRGBAFormat ) {

			extension = extensions.get( 'EXT_sRGB' );

			if ( extension !== null ) {

				return extension.SRGB_ALPHA_EXT;

			} else {

				return null;

			}

		}

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBAIntegerFormat ) return 36249;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( encoding === sRGBEncoding ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC1

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		// ETC2

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	return { convert: convert };

}

class ArrayCamera extends PerspectiveCamera {

	constructor( array = [] ) {

		super();

		this.isArrayCamera = true;

		this.cameras = array;

	}

}

class Group extends Object3D {

	constructor() {

		super();

		this.isGroup = true;

		this.type = 'Group';

	}

}

const _moveEvent = { type: 'move' };

class WebXRController {

	constructor() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[ inputjoint.jointName ] = joint;
						// ??
						hand.add( joint );

					}

					const joint = hand.joints[ inputjoint.jointName ];

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

}

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isDepthTexture = true;

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps = false;

	}


}

class WebXRManager extends EventDispatcher {

	constructor( renderer, gl ) {

		super();

		const scope = this;

		let session = null;
		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';
		let customReferenceSpace = null;

		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;
		const attributes = gl.getContextAttributes();
		let initialRenderTarget = null;
		let newRenderTarget = null;

		const controllers = [];
		const inputSourcesMap = new Map();

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controller = inputSourcesMap.get( event.inputSource );

			if ( controller !== undefined ) {

				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			session.removeEventListener( 'select', onSessionEvent );
			session.removeEventListener( 'selectstart', onSessionEvent );
			session.removeEventListener( 'selectend', onSessionEvent );
			session.removeEventListener( 'squeeze', onSessionEvent );
			session.removeEventListener( 'squeezestart', onSessionEvent );
			session.removeEventListener( 'squeezeend', onSessionEvent );
			session.removeEventListener( 'end', onSessionEnd );
			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

			inputSourcesMap.forEach( function ( controller, inputSource ) {

				if ( controller !== undefined ) {

					controller.disconnect( inputSource );

				}

			} );

			inputSourcesMap.clear();

			_currentDepthNear = null;
			_currentDepthFar = null;

			// restore framebuffer/rendering state

			renderer.setRenderTarget( initialRenderTarget );

			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();

			scope.isPresenting = false;

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return customReferenceSpace || referenceSpace;

		};

		this.setReferenceSpace = function ( space ) {

			customReferenceSpace = space;

		};

		this.getBaseLayer = function () {

			return glProjLayer !== null ? glProjLayer : glBaseLayer;

		};

		this.getBinding = function () {

			return glBinding;

		};

		this.getFrame = function () {

			return xrFrame;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				initialRenderTarget = renderer.getRenderTarget();

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

					const layerInit = {
						antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: glBaseLayer } );

					newRenderTarget = new WebGLRenderTarget(
						glBaseLayer.framebufferWidth,
						glBaseLayer.framebufferHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							encoding: renderer.outputEncoding
						}
					);

				} else {

					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;

					if ( attributes.depth ) {

						glDepthFormat = attributes.stencil ? 35056 : 33190;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

					}

					const projectionlayerInit = {
						colorFormat: ( renderer.outputEncoding === sRGBEncoding ) ? 35907 : 32856,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};

					glBinding = new XRWebGLBinding( session, gl );

					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					session.updateRenderState( { layers: [ glProjLayer ] } );

					newRenderTarget = new WebGLRenderTarget(
						glProjLayer.textureWidth,
						glProjLayer.textureHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
							stencilBuffer: attributes.stencil,
							encoding: renderer.outputEncoding,
							samples: attributes.antialias ? 4 : 0
						} );

					const renderTargetProperties = renderer.properties.get( newRenderTarget );
					renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

				}

				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				// Set foveation to maximum.
				this.setFoveation( 1.0 );

				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		function onInputSourcesChange( event ) {

			const inputSources = session.inputSources;

			// Assign controllers to available inputSources

			for ( let i = 0; i < inputSources.length; i ++ ) {

				const index = inputSources[ i ].handedness === 'right' ? 1 : 0;
				inputSourcesMap.set( inputSources[ i ], controllers[ index ] );

			}

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					inputSourcesMap.delete( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'connected', data: inputSource } );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.updateCamera = function ( camera ) {

			if ( session === null ) return;

			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				} );

				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;

			}

			const parent = camera.parent;
			const cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

			// update user camera and its children

			camera.position.copy( cameraVR.position );
			camera.quaternion.copy( cameraVR.quaternion );
			camera.scale.copy( cameraVR.scale );
			camera.matrix.copy( cameraVR.matrix );
			camera.matrixWorld.copy( cameraVR.matrixWorld );

			const children = camera.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( true );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

		};

		this.getCamera = function () {

			return cameraVR;

		};

		this.getFoveation = function () {

			if ( glProjLayer !== null ) {

				return glProjLayer.fixedFoveation;

			}

			if ( glBaseLayer !== null ) {

				return glBaseLayer.fixedFoveation;

			}

			return undefined;

		};

		this.setFoveation = function ( foveation ) {

			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			if ( glProjLayer !== null ) {

				glProjLayer.fixedFoveation = foveation;

			}

			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

				glBaseLayer.fixedFoveation = foveation;

			}

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
			xrFrame = frame;

			if ( pose !== null ) {

				const views = pose.views;

				if ( glBaseLayer !== null ) {

					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
					renderer.setRenderTarget( newRenderTarget );

				}

				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if ( views.length !== cameraVR.cameras.length ) {

					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];

					let viewport = null;

					if ( glBaseLayer !== null ) {

						viewport = glBaseLayer.getViewport( view );

					} else {

						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if ( i === 0 ) {

							renderer.setRenderTargetTextures(
								newRenderTarget,
								glSubImage.colorTexture,
								glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

							renderer.setRenderTarget( newRenderTarget );

						}

					}

					let camera = cameras[ i ];

					if ( camera === undefined ) {

						camera = new PerspectiveCamera();
						camera.layers.enable( i );
						camera.viewport = new Vector4();
						cameras[ i ] = camera;

					}

					camera.matrix.fromArray( view.transform.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

					if ( cameraVRNeedsUpdate === true ) {

						cameraVR.cameras.push( camera );

					}

				}

			}

			//

			const inputSources = session.inputSources;

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = inputSources[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller !== undefined ) {

					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

				}

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

			xrFrame = null;

		}

		const animation = new WebGLAnimation();

		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

}

function WebGLMaterials( renderer, properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsStandard( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( renderer.physicallyCorrectLights !== true ) ? Math.PI : 1;

			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map
		// 13. iridescence map
		// 14. iridescence thickness map
		// 15. specular intensity map
		// 16. specular tint map
		// 17. transmission map
		// 18. thickness map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		} else if ( material.iridescenceMap ) {

			uvScaleMap = material.iridescenceMap;

		} else if ( material.iridescenceThicknessMap ) {

			uvScaleMap = material.iridescenceThicknessMap;

		} else if ( material.specularIntensityMap ) {

			uvScaleMap = material.specularIntensityMap;

		} else if ( material.specularColorMap ) {

			uvScaleMap = material.specularColorMap;

		} else if ( material.transmissionMap ) {

			uvScaleMap = material.transmissionMap;

		} else if ( material.thicknessMap ) {

			uvScaleMap = material.thicknessMap;

		} else if ( material.sheenColorMap ) {

			uvScaleMap = material.sheenColorMap;

		} else if ( material.sheenRoughnessMap ) {

			uvScaleMap = material.sheenRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		uniforms.ior.value = material.ior; // also part of uniforms common

		if ( material.sheen > 0 ) {

			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

			uniforms.sheenRoughness.value = material.sheenRoughness;

			if ( material.sheenColorMap ) {

				uniforms.sheenColorMap.value = material.sheenColorMap;

			}

			if ( material.sheenRoughnessMap ) {

				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

			}

		}

		if ( material.clearcoat > 0 ) {

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

		}

		if ( material.iridescence > 0 ) {

			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

			if ( material.iridescenceMap ) {

				uniforms.iridescenceMap.value = material.iridescenceMap;

			}

			if ( material.iridescenceThicknessMap ) {

				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

			}

		}

		if ( material.transmission > 0 ) {

			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

			}

			uniforms.thickness.value = material.thickness;

			if ( material.thicknessMap ) {

				uniforms.thicknessMap.value = material.thicknessMap;

			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy( material.attenuationColor );

		}

		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy( material.specularColor );

		if ( material.specularIntensityMap ) {

			uniforms.specularIntensityMap.value = material.specularIntensityMap;

		}

		if ( material.specularColorMap ) {

			uniforms.specularColorMap.value = material.specularColorMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters = {} ) {

	this.isWebGLRenderer = true;

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let _alpha;

	if ( _context !== null ) {

		_alpha = _context.getContextAttributes().alpha;

	} else {

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false;

	}

	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	//

	Object.defineProperties( this, {

		// @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d

		gammaFactor: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );
				return 2;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );

			}
		}

	} );

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;

	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new Vector4( 0, 0, _width, _height );
	const _scissor = new Vector4( 0, 0, _width, _height );
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// transmission

	let _transmissionRenderTarget = null;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();

	const _vector2 = new Vector2();
	const _vector3 = new Vector3();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: true,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// OffscreenCanvas does not have setAttribute, see #22811
		if ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

		// event listeners must be registered before WebGL context is created, see #12753
		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
		_canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		extensions.init( capabilities );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );

		info = new WebGLInfo();
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new WebGLCubeMaps( _this );
		cubeuvmaps = new WebGLCubeUVMaps( _this );
		attributes = new WebGLAttributes( _gl, capabilities );
		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
		clipping = new WebGLClipping( properties );
		programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
		materials = new WebGLMaterials( _this, properties );
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates( extensions, capabilities );
		background = new WebGLBackground( _this, cubemaps, state, objects, _alpha, _premultipliedAlpha );
		shadowMap = new WebGLShadowMap( _this, objects, capabilities );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function ( target ) {

		return target.copy( background.getClearColor() );

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color = true, depth = true, stencil = true ) {

		let bits = 0;

		if ( color ) bits |= 16384;
		if ( depth ) bits |= 256;
		if ( stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
		_canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		cubeuvmaps.dispose();
		objects.dispose();
		bindingStates.dispose();
		programCache.dispose();

		xr.dispose();

		xr.removeEventListener( 'sessionstart', onXRSessionStart );
		xr.removeEventListener( 'sessionend', onXRSessionEnd );

		if ( _transmissionRenderTarget ) {

			_transmissionRenderTarget.dispose();
			_transmissionRenderTarget = null;

		}

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;

		initGLContext();

		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;

	}

	function onContextCreationError( event ) {

		console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReferences( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReferences( material ) {

		const programs = properties.get( material ).programs;

		if ( programs !== undefined ) {

			programs.forEach( function ( program ) {

				programCache.releaseProgram( program );

			} );

			if ( material.isShaderMaterial ) {

				programCache.releaseShaderCache( material );

			}

		}

	}

	// Buffer rendering

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, geometry, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		const dataCount = ( index !== null ) ? index.count : position.count;

		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;

		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		const drawStart = Math.max( rangeStart, groupStart );
		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( _this.physicallyCorrectLights );

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						getProgram( material2, scene, object );

					}

				} else {

					getProgram( material, scene, object );

				}

			}

		} );

		renderStateStack.pop();
		currentRenderState = null;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	function onXRSessionStart() {

		animation.stop();

	}

	function onXRSessionEnd() {

		animation.start();

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof self !== 'undefined' ) animation.setContext( self );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	xr.addEventListener( 'sessionstart', onXRSessionStart );
	xr.addEventListener( 'sessionend', onXRSessionEnd );

	// Rendering

	this.render = function ( scene, camera ) {

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

			camera = xr.getCamera(); // use XR camera for rendering

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

		currentRenderState = renderStates.get( scene, renderStateStack.length );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, renderListStack.length );
		currentRenderList.init();

		renderListStack.push( currentRenderList );

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		//

		background.render( currentRenderList, scene );

		// render scene

		currentRenderState.setupLights( _this.physicallyCorrectLights );

		if ( camera.isArrayCamera ) {

			const cameras = camera.cameras;

			for ( let i = 0, l = cameras.length; i < l; i ++ ) {

				const camera2 = cameras[ i ];

				renderScene( currentRenderList, scene, camera2, camera2.viewport );

			}

		} else {

			renderScene( currentRenderList, scene, camera );

		}

		//

		if ( _currentRenderTarget !== null ) {

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

		}

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		renderStateStack.pop();

		if ( renderStateStack.length > 0 ) {

			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		} else {

			currentRenderState = null;

		}

		renderListStack.pop();

		if ( renderListStack.length > 0 ) {

			currentRenderList = renderListStack[ renderListStack.length - 1 ];

		} else {

			currentRenderList = null;

		}

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderScene( currentRenderList, scene, camera, viewport ) {

		const opaqueObjects = currentRenderList.opaque;
		const transmissiveObjects = currentRenderList.transmissive;
		const transparentObjects = currentRenderList.transparent;

		currentRenderState.setupLightsView( camera );

		if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );

		if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

	}

	function renderTransmissionPass( opaqueObjects, scene, camera ) {

		const isWebGL2 = capabilities.isWebGL2;

		if ( _transmissionRenderTarget === null ) {

			_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
				generateMipmaps: true,
				type: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,
				minFilter: LinearMipmapLinearFilter,
				samples: ( isWebGL2 && _antialias === true ) ? 4 : 0
			} );

		}

		_this.getDrawingBufferSize( _vector2 );

		if ( isWebGL2 ) {

			_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );

		} else {

			_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );

		}

		//

		const currentRenderTarget = _this.getRenderTarget();
		_this.setRenderTarget( _transmissionRenderTarget );
		_this.clear();

		// Turn off the features which can affect the frag color for opaque objects pass.
		// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		const currentToneMapping = _this.toneMapping;
		_this.toneMapping = NoToneMapping;

		renderObjects( opaqueObjects, scene, camera );

		_this.toneMapping = currentToneMapping;

		textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
		textures.updateRenderTargetMipmap( _transmissionRenderTarget );

		_this.setRenderTarget( currentRenderTarget );

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( object.layers.test( camera.layers ) ) {

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		material.onBeforeRender( _this, scene, camera, geometry, object, group );

		if ( material.transparent === true && material.side === DoubleSide ) {

			material.side = BackSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = FrontSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = DoubleSide;

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function getProgram( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

		if ( programs === undefined ) {

			// new material

			material.addEventListener( 'dispose', onMaterialDispose );

			programs = new Map();
			materialProperties.programs = programs;

		}

		let program = programs.get( programCacheKey );

		if ( program !== undefined ) {

			// early out if program and light state is identical

			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				updateCommonMaterialProperties( material, parameters );

				return program;

			}

		} else {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBuild( object, parameters, _this );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );
			programs.set( programCacheKey, program );

			materialProperties.uniforms = parameters.uniforms;

		}

		const uniforms = materialProperties.uniforms;

		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			uniforms.clippingPlanes = clipping.uniform;

		}

		updateCommonMaterialProperties( material, parameters );

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;

		return program;

	}

	function updateCommonMaterialProperties( material, parameters ) {

		const materialProperties = properties.get( material );

		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.skinning = parameters.skinning;
		materialProperties.morphTargets = parameters.morphTargets;
		materialProperties.morphNormals = parameters.morphNormals;
		materialProperties.morphColors = parameters.morphColors;
		materialProperties.morphTargetsCount = parameters.morphTargetsCount;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;
		materialProperties.vertexTangents = parameters.vertexTangents;
		materialProperties.toneMapping = parameters.toneMapping;

	}

	function setProgram( camera, scene, geometry, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );
		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
		const vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;
		const morphTargets = !! geometry.morphAttributes.position;
		const morphNormals = !! geometry.morphAttributes.normal;
		const morphColors = !! geometry.morphAttributes.color;
		const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		//

		let needsProgramChange = false;

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.outputEncoding !== encoding ) {

				needsProgramChange = true;

			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				needsProgramChange = true;

			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				needsProgramChange = true;

			} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

				needsProgramChange = true;

			} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

				needsProgramChange = true;

			} else if ( materialProperties.envMap !== envMap ) {

				needsProgramChange = true;

			} else if ( material.fog === true && materialProperties.fog !== fog ) {

				needsProgramChange = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexTangents !== vertexTangents ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphTargets !== morphTargets ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphNormals !== morphNormals ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphColors !== morphColors ) {

				needsProgramChange = true;

			} else if ( materialProperties.toneMapping !== toneMapping ) {

				needsProgramChange = true;

			} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

				needsProgramChange = true;

			}

		} else {

			needsProgramChange = true;
			materialProperties.__version = material.version;

		}

		//

		let program = materialProperties.currentProgram;

		if ( needsProgramChange === true ) {

			program = getProgram( material, scene, object );

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				object.isSkinnedMesh ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning and morph target uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone and morph texture must go before other textures
		// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

		if ( object.isSkinnedMesh ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					console.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );

				}

			}

		}

		const morphAttributes = geometry.morphAttributes;

		if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

			morphtargets.update( object, geometry, material, program );

		}


		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog === true ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

		properties.get( renderTarget.texture ).__webglTexture = colorTexture;
		properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

		const renderTargetProperties = properties.get( renderTarget );
		renderTargetProperties.__hasExternalTextures = true;

		if ( renderTargetProperties.__hasExternalTextures ) {

			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

			if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

					console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
					renderTargetProperties.__useRenderToTexture = false;

				}

			}

		}

	};

	this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

		const renderTargetProperties = properties.get( renderTarget );
		renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
		renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		let useDefaultFramebuffer = true;

		if ( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

				// We need to make sure to rebind the framebuffer.
				state.bindFramebuffer( 36160, null );
				useDefaultFramebuffer = false;

			} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			} else if ( renderTargetProperties.__hasExternalTextures ) {

				// Color and depth texture must be rebound in order for the swapchain to update.
				textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

			}

		}

		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;

		if ( renderTarget ) {

			const texture = renderTarget.texture;

			if ( texture.isData3DTexture || texture.isDataArrayTexture ) {

				isRenderTarget3D = true;

			}

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

		if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

			state.drawBuffers( renderTarget, framebuffer );

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		} else if ( isRenderTarget3D ) {

			const textureProperties = properties.get( renderTarget.texture );
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		}

		_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			state.bindFramebuffer( 36160, framebuffer );

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! halfFloatSupportedByExt ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

				if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

					_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

				}

			} finally {

				// restore framebuffer of current render target if necessary

				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				state.bindFramebuffer( 36160, framebuffer );

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexSubImage2D( 3553, level, 0, 0, position.x, position.y, width, height );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		if ( _this.isWebGL1Renderer ) {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			return;

		}

		const width = sourceBox.max.x - sourceBox.min.x + 1;
		const height = sourceBox.max.y - sourceBox.min.y + 1;
		const depth = sourceBox.max.z - sourceBox.min.z + 1;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );
		let glTarget;

		if ( dstTexture.isData3DTexture ) {

			textures.setTexture3D( dstTexture, 0 );
			glTarget = 32879;

		} else if ( dstTexture.isDataArrayTexture ) {

			textures.setTexture2DArray( dstTexture, 0 );
			glTarget = 35866;

		} else {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			return;

		}

		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		const unpackRowLen = _gl.getParameter( 3314 );
		const unpackImageHeight = _gl.getParameter( 32878 );
		const unpackSkipPixels = _gl.getParameter( 3316 );
		const unpackSkipRows = _gl.getParameter( 3315 );
		const unpackSkipImages = _gl.getParameter( 32877 );

		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

		_gl.pixelStorei( 3314, image.width );
		_gl.pixelStorei( 32878, image.height );
		_gl.pixelStorei( 3316, sourceBox.min.x );
		_gl.pixelStorei( 3315, sourceBox.min.y );
		_gl.pixelStorei( 32877, sourceBox.min.z );

		if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

			_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
				_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

			} else {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

			}

		}

		_gl.pixelStorei( 3314, unpackRowLen );
		_gl.pixelStorei( 32878, unpackImageHeight );
		_gl.pixelStorei( 3316, unpackSkipPixels );
		_gl.pixelStorei( 3315, unpackSkipRows );
		_gl.pixelStorei( 32877, unpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	this.resetState = function () {

		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;

		state.reset();
		bindingStates.reset();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

	}

}

class WebGL1Renderer extends WebGLRenderer {}

WebGL1Renderer.prototype.isWebGL1Renderer = true;

class Scene extends Object3D {

	constructor() {

		super();

		this.isScene = true;

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

}

class InterleavedBuffer {

	constructor( array, stride ) {

		this.isInterleavedBuffer = true;

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$6 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.isInterleavedBufferAttribute = true;

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	setX( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	}

	getY( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	}

	getZ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	}

	getW( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interlaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isSpriteMaterial = true;

		this.type = 'SpriteMaterial';

		this.color = new Color$1( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector$5 = /*@__PURE__*/ new Vector3();
const _matrix$3 = /*@__PURE__*/ new Matrix4();

class SkinnedMesh extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isSkinnedMesh = true;

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	}

	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	pose() {

		this.skeleton.pose();

	}

	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.fromBufferAttribute( skinWeight, i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	boneTransform( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix$3.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix$3 ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

}

class Bone extends Object3D {

	constructor() {

		super();

		this.isBone = true;

		this.type = 'Bone';

	}

}

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.isDataTexture = true;

		this.image = { data: data, width: width, height: height };

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = ceilPowerOfTwo( size );
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
		boneTexture.needsUpdate = true;

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;
		this.boneTextureSize = size;

		return this;

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		this.color = new Color$1( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

const _start$1 = /*@__PURE__*/ new Vector3();
const _end$1 = /*@__PURE__*/ new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

class Line$1 extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		this.isLine = true;

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [ 0 ];

			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

				_start$1.fromBufferAttribute( positionAttribute, i - 1 );
				_end$1.fromBufferAttribute( positionAttribute, i );

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += _start$1.distanceTo( _end$1 );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const a = index.getX( i );
				const b = index.getX( i + 1 );

				vStart.fromBufferAttribute( positionAttribute, a );
				vEnd.fromBufferAttribute( positionAttribute, b );

				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				vStart.fromBufferAttribute( positionAttribute, i );
				vEnd.fromBufferAttribute( positionAttribute, i + 1 );

				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

class LineSegments extends Line$1 {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineSegments = true;

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];

			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

				_start.fromBufferAttribute( positionAttribute, i );
				_end.fromBufferAttribute( positionAttribute, i + 1 );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

}

class LineLoop extends Line$1 {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineLoop = true;

		this.type = 'LineLoop';

	}

}

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		this.color = new Color$1( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.isPoints = true;

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

//

new Vector3();

new Vector3();
new Vector3();
new Vector3();
new Triangle();

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();
		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShadowMaterial = true;

		this.type = 'ShadowMaterial';

		this.color = new Color$1( 0x000000 );
		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.fog = source.fog;

		return this;

	}

}

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.isRawShaderMaterial = true;

		this.type = 'RawShaderMaterial';

	}

}

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshStandardMaterial = true;

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color$1( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color$1( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.iridescenceMap = null;
		this.iridescenceIOR = 1.3;
		this.iridescenceThicknessRange = [ 100, 400 ];
		this.iridescenceThicknessMap = null;

		this.sheenColor = new Color$1( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = 0.0;
		this.attenuationColor = new Color$1( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color$1( 1, 1, 1 );
		this.specularColorMap = null;

		this._sheen = 0.0;
		this._clearcoat = 0;
		this._iridescence = 0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshPhongMaterial = true;

		this.type = 'MeshPhongMaterial';

		this.color = new Color$1( 0xffffff ); // diffuse
		this.specular = new Color$1( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color$1( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshToonMaterial = true;

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color$1( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color$1( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshNormalMaterial = true;

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		this.color = new Color$1( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color$1( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshMatcapMaterial = true;

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color$1( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.isLineDashedMaterial = true;

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

const materialLib = {
	ShadowMaterial,
	SpriteMaterial,
	RawShaderMaterial,
	ShaderMaterial,
	PointsMaterial,
	MeshPhysicalMaterial,
	MeshStandardMaterial,
	MeshPhongMaterial,
	MeshToonMaterial,
	MeshNormalMaterial,
	MeshLambertMaterial,
	MeshDepthMaterial,
	MeshDistanceMaterial,
	MeshBasicMaterial,
	MeshMatcapMaterial,
	LineDashedMaterial,
	LineBasicMaterial,
	Material
};

Material.fromType = function ( type ) {

	return new materialLib[ type ]();

};

const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

		this.settings = null;
		this.DefaultSettings_ = {};

	}

	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_( i1 - 1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.copySampleValue_( 0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.copySampleValue_( 0 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_( i1 - 1 );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	// Template methods for derived classes:

	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

class LinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = AnimationUtils.arraySlice( this.times, 0 );
		const values = AnimationUtils.arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * fps;

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

class LoadingManager {

	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

const DefaultLoadingManager = new LoadingManager();

class Loader {

	constructor( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	load( /* url, onLoad, onProgress, onError */ ) {}

	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	parse( /* data */ ) {}

	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	setPath( path ) {

		this.path = path;
		return this;

	}

	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

const loading = {};

class FileLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();
					const contentLength = response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw Error( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}` );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === undefined ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class TextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.isLight = true;

		this.type = 'Light';

		this.color = new Color$1( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.isSpotLightShadow = true;

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		super( color, intensity );

		this.isSpotLight = true;

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 1 ) {

		super( color, intensity );

		this.isPointLight = true;

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		this.isDirectionalLightShadow = true;

	}

}

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isAmbientLight = true;

		this.type = 'AmbientLight';

	}

}

class LoaderUtils {

	static decodeText( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	}

	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.slice( 0, index + 1 );

	}

	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

class ImageBitmapLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.isImageBitmapLoader = true;

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.options = { premultiplyAlpha: 'none' };

	}

	setOptions( options ) {

		this.options = options;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {

	constructor( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( matches === null ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	static findNode( root, nodeName ) {

		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	// create getter / setter pair for a property in the scene graph
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( ! targetObject.geometry.morphAttributes ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
					return;

				}

				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

class Raycaster {

	constructor( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	setFromCamera( coords, camera ) {

		if ( camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	intersectObject( object, recursive = true, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _baseTable = new Uint32Array( 512 );
const _shiftTable = new Uint32Array( 512 );

for ( let i = 0; i < 256; ++ i ) {

	const e = i - 127;

	// very small number (0, -0)

	if ( e < - 27 ) {

		_baseTable[ i ] = 0x0000;
		_baseTable[ i | 0x100 ] = 0x8000;
		_shiftTable[ i ] = 24;
		_shiftTable[ i | 0x100 ] = 24;

		// small number (denorm)

	} else if ( e < - 14 ) {

		_baseTable[ i ] = 0x0400 >> ( - e - 14 );
		_baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
		_shiftTable[ i ] = - e - 1;
		_shiftTable[ i | 0x100 ] = - e - 1;

		// normal number

	} else if ( e <= 15 ) {

		_baseTable[ i ] = ( e + 15 ) << 10;
		_baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
		_shiftTable[ i ] = 13;
		_shiftTable[ i | 0x100 ] = 13;

		// large number (Infinity, -Infinity)

	} else if ( e < 128 ) {

		_baseTable[ i ] = 0x7c00;
		_baseTable[ i | 0x100 ] = 0xfc00;
		_shiftTable[ i ] = 24;
		_shiftTable[ i | 0x100 ] = 24;

		// stay (NaN, Infinity, -Infinity)

	} else {

		_baseTable[ i ] = 0x7c00;
		_baseTable[ i | 0x100 ] = 0xfc00;
		_shiftTable[ i ] = 13;
		_shiftTable[ i | 0x100 ] = 13;

	}

}

// float16 to float32 helpers

const _mantissaTable = new Uint32Array( 2048 );
const _exponentTable = new Uint32Array( 64 );
const _offsetTable = new Uint32Array( 64 );

for ( let i = 1; i < 1024; ++ i ) {

	let m = i << 13; // zero pad mantissa bits
	let e = 0; // zero exponent

	// normalized
	while ( ( m & 0x00800000 ) === 0 ) {

		m <<= 1;
		e -= 0x00800000; // decrement exponent

	}

	m &= ~ 0x00800000; // clear leading 1 bit
	e += 0x38800000; // adjust bias

	_mantissaTable[ i ] = m | e;

}

for ( let i = 1024; i < 2048; ++ i ) {

	_mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

}

for ( let i = 1; i < 31; ++ i ) {

	_exponentTable[ i ] = i << 23;

}

_exponentTable[ 31 ] = 0x47800000;
_exponentTable[ 32 ] = 0x80000000;
for ( let i = 33; i < 63; ++ i ) {

	_exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

}

_exponentTable[ 63 ] = 0xc7800000;

for ( let i = 1; i < 64; ++ i ) {

	if ( i !== 32 ) {

		_offsetTable[ i ] = 1024;

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };

class OrbitControls extends EventDispatcher {

	constructor( object, domElement ) {

		super();

		if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
		if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new Vector3();

			// so camera.up is the orbit axis
			const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new Vector3();
			const lastQuaternion = new Quaternion();

			const twoPI = 2 * Math.PI;

			return function update() {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				scale = 1;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );


			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();

		let scale = 1;
		const panOffset = new Vector3();
		let zoomChanged = false;

		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();
		const rotateDelta = new Vector2();

		const panStart = new Vector2();
		const panEnd = new Vector2();
		const panDelta = new Vector2();

		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();
		const dollyDelta = new Vector2();

		const pointers = [];
		const pointerPositions = {};

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new Vector3();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate() {

			if ( pointers.length === 1 ) {

				rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan() {

			if ( pointers.length === 1 ) {

				panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly() {

			const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
			const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enablePan ) handleTouchStartPan();

		}

		function handleTouchStartDollyRotate() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enableRotate ) handleTouchStartRotate();

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

		    removePointer( event );

		    if ( pointers.length === 0 ) {

		        scope.domElement.releasePointerCapture( event.pointerId );

		        scope.domElement.removeEventListener( 'pointermove', onPointerMove );
		        scope.domElement.removeEventListener( 'pointerup', onPointerUp );

		    }

		    scope.dispatchEvent( _endEvent );

		    state = STATE.NONE;

		}

		function onPointerCancel( event ) {

			removePointer( event );

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( event );

			scope.dispatchEvent( _endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate();

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan();

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan();

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate();

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ].pointerId == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointer.pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		// force an update at start

		this.update();

	}

}

const _viewVector = new Vector3();
const _u$2$1 = new Vector3();
class Face {
    index;
    triangle = new Triangle();
    normal = new Vector3();
    midpoint = new Vector3();
    constructor(index, a, b, c) {
        this.index = index;
        this.triangle.set(a.position, b.position, c.position);
        this.triangle.getNormal(this.normal);
        this.triangle.getMidpoint(this.midpoint);
    }
    isFront(position) {
        return _viewVector
            .subVectors(position, this.midpoint)
            .normalize()
            .dot(this.normal) >= 0;
    }
    halfEdgeFromPosition(position, tolerance = 1e-10) {
        const startHalfEdge = this.halfEdge;
        let halfEdge = startHalfEdge;
        do {
            if (halfEdge.containsPoint(position, tolerance)) {
                return halfEdge;
            }
            halfEdge = halfEdge.next;
        } while (halfEdge != startHalfEdge);
        return null;
    }
    vertexFromPosition(position, tolerance = 1e-10) {
        const startHalfEdge = this.halfEdge;
        let halfEdge = startHalfEdge;
        do {
            _u$2$1.subVectors(halfEdge.vertex.position, position);
            if (_u$2$1.length() < tolerance) {
                return halfEdge.vertex;
            }
            halfEdge = halfEdge.next;
        } while (halfEdge != startHalfEdge);
        return null;
    }
    halfEdgeFromVertex(vertex) {
        const startHalfEdge = this.halfEdge;
        let halfEdge = startHalfEdge;
        do {
            if (halfEdge.vertex === vertex) {
                return halfEdge;
            }
            halfEdge = halfEdge.next;
        } while (halfEdge != startHalfEdge);
        return null;
    }
}

const _u$1$1 = new Vector3();
class Vertex {
    index;
    position;
    normal;
    halfEdges = new Array();
    constructor(index, position, normal) {
        this.index = index;
        this.position = position;
        this.normal = normal;
    }
    connectedBoundaryHalfEdges() {
        const array = new Array();
        for (const halfEdge of this.halfEdges) {
            if (!halfEdge.twin) {
                array.push(halfEdge);
            }
            if (!halfEdge.prev.twin) {
                array.push(halfEdge.prev);
            }
        }
        return array;
    }
    matchesPosition(position, tolerance = 1e-10) {
        _u$1$1.subVectors(position, this.position);
        return _u$1$1.length() < tolerance;
    }
}

const EPSILON$2 = 1e-10;
const _matrix$2 = new Matrix4();
function orient3D$2(a, b, c, d) {
    _matrix$2.set(a.x, a.y, a.z, 1, b.x, b.y, b.z, 1, c.x, c.y, c.z, 1, d.x, d.y, d.z, 1);
    const det = _matrix$2.determinant();
    if (det > EPSILON$2) {
        return 1;
    }
    else if (det < -EPSILON$2) {
        return -1;
    }
    return 0;
}
function frontSide$1(a, b, c, d) {
    return orient3D$2(d, b, c, a);
}

const _u$4 = new Vector3();
const _v$3 = new Vector3();
const _line = new Line3();
class HalfEdge {
    face;
    vertex;
    twin;
    constructor(face, vertex) {
        this.face = face;
        this.vertex = vertex;
    }
    containsPoint(point, tolerance = 1e-10) {
        _u$4.subVectors(this.vertex.position, point);
        _v$3.subVectors(this.next.vertex.position, point);
        _line.set(this.vertex.position, this.next.vertex.position);
        _line.closestPointToPoint(point, true, _u$4);
        console.log(_u$4.distanceTo(point));
        return _u$4.distanceTo(point) < tolerance;
    }
    normalAtPosition(point, target) {
        _u$4.subVectors(this.vertex.position, point);
        _v$3.subVectors(this.vertex.position, this.next.vertex.position);
        const ratio = _u$4.length() / _v$3.length();
        return target.lerpVectors(this.vertex.normal, this.next.vertex.normal, 1 - ratio);
    }
    get isBoundary() {
        return this.twin === undefined;
    }
    get isConcave() {
        if (this.twin) {
            return frontSide$1(this.vertex.position, this.next.vertex.position, this.prev.vertex.position, this.twin.prev.vertex.position) > 0;
        }
        return false;
    }
}

class HalfEdgeStructure {
    geometry;
    options;
    faces = new Array();
    vertices = new Array();
    halfEdges = new Array();
    constructor(geometry, options = {}) {
        this.geometry = geometry;
        this.options = {
            hashNormals: false,
            tolerance: 1e-4,
            ...options
        };
    }
    build() {
        this.faces.clear();
        this.vertices.clear();
        this.halfEdges.clear();
        const geometry = this.geometry;
        const options = this.options;
        if (!geometry.hasAttribute("position")) {
            throw "BufferGeometry doesn't have a position BufferAttribute.";
        }
        if (!geometry.hasAttribute("normal")) {
            geometry.computeVertexNormals();
        }
        const positionBuffer = geometry.getAttribute('position');
        const normalBuffer = geometry.getAttribute('normal');
        const indexVertexArray = mergeVertexIndices(geometry, options.tolerance, options.hashNormals);
        let nbOfFaces = positionBuffer.count / 3;
        let getVertexIndex = function (bufferIndex) {
            return indexVertexArray[bufferIndex];
        };
        const indexBuffer = geometry.getIndex();
        if (indexBuffer) {
            nbOfFaces = indexBuffer.count / 3;
            getVertexIndex = function (bufferIndex) {
                return indexVertexArray[indexBuffer.array[bufferIndex]];
            };
        }
        const halfEdgeMap = new Map();
        const vertexMap = new Map();
        for (let faceIndex = 0; faceIndex < nbOfFaces; faceIndex++) {
            const vertices = new Array();
            for (let i = 0; i < 3; i++) {
                const vertexIndex = getVertexIndex(faceIndex * 3 + i);
                let vertex = vertexMap.get(vertexIndex);
                if (!vertex) {
                    const position = new Vector3().fromBufferAttribute(positionBuffer, vertexIndex);
                    const normal = new Vector3().fromBufferAttribute(normalBuffer, vertexIndex);
                    vertex = new Vertex(vertexIndex, position, normal);
                    vertexMap.set(vertexIndex, vertex);
                    this.vertices.push(vertex);
                }
                vertices.push(vertex);
            }
            const face = new Face(faceIndex, vertices[0], vertices[1], vertices[2]);
            this.faces.push(face);
            const halfEdges = new Array();
            for (let i = 0; i < 3; i++) {
                const vertex = vertices[i];
                const halfEdge = new HalfEdge(face, vertex);
                vertex.halfEdges.push(halfEdge);
                const nextVertex = vertices[(i + 1) % 3];
                const twinHalfEdgeHash = nextVertex.index + '-' + vertex.index;
                const twin = halfEdgeMap.get(twinHalfEdgeHash);
                if (twin) {
                    halfEdge.twin = twin;
                    twin.twin = halfEdge;
                }
                const halfEdgeHash = vertex.index + '-' + nextVertex.index;
                halfEdgeMap.set(halfEdgeHash, halfEdge);
                halfEdges.push(halfEdge);
                this.halfEdges.push(halfEdge);
            }
            for (let i = 0; i < 3; i++) {
                halfEdges[i].next = halfEdges[(i + 2) % 3].prev = halfEdges[(i + 1) % 3];
            }
            face.halfEdge = halfEdges[0];
        }
    }
}
function mergeVertexIndices(geometry, tolerance = 1e-4, hashNormals = false) {
    if (!geometry.hasAttribute('position')) {
        throw "BufferGeometry doesn't have a 'position' buffer attribute.";
    }
    if (!geometry.hasAttribute('normal')) {
        geometry.computeVertexNormals();
    }
    const positionBuffer = geometry.getAttribute('position');
    const decimalShift = Math.log10(1 / tolerance);
    const shiftMultiplier = Math.pow(10, decimalShift);
    const hashVertexMap = new Map();
    const indexVertexArray = new Array();
    const hashBuffers = [positionBuffer];
    if (hashNormals) {
        const normalBuffer = geometry.getAttribute('normal');
        hashBuffers.push(normalBuffer);
    }
    for (let i = 0; i < positionBuffer.count; i++) {
        let hash = "";
        for (const hashBuffer of hashBuffers) {
            for (let j = 0; j < 3; j++) {
                hash += `${Math.round(hashBuffer.array[i * 3 + j] * shiftMultiplier)}`;
            }
        }
        let vertexIndex = hashVertexMap.get(hash);
        if (vertexIndex == undefined) {
            vertexIndex = i;
            hashVertexMap.set(hash, i);
        }
        indexVertexArray.push(vertexIndex);
    }
    return indexVertexArray;
}

Array.prototype.clear = function () {
    this.splice(0, this.length);
    return this;
};
Array.prototype.remove = function (t) {
    const idx = this.indexOf(t);
    if (idx === -1) {
        return false;
    }
    this.splice(idx, 1);
    return true;
};

function intersectSegments(a, b) {
  // Note: this is almost the same as geom.intersectSegments()
  // The main difference is that we don't have a pre-computed
  // value for dx/dy on the segments.
  //  https://stackoverflow.com/a/1968345/125351
  var aStart = a.from, bStart = b.from;
  var p0_x = aStart.x, p0_y = aStart.y,
      p2_x = bStart.x, p2_y = bStart.y;

  var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;
  var div = s1_x * s2_y - s2_x * s1_y;

  var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
  if (s < 0 || s > 1) return;

  var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

  if (t >= 0 && t <= 1) {
    return {
      x: p0_x - (t * s1_x),
      y: p0_y - (t * s1_y)
    }
  }
}

class FlatQueue {

    constructor() {
        this.ids = [];
        this.values = [];
        this.length = 0;
    }

    clear() {
        this.length = 0;
    }

    push(id, value) {
        let pos = this.length++;

        while (pos > 0) {
            const parent = (pos - 1) >> 1;
            const parentValue = this.values[parent];
            if (value >= parentValue) break;
            this.ids[pos] = this.ids[parent];
            this.values[pos] = parentValue;
            pos = parent;
        }

        this.ids[pos] = id;
        this.values[pos] = value;
    }

    pop() {
        if (this.length === 0) return undefined;

        const top = this.ids[0];
        this.length--;

        if (this.length > 0) {
            const id = this.ids[0] = this.ids[this.length];
            const value = this.values[0] = this.values[this.length];
            const halfLength = this.length >> 1;
            let pos = 0;

            while (pos < halfLength) {
                let left = (pos << 1) + 1;
                const right = left + 1;
                let bestIndex = this.ids[left];
                let bestValue = this.values[left];
                const rightValue = this.values[right];

                if (right < this.length && rightValue < bestValue) {
                    left = right;
                    bestIndex = this.ids[right];
                    bestValue = rightValue;
                }
                if (bestValue >= value) break;

                this.ids[pos] = bestIndex;
                this.values[pos] = bestValue;
                pos = left;
            }

            this.ids[pos] = id;
            this.values[pos] = value;
        }

        return top;
    }

    peek() {
        if (this.length === 0) return undefined;
        return this.ids[0];
    }

    peekValue() {
        if (this.length === 0) return undefined;
        return this.values[0];
    }

    shrink() {
        this.ids.length = this.values.length = this.length;
    }
}

const ARRAY_TYPES = [
    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
    Int32Array, Uint32Array, Float32Array, Float64Array
];

const VERSION = 3; // serialized format version

class Flatbush {

    static from(data) {
        if (!(data instanceof ArrayBuffer)) {
            throw new Error('Data must be an instance of ArrayBuffer.');
        }
        const [magic, versionAndType] = new Uint8Array(data, 0, 2);
        if (magic !== 0xfb) {
            throw new Error('Data does not appear to be in a Flatbush format.');
        }
        if (versionAndType >> 4 !== VERSION) {
            throw new Error(`Got v${versionAndType >> 4} data when expected v${VERSION}.`);
        }
        const [nodeSize] = new Uint16Array(data, 2, 1);
        const [numItems] = new Uint32Array(data, 4, 1);

        return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);
    }

    constructor(numItems, nodeSize = 16, ArrayType = Float64Array, data) {
        if (numItems === undefined) throw new Error('Missing required argument: numItems.');
        if (isNaN(numItems) || numItems <= 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);

        this.numItems = +numItems;
        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);

        // calculate the total number of nodes in the R-tree to allocate space for
        // and the index of each tree level (used in search later)
        let n = numItems;
        let numNodes = n;
        this._levelBounds = [n * 4];
        do {
            n = Math.ceil(n / this.nodeSize);
            numNodes += n;
            this._levelBounds.push(numNodes * 4);
        } while (n !== 1);

        this.ArrayType = ArrayType || Float64Array;
        this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;

        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
        const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;

        if (arrayTypeIndex < 0) {
            throw new Error(`Unexpected typed array class: ${ArrayType}.`);
        }

        if (data && (data instanceof ArrayBuffer)) {
            this.data = data;
            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);

            this._pos = numNodes * 4;
            this.minX = this._boxes[this._pos - 4];
            this.minY = this._boxes[this._pos - 3];
            this.maxX = this._boxes[this._pos - 2];
            this.maxY = this._boxes[this._pos - 1];

        } else {
            this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
            this._pos = 0;
            this.minX = Infinity;
            this.minY = Infinity;
            this.maxX = -Infinity;
            this.maxY = -Infinity;

            new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);
            new Uint16Array(this.data, 2, 1)[0] = nodeSize;
            new Uint32Array(this.data, 4, 1)[0] = numItems;
        }

        // a priority queue for k-nearest-neighbors queries
        this._queue = new FlatQueue();
    }

    add(minX, minY, maxX, maxY) {
        const index = this._pos >> 2;
        this._indices[index] = index;
        this._boxes[this._pos++] = minX;
        this._boxes[this._pos++] = minY;
        this._boxes[this._pos++] = maxX;
        this._boxes[this._pos++] = maxY;

        if (minX < this.minX) this.minX = minX;
        if (minY < this.minY) this.minY = minY;
        if (maxX > this.maxX) this.maxX = maxX;
        if (maxY > this.maxY) this.maxY = maxY;

        return index;
    }

    finish() {
        if (this._pos >> 2 !== this.numItems) {
            throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);
        }

        if (this.numItems <= this.nodeSize) {
            // only one node, skip sorting and just fill the root box
            this._boxes[this._pos++] = this.minX;
            this._boxes[this._pos++] = this.minY;
            this._boxes[this._pos++] = this.maxX;
            this._boxes[this._pos++] = this.maxY;
            return;
        }

        const width = (this.maxX - this.minX) || 1;
        const height = (this.maxY - this.minY) || 1;
        const hilbertValues = new Uint32Array(this.numItems);
        const hilbertMax = (1 << 16) - 1;

        // map item centers into Hilbert coordinate space and calculate Hilbert values
        for (let i = 0; i < this.numItems; i++) {
            let pos = 4 * i;
            const minX = this._boxes[pos++];
            const minY = this._boxes[pos++];
            const maxX = this._boxes[pos++];
            const maxY = this._boxes[pos++];
            const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);
            const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);
            hilbertValues[i] = hilbert(x, y);
        }

        // sort items by their Hilbert value (for packing later)
        sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1, this.nodeSize);

        // generate nodes at each tree level, bottom-up
        for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {
            const end = this._levelBounds[i];

            // generate a parent node for each block of consecutive <nodeSize> nodes
            while (pos < end) {
                const nodeIndex = pos;

                // calculate bbox for the new node
                let nodeMinX = Infinity;
                let nodeMinY = Infinity;
                let nodeMaxX = -Infinity;
                let nodeMaxY = -Infinity;
                for (let i = 0; i < this.nodeSize && pos < end; i++) {
                    nodeMinX = Math.min(nodeMinX, this._boxes[pos++]);
                    nodeMinY = Math.min(nodeMinY, this._boxes[pos++]);
                    nodeMaxX = Math.max(nodeMaxX, this._boxes[pos++]);
                    nodeMaxY = Math.max(nodeMaxY, this._boxes[pos++]);
                }

                // add the new node to the tree data
                this._indices[this._pos >> 2] = nodeIndex;
                this._boxes[this._pos++] = nodeMinX;
                this._boxes[this._pos++] = nodeMinY;
                this._boxes[this._pos++] = nodeMaxX;
                this._boxes[this._pos++] = nodeMaxY;
            }
        }
    }

    search(minX, minY, maxX, maxY, filterFn) {
        if (this._pos !== this._boxes.length) {
            throw new Error('Data not yet indexed - call index.finish().');
        }

        let nodeIndex = this._boxes.length - 4;
        const queue = [];
        const results = [];

        while (nodeIndex !== undefined) {
            // find the end index of the node
            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));

            // search through child nodes
            for (let pos = nodeIndex; pos < end; pos += 4) {
                // check if node bbox intersects with query bbox
                if (maxX < this._boxes[pos]) continue; // maxX < nodeMinX
                if (maxY < this._boxes[pos + 1]) continue; // maxY < nodeMinY
                if (minX > this._boxes[pos + 2]) continue; // minX > nodeMaxX
                if (minY > this._boxes[pos + 3]) continue; // minY > nodeMaxY

                const index = this._indices[pos >> 2] | 0;

                if (nodeIndex < this.numItems * 4) {
                    if (filterFn === undefined || filterFn(index)) {
                        results.push(index); // leaf item
                    }

                } else {
                    queue.push(index); // node; add it to the search queue
                }
            }

            nodeIndex = queue.pop();
        }

        return results;
    }

    neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {
        if (this._pos !== this._boxes.length) {
            throw new Error('Data not yet indexed - call index.finish().');
        }

        let nodeIndex = this._boxes.length - 4;
        const q = this._queue;
        const results = [];
        const maxDistSquared = maxDistance * maxDistance;

        while (nodeIndex !== undefined) {
            // find the end index of the node
            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));

            // add child nodes to the queue
            for (let pos = nodeIndex; pos < end; pos += 4) {
                const index = this._indices[pos >> 2] | 0;

                const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);
                const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);
                const dist = dx * dx + dy * dy;

                if (nodeIndex < this.numItems * 4) { // leaf node
                    if (filterFn === undefined || filterFn(index)) {
                        // put an odd index if it's an item rather than a node, to recognize later
                        q.push((index << 1) + 1, dist);
                    }
                } else {
                    q.push(index << 1, dist);
                }
            }

            // pop items from the queue
            while (q.length && (q.peek() & 1)) {
                const dist = q.peekValue();
                if (dist > maxDistSquared) {
                    q.clear();
                    return results;
                }
                results.push(q.pop() >> 1);

                if (results.length === maxResults) {
                    q.clear();
                    return results;
                }
            }

            nodeIndex = q.pop() >> 1;
        }

        q.clear();
        return results;
    }
}

function axisDist(k, min, max) {
    return k < min ? min - k : k <= max ? 0 : k - max;
}

// binary search for the first value in the array bigger than the given
function upperBound(value, arr) {
    let i = 0;
    let j = arr.length - 1;
    while (i < j) {
        const m = (i + j) >> 1;
        if (arr[m] > value) {
            j = m;
        } else {
            i = m + 1;
        }
    }
    return arr[i];
}

// custom quicksort that partially sorts bbox data alongside the hilbert values
function sort(values, boxes, indices, left, right, nodeSize) {
    if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) return;

    const pivot = values[(left + right) >> 1];
    let i = left - 1;
    let j = right + 1;

    while (true) {
        do i++; while (values[i] < pivot);
        do j--; while (values[j] > pivot);
        if (i >= j) break;
        swap(values, boxes, indices, i, j);
    }

    sort(values, boxes, indices, left, j, nodeSize);
    sort(values, boxes, indices, j + 1, right, nodeSize);
}

// swap two values and two corresponding boxes
function swap(values, boxes, indices, i, j) {
    const temp = values[i];
    values[i] = values[j];
    values[j] = temp;

    const k = 4 * i;
    const m = 4 * j;

    const a = boxes[k];
    const b = boxes[k + 1];
    const c = boxes[k + 2];
    const d = boxes[k + 3];
    boxes[k] = boxes[m];
    boxes[k + 1] = boxes[m + 1];
    boxes[k + 2] = boxes[m + 2];
    boxes[k + 3] = boxes[m + 3];
    boxes[m] = a;
    boxes[m + 1] = b;
    boxes[m + 2] = c;
    boxes[m + 3] = d;

    const e = indices[i];
    indices[i] = indices[j];
    indices[j] = e;
}

// Fast Hilbert curve algorithm by http://threadlocalmutex.com/
// Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)
function hilbert(x, y) {
    let a = x ^ y;
    let b = 0xFFFF ^ a;
    let c = 0xFFFF ^ (x | y);
    let d = x & (y ^ 0xFFFF);

    let A = a | (b >> 1);
    let B = (a >> 1) ^ a;
    let C = ((c >> 1) ^ (b & (d >> 1))) ^ c;
    let D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;

    a = A; b = B; c = C; d = D;
    A = ((a & (a >> 2)) ^ (b & (b >> 2)));
    B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
    C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
    D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));

    a = A; b = B; c = C; d = D;
    A = ((a & (a >> 4)) ^ (b & (b >> 4)));
    B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
    C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
    D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));

    a = A; b = B; c = C; d = D;
    C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
    D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));

    a = C ^ (C >> 1);
    b = D ^ (D >> 1);

    let i0 = x ^ y;
    let i1 = b | (0xFFFF ^ (i0 | a));

    i0 = (i0 | (i0 << 8)) & 0x00FF00FF;
    i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;
    i0 = (i0 | (i0 << 2)) & 0x33333333;
    i0 = (i0 | (i0 << 1)) & 0x55555555;

    i1 = (i1 | (i1 << 8)) & 0x00FF00FF;
    i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;
    i1 = (i1 | (i1 << 2)) & 0x33333333;
    i1 = (i1 | (i1 << 1)) & 0x55555555;

    return ((i1 << 1) | i0) >>> 0;
}

/**
 * This implementation is inspired by discussion here 
 * https://twitter.com/mourner/status/1049325199617921024 and 
 * here https://github.com/anvaka/isect/issues/1
 * 
 * It builds an index of all segments using static spatial index
 * and then for each segment it queries overlapping rectangles.
 */
function bush(lines, options) {
  var results = [];
  var reportIntersection = (options && options.onFound) || 
                            defaultIntersectionReporter;
  var asyncState;

  var index = new Flatbush(lines.length);
  lines.forEach(addToIndex);
  index.finish();

  return {
    run: run,
    step: step,
    results: results,

    // undocumented, don't use unless you know what you are doing:
    checkIntersection: checkIntersection
  }

  function run() {
    for (var i = 0; i < lines.length; ++i) {
      if (checkIntersection(lines[i], i)) {
        return; // stop early
      }
    }
    return results;
  }

  function checkIntersection(currentSegment, currentId) {
    // sorry about code duplication.
    var minX = currentSegment.from.x; var maxX = currentSegment.to.x;
    var minY = currentSegment.from.y; var maxY = currentSegment.to.y;
    var t;
    if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
    if (minY > maxY) { t = minY; minY = maxY; maxY = t; }

    var ids = index.search(minX, minY, maxX, maxY);

    for (var i = 0; i < ids.length; ++i) {
      var segmentIndex = ids[i];
      if (segmentIndex <= currentId) continue; // we have either reported it, or it is current.

      var otherSegment = lines[segmentIndex];
      var point = intersectSegments(otherSegment, currentSegment);

      if (point) {
        if (reportIntersection(point, [currentSegment, otherSegment])) {
          // stop early
          return true;
        }
      }
    }
  }

  function step() {
    if (!asyncState) {
      asyncState = {i: 0};
    }
    var test = lines[asyncState.i];
    checkIntersection(test, asyncState.i);
    asyncState.i += 1;
    return asyncState.i < lines.length;
  }


  function addToIndex(line) {
    var minX = line.from.x; var maxX = line.to.x;
    var minY = line.from.y; var maxY = line.to.y;
    var t;
    if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
    if (minY > maxY) { t = minY; minY = maxY; maxY = t; }
    index.add(minX, minY, maxX, maxY);
  }

  function defaultIntersectionReporter(p, interior) {
    results.push({
      point: p, 
      segments: interior
    });
  }
}

new Vector3();
const _matrix$1 = new Matrix4();
function NDCPointToImage(point, renderSize) {
    return point.set((point.x + 1) / 2 * renderSize.w, (1 - point.y) / 2 * renderSize.h);
}
// See https://hal.inria.fr/hal-02189483 appendix C.2 Orientation test
function orient3D$1(a, b, c, d, epsilon = 1e-10) {
    _matrix$1.set(a.x, a.y, a.z, 1, b.x, b.y, b.z, 1, c.x, c.y, c.z, 1, d.x, d.y, d.z, 1);
    const det = _matrix$1.determinant();
    if (det > epsilon) {
        return 1;
    }
    else if (det < -epsilon) {
        return -1;
    }
    return 0;
}
// See https://hal.inria.fr/hal-02189483 appendix C.2 Orientation test
function frontSide(a, b, c, d) {
    return orient3D$1(d, b, c, a);
}
// See https://hal.inria.fr/hal-02189483 appendix C.2 Orientation test
function sameSide(a, b, c, d, e) {
    return (orient3D$1(a, b, c, d) > 0) === (orient3D$1(a, b, c, e) > 0);
}
function round(num) {
    return Math.round(num * 100) / 100;
}

// Author: Axel Antoine
var EdgeNature;
(function (EdgeNature) {
    EdgeNature["None"] = "None";
    EdgeNature["Silhouette"] = "Silhouette";
    EdgeNature["Boundary"] = "Boudary";
    EdgeNature["SurfaceIntersection"] = "SurfaceIntersection";
    EdgeNature["Crease"] = "Crease";
    EdgeNature["Material"] = "Material";
})(EdgeNature || (EdgeNature = {}));
const _vec2a = new Vector2();
const _vec2b = new Vector2();
const _u$3 = new Vector3();
const _v$2 = new Vector3();
const _cross = new Vector3();
class Edge {
    vertices;
    meshes;
    faces;
    nature = EdgeNature.None;
    angle = Infinity;
    isBack = false;
    isConcave = false;
    constructor(meshes, faces, a, b) {
        this.meshes = meshes;
        this.vertices = [a, b];
        this.faces = faces;
    }
    updateNatureFromHalfEdge(halfEdge, camera) {
        // this.halfEdge = halfEdge;
        if (halfEdge.twin) {
            this.isConcave = frontSide(halfEdge.vertex.position, halfEdge.next.vertex.position, halfEdge.prev.vertex.position, halfEdge.twin.prev.vertex.position) > 0;
            const faceAFront = halfEdge.face.isFront(camera.position);
            const faceBFront = halfEdge.twin.face.isFront(camera.position);
            // If edge is between two back faces, then it is a back edge
            this.isBack = !faceAFront && !faceBFront;
            // If edge is between front and back face, then it is a silhouette edge
            if (faceAFront !== faceBFront) {
                this.nature = EdgeNature.Silhouette;
            }
            else {
                const n1 = halfEdge.face.normal.normalize();
                const n2 = halfEdge.twin.face.normal.normalize();
                const angle = Math.acos(n1.dot(n2)) * 180 / Math.PI;
                if (80 < angle && angle < 100) {
                    this.nature = EdgeNature.Crease;
                }
            }
        }
        else {
            // If edge only has one connected face, then it is a boundary
            this.nature = EdgeNature.Boundary;
        }
    }
    get points() {
        return [this.vertices[0].point, this.vertices[1].point];
    }
    get to() {
        return this.vertices[1].point.position;
    }
    get from() {
        return this.vertices[0].point.position;
    }
    clone() {
        return (new Edge([], [], this.vertices[0], this.vertices[1])).copy(this);
    }
    copy(source) {
        this.meshes.clear();
        this.meshes.push(...source.meshes);
        this.faces.clear();
        this.faces.push(...source.faces);
        this.nature = source.nature;
        this.angle = source.angle;
        this.isBack = source.isBack;
        // this.halfEdge = source.halfEdge;
        this.replaceVertex(this.vertices[0], source.vertices[0]);
        this.replaceVertex(this.vertices[1], source.vertices[1]);
        this.isConcave = source.isConcave;
        return this;
    }
    replaceVertex(oldVertex, newVertex) {
        const index = this.vertices.indexOf(oldVertex);
        if (index !== -1) {
            this.vertices[index] = newVertex;
            return true;
        }
        return false;
    }
    otherVertex(vertex) {
        if (vertex === this.vertices[0]) {
            return this.vertices[1];
        }
        else {
            return this.vertices[0];
        }
    }
    otherPoint(point) {
        if (point === this.vertices[0].point) {
            return this.vertices[1].point;
        }
        else {
            return this.vertices[0].point;
        }
    }
    hasVertex(vertex) {
        return this.vertices[0] === vertex || this.vertices[1] === vertex;
    }
    hasPoint(point) {
        return this.vertices[0].point === point || this.vertices[1].point === point;
    }
    isConnectedToEdge(edge) {
        return this.hasPoint(edge.vertices[0].point) ||
            this.hasPoint(edge.vertices[1].point);
    }
    contains3dPosition(position, tolerance = 1e-10) {
        _u$3.subVectors(this.vertices[0].position, position);
        _v$2.subVectors(this.vertices[1].position, position);
        _cross.crossVectors(_u$3, _v$2);
        return _cross.length() < tolerance && _u$3.dot(_v$2) < 0;
    }
    contains2dPosition(position, tolerance = 1e-10) {
        _vec2a.subVectors(this.vertices[0].point.position, position);
        _vec2b.subVectors(this.vertices[1].point.position, position);
        return _vec2a.cross(_vec2b) < tolerance && _vec2a.dot(_vec2b) < 0;
    }
    normalAtPosition(point, target) {
        _u$3.subVectors(this.vertices[0].position, point);
        _v$2.subVectors(this.vertices[0].position, this.vertices[1].position);
        const ratio = _u$3.length() / _v$2.length();
        return target.lerpVectors(this.vertices[0].normal, this.vertices[1].normal, ratio);
    }
    position3dFromPosition2d(position, target) {
        _vec2a.subVectors(this.vertices[0].point.position, position);
        _vec2b.subVectors(this.vertices[0].point.position, this.vertices[1].point.position);
        const ratio = _vec2a.length() / _vec2b.length();
        return target.lerpVectors(this.vertices[0].position, this.vertices[1].position, ratio);
    }
}

var PointSingularity;
(function (PointSingularity) {
    PointSingularity["None"] = "None";
    PointSingularity["ImageIntersection"] = "ImageIntersection";
    PointSingularity["MeshIntersection"] = "MeshIntersection";
    PointSingularity["CurtainFold"] = "CurtainFold";
    PointSingularity["Bifurcation"] = "Bifurcation";
})(PointSingularity || (PointSingularity = {}));
const _u$2 = new Vector2();
class Point$1 {
    position;
    visible = false;
    singularity = PointSingularity.None;
    vertices;
    constructor(position, vertices) {
        this.position = position;
        this.vertices = vertices;
    }
    get x() {
        return this.position.x;
    }
    get y() {
        return this.position.y;
    }
    get edges() {
        const set = new Set();
        for (const v of this.vertices) {
            for (const e of v.edges) {
                set.add(e);
            }
        }
        return Array.from(set);
    }
    matchPosition(position, tolerance = 1e-10) {
        _u$2.subVectors(position, this.position);
        return _u$2.length() < tolerance;
    }
}

// Author: Axel Antoine
var ContourVisibility;
(function (ContourVisibility) {
    ContourVisibility["Unknown"] = "Unknown";
    ContourVisibility["Hidden"] = "Hidden";
    ContourVisibility["Visible"] = "Visible";
})(ContourVisibility || (ContourVisibility = {}));
class Contour {
    id;
    object;
    raycastPoint = new Vector2();
    edges = new Array();
    points = new Array();
    visibility = ContourVisibility.Unknown;
    constructor(id, object) {
        this.id = id;
        this.object = object;
    }
    get head() {
        return this.points[0];
    }
    get tail() {
        return this.points[this.points.length - 1];
    }
    get size() {
        return this.points.length;
    }
    get nature() {
        return this.edges[0].nature;
    }
    middlePoint() {
        return this.points[Math.floor(this.points.length / 2)];
    }
    middleEdge() {
        if (this.edges.length === 0) {
            return null;
        }
        else {
            return this.edges[Math.floor(this.edges.length / 2)];
        }
    }
    addEdge(edge) {
        if (this.edges.length == 0) {
            this.edges.push(edge);
            this.points.push(edge.vertices[0].point);
            this.points.push(edge.vertices[1].point);
        }
        else {
            if (edge.hasPoint(this.head)) {
                // Put vertex and segment in the head of the lists
                this.points.unshift(edge.otherPoint(this.head));
                this.edges.unshift(edge);
            }
            else if (edge.hasPoint(this.tail)) {
                // Put vertex and segment in the tail of the lists
                this.points.push(edge.otherPoint(this.tail));
                this.edges.push(edge);
            }
        }
    }
}

var Arrangement2D = (() => {
  var _scriptDir = import.meta.url;
  
  return (
function(Arrangement2D) {
  Arrangement2D = Arrangement2D || {};

var Module=typeof Arrangement2D!="undefined"?Arrangement2D:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject;});if(!Object.getOwnPropertyDescriptor(Module["ready"],"_main")){Object.defineProperty(Module["ready"],"_main",{configurable:true,get:function(){abort("You are getting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_main",{configurable:true,set:function(){abort("You are setting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_VoidPtr___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_VoidPtr___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_VoidPtr___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_VoidPtr___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_VoidPtr___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ArrangementBuilder_ArrangementBuilder_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_ArrangementBuilder_ArrangementBuilder_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ArrangementBuilder_ArrangementBuilder_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ArrangementBuilder_ArrangementBuilder_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ArrangementBuilder_ArrangementBuilder_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ArrangementBuilder_getPolygons_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_ArrangementBuilder_getPolygons_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ArrangementBuilder_getPolygons_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ArrangementBuilder_getPolygons_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ArrangementBuilder_getPolygons_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ArrangementBuilder___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_ArrangementBuilder___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ArrangementBuilder___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ArrangementBuilder___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ArrangementBuilder___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Point_Point_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Point_Point_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Point_Point_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Point_Point_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Point_Point_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Point_Point_2")){Object.defineProperty(Module["ready"],"_emscripten_bind_Point_Point_2",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Point_Point_2 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Point_Point_2",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Point_Point_2 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Point_get_x_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Point_get_x_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Point_get_x_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Point_get_x_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Point_get_x_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Point_set_x_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_Point_set_x_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Point_set_x_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Point_set_x_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Point_set_x_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Point_get_y_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Point_get_y_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Point_get_y_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Point_get_y_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Point_get_y_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Point_set_y_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_Point_set_y_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Point_set_y_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Point_set_y_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Point_set_y_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Point___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Point___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Point___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Point___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Point___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon_Polygon_2")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_Polygon_2",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon_Polygon_2 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_Polygon_2",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon_Polygon_2 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon_getInsidePoint_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_getInsidePoint_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon_getInsidePoint_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_getInsidePoint_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon_getInsidePoint_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon_getPolyTristripArea_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_getPolyTristripArea_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon_getPolyTristripArea_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_getPolyTristripArea_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon_getPolyTristripArea_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon_get_contour_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_get_contour_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon_get_contour_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_get_contour_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon_get_contour_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon_set_contour_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_set_contour_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon_set_contour_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_set_contour_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon_set_contour_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon_get_holes_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_get_holes_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon_get_holes_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_get_holes_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon_get_holes_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon_set_holes_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_set_holes_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon_set_holes_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon_set_holes_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon_set_holes_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Polygon___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Polygon___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Polygon___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Polygon___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PointList_PointList_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_PointList_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PointList_PointList_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_PointList_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PointList_PointList_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PointList_push_back_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_push_back_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PointList_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_push_back_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PointList_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PointList_size_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_size_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PointList_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_size_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PointList_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PointList_at_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_at_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PointList_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_at_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PointList_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PointList_clear_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_clear_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PointList_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PointList_clear_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PointList_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PointList___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PointList___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PointList___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PointList___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PointList___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PolygonList_PolygonList_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_PolygonList_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PolygonList_PolygonList_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_PolygonList_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PolygonList_PolygonList_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PolygonList_push_back_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_push_back_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PolygonList_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_push_back_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PolygonList_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PolygonList_size_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_size_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PolygonList_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_size_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PolygonList_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PolygonList_at_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_at_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PolygonList_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_at_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PolygonList_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PolygonList_clear_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_clear_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PolygonList_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList_clear_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PolygonList_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_PolygonList___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_PolygonList___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_PolygonList___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_PolygonList___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Contour_Contour_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_Contour_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Contour_Contour_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_Contour_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Contour_Contour_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Contour_push_back_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_push_back_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Contour_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_push_back_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Contour_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Contour_size_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_size_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Contour_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_size_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Contour_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Contour_at_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_at_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Contour_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_at_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Contour_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Contour_clear_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_clear_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Contour_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Contour_clear_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Contour_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_Contour___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_Contour___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_Contour___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_Contour___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_Contour___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ContourList_ContourList_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_ContourList_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ContourList_ContourList_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_ContourList_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ContourList_ContourList_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ContourList_push_back_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_push_back_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ContourList_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_push_back_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ContourList_push_back_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ContourList_size_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_size_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ContourList_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_size_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ContourList_size_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ContourList_at_1")){Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_at_1",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ContourList_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_at_1",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ContourList_at_1 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ContourList_clear_0")){Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_clear_0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ContourList_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList_clear_0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ContourList_clear_0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_emscripten_bind_ContourList___destroy___0")){Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList___destroy___0",{configurable:true,get:function(){abort("You are getting _emscripten_bind_ContourList___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_emscripten_bind_ContourList___destroy___0",{configurable:true,set:function(){abort("You are setting _emscripten_bind_ContourList___destroy___0 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"_fflush")){Object.defineProperty(Module["ready"],"_fflush",{configurable:true,get:function(){abort("You are getting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"_fflush",{configurable:true,set:function(){abort("You are setting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}if(!Object.getOwnPropertyDescriptor(Module["ready"],"onRuntimeInitialized")){Object.defineProperty(Module["ready"],"onRuntimeInitialized",{configurable:true,get:function(){abort("You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});Object.defineProperty(Module["ready"],"onRuntimeInitialized",{configurable:true,set:function(){abort("You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js");}});}var moduleOverrides=Object.assign({},Module);var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(Module["ENVIRONMENT"]){throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)")}var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;if(e&&typeof e=="object"&&e.stack){toLog=[e,e.stack];}err("exiting due to exception: "+toLog);}var fs;var nodePath;var requireNodeFS;if(ENVIRONMENT_IS_NODE){if(!(typeof process=="object"&&typeof require=="function"))throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");if(ENVIRONMENT_IS_WORKER){scriptDirectory=require("path").dirname(scriptDirectory)+"/";}else {scriptDirectory=__dirname+"/";}requireNodeFS=()=>{if(!nodePath){fs=require("fs");nodePath=require("path");}};read_=function shell_read(filename,binary){var ret=tryParseAsDataURI(filename);if(ret){return binary?ret:ret.toString()}requireNodeFS();filename=nodePath["normalize"](filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret);}assert(ret.buffer);return ret};readAsync=(filename,onload,onerror)=>{var ret=tryParseAsDataURI(filename);if(ret){onload(ret);}requireNodeFS();filename=nodePath["normalize"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer);});};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/");}process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",function(reason){throw reason});quit_=(status,toThrow)=>{if(keepRuntimeAlive()){process["exitCode"]=status;throw toThrow}logExceptionOnExit(toThrow);process["exit"](status);};Module["inspect"]=function(){return "[Emscripten Module object]"};}else if(ENVIRONMENT_IS_SHELL){if(typeof process=="object"&&typeof require==="function"||typeof window=="object"||typeof importScripts=="function")throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");if(typeof read!="undefined"){read_=function shell_read(f){const data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)};}readBinary=function readBinary(f){let data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer=="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data=="object");return data};readAsync=function readAsync(f,onload,onerror){setTimeout(()=>onload(readBinary(f)),0);};if(typeof scriptArgs!="undefined"){scriptArgs;}if(typeof quit=="function"){quit_=(status,toThrow)=>{logExceptionOnExit(toThrow);quit(status);};}if(typeof print!="undefined"){if(typeof console=="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!="undefined"?printErr:print;}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href;}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1);}else {scriptDirectory="";}if(!(typeof window=="object"||typeof importScripts=="function"))throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");{read_=url=>{try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}};}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror();};xhr.onerror=onerror;xhr.send(null);};}}else {throw new Error("environment detection error")}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;checkIncomingModuleAPI();if(Module["arguments"])Module["arguments"];legacyModuleProp("arguments","arguments_");if(Module["thisProgram"])thisProgram=Module["thisProgram"];legacyModuleProp("thisProgram","thisProgram");if(Module["quit"])quit_=Module["quit"];legacyModuleProp("quit","quit_");assert(typeof Module["memoryInitializerPrefixURL"]=="undefined","Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["pthreadMainPrefixURL"]=="undefined","Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["cdInitializerPrefixURL"]=="undefined","Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["filePackagePrefixURL"]=="undefined","Module.filePackagePrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["read"]=="undefined","Module.read option was removed (modify read_ in JS)");assert(typeof Module["readAsync"]=="undefined","Module.readAsync option was removed (modify readAsync in JS)");assert(typeof Module["readBinary"]=="undefined","Module.readBinary option was removed (modify readBinary in JS)");assert(typeof Module["setWindowTitle"]=="undefined","Module.setWindowTitle option was removed (modify setWindowTitle in JS)");assert(typeof Module["TOTAL_MEMORY"]=="undefined","Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");legacyModuleProp("read","read_");legacyModuleProp("readAsync","readAsync");legacyModuleProp("readBinary","readBinary");legacyModuleProp("setWindowTitle","setWindowTitle");assert(!ENVIRONMENT_IS_SHELL,"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text);}}function legacyModuleProp(prop,newName){if(!Object.getOwnPropertyDescriptor(Module,prop)){Object.defineProperty(Module,prop,{configurable:true,get:function(){abort("Module."+prop+" has been replaced with plain "+newName+" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");}});}}function ignoredModuleProp(prop){if(Object.getOwnPropertyDescriptor(Module,prop)){abort("`Module."+prop+"` was supplied but `"+prop+"` not included in INCOMING_MODULE_JS_API");}}function unexportedMessage(sym,isFSSybol){var msg="'"+sym+"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";if(isFSSybol){msg+=". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";}return msg}function unexportedRuntimeSymbol(sym,isFSSybol){if(!Object.getOwnPropertyDescriptor(Module,sym)){Object.defineProperty(Module,sym,{configurable:true,get:function(){abort(unexportedMessage(sym,isFSSybol));}});}}function unexportedRuntimeFunction(sym,isFSSybol){if(!Object.getOwnPropertyDescriptor(Module,sym)){Module[sym]=()=>abort(unexportedMessage(sym,isFSSybol));}}var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];legacyModuleProp("wasmBinary","wasmBinary");var noExitRuntime=Module["noExitRuntime"]||true;legacyModuleProp("noExitRuntime","noExitRuntime");if(typeof WebAssembly!="object"){abort("no native wasm support detected");}var wasmMemory;var ABORT=false;function assert(condition,text){if(!condition){abort("Assertion failed"+(text?": "+text:""));}}var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}else {var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {if((u0&248)!=240)warnOnce("Invalid UTF-8 leading byte 0x"+u0.toString(16)+" encountered when deserializing a UTF-8 string in wasm memory to a JS string!");u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;if(u>1114111)warnOnce("Invalid Unicode code point 0x"+u.toString(16)+" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}}heap[outIdx]=0;return outIdx-startIdx}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):undefined;function writeArrayToMemory(array,buffer){assert(array.length>=0,"writeArrayToMemory array must have a length (should be an array or typed array)");HEAP8.set(array,buffer);}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){assert(str.charCodeAt(i)===(str.charCodeAt(i)&255));HEAP8[buffer++>>0]=str.charCodeAt(i);}if(!dontAddNull)HEAP8[buffer>>0]=0;}var buffer,HEAP8,HEAPU8,HEAP32,HEAPU32;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=new Float32Array(buf);Module["HEAPF64"]=new Float64Array(buf);}var TOTAL_STACK=5242880;if(Module["TOTAL_STACK"])assert(TOTAL_STACK===Module["TOTAL_STACK"],"the stack size can no longer be determined at runtime");var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;legacyModuleProp("INITIAL_MEMORY","INITIAL_MEMORY");assert(INITIAL_MEMORY>=TOTAL_STACK,"INITIAL_MEMORY should be larger than TOTAL_STACK, was "+INITIAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");assert(typeof Int32Array!="undefined"&&typeof Float64Array!=="undefined"&&Int32Array.prototype.subarray!=undefined&&Int32Array.prototype.set!=undefined,"JS engine does not provide full typed array support");assert(!Module["wasmMemory"],"Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");assert(INITIAL_MEMORY==16777216,"Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");var wasmTable;function writeStackCookie(){var max=_emscripten_stack_get_end();assert((max&3)==0);HEAP32[max>>2]=34821223;HEAP32[max+4>>2]=2310721022;HEAPU32[0]=1668509029;}function checkStackCookie(){if(ABORT)return;var max=_emscripten_stack_get_end();var cookie1=HEAPU32[max>>2];var cookie2=HEAPU32[max+4>>2];if(cookie1!=34821223||cookie2!=2310721022){abort("Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x"+cookie2.toString(16)+" 0x"+cookie1.toString(16));}if(HEAPU32[0]!==1668509029)abort("Runtime error: The application has corrupted its heap memory area (address zero)!");}(function(){var h16=new Int16Array(1);var h8=new Int8Array(h16.buffer);h16[0]=25459;if(h8[0]!==115||h8[1]!==99)throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)"})();var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){assert(!runtimeInitialized);runtimeInitialized=true;checkStackCookie();callRuntimeCallbacks(__ATINIT__);}function postRun(){checkStackCookie();if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnInit(cb){__ATINIT__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}assert(Math.imul,"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.fround,"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.clz32,"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.trunc,"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;var runDependencyTracking={};function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(id){assert(!runDependencyTracking[id]);runDependencyTracking[id]=1;if(runDependencyWatcher===null&&typeof setInterval!="undefined"){runDependencyWatcher=setInterval(function(){if(ABORT){clearInterval(runDependencyWatcher);runDependencyWatcher=null;return}var shown=false;for(var dep in runDependencyTracking){if(!shown){shown=true;err("still waiting on run dependencies:");}err("dependency: "+dep);}if(shown){err("(end of list)");}},1e4);}}else {err("warning: run dependency added without ID");}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(id){assert(runDependencyTracking[id]);delete runDependencyTracking[id];}else {err("warning: run dependency removed without ID");}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null;}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}function abort(what){{if(Module["onAbort"]){Module["onAbort"](what);}}what="Aborted("+what+")";err(what);ABORT=true;var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var FS={error:function(){abort("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM");},init:function(){FS.error();},createDataFile:function(){FS.error();},createPreloadedFile:function(){FS.error();},createLazyFile:function(){FS.error();},open:function(){FS.error();},mkdev:function(){FS.error();},registerDevice:function(){FS.error();},analyzePath:function(){FS.error();},loadFilesFromDB:function(){FS.error();},ErrnoError:function ErrnoError(){FS.error();}};Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}function createExportWrapper(name,fixedasm){return function(){var displayName=name;var asm=fixedasm;if(!fixedasm){asm=Module["asm"];}assert(runtimeInitialized,"native function `"+displayName+"` called before runtime initialization");if(!asm[name]){assert(asm[name],"exported native function `"+displayName+"` not found");}return asm[name].apply(null,arguments)}}var wasmBinaryFile;wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABpAMzYAJ/fwBgAX8Bf2ABfwBgAn9/AX9gA39/fwF/YAN/f38AYAR/f39/AGAEf39/fwF/YAV/f39/fwBgBn9/f39/fwF/YAV/f39/fwF/YAh/f39/f39/fwF/YAZ/f39/f38AYAAAYAd/f39/f39/AGAHf39/f39/fwF/YAABf2AFf35+fn4AYAV/f39/fgF/YAJ/fABgAX8BfGADf35/AX5gAnx/AXxgBH9+fn8AYAp/f39/f39/f39/AX9gBn9/f39+fgF/YAd/f39/f35+AX9gCX9/f39/f39/fwF/YAZ/fH9/f38Bf2AFf39+f38AYAR/f39/AX5gDH9/f39/f39/f39/fwF/YAV/f39/fAF/YAt/f39/f39/f39/fwF/YAp/f39/f39/f39/AGAPf39/f39/f39/f39/f39/AGADf39/AX5gCH9/f39/f39/AGAEf398fABgAnx8AX9gAn5/AX9gAn9+AGACf38BfmADf39+AGAEfn5+fgF/YAN+fn4Bf2ACfn4BfGACfn4BfWAEf39/fgF+YAN/f38BfWADf39/AXwC+wIOA2VudhhfX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24AAQNlbnYLX19jeGFfdGhyb3cABQNlbnYFYWJvcnQADQNlbnYEZXhpdAACA2VudhVlbXNjcmlwdGVuX21lbWNweV9iaWcABRZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAEWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQAHA2VudhZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwAAEWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9yZWFkAAcWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MRFlbnZpcm9uX3NpemVzX2dldAADFndhc2lfc25hcHNob3RfcHJldmlldzELZW52aXJvbl9nZXQAAwNlbnYKc3RyZnRpbWVfbAAKA2VudgtzZXRUZW1wUmV0MAACFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfc2VlawAKA5AIjggNAgEBBAEDAQINDQECEwIAAAECFAICAAICAgYIBQYAAwYBAgICAgECAgECAAECAQMBAgIBAgECAQECAAIBBAQEAwICAAAFAQkBAwMABQQFAAUCAQEBAQIBAgIGAQwCBQQIDAgOCwAGBQECAgkBAQoCAgYGCAoBAwMFAwECAgICAAIHAAIFBgIEBgQDBgYBAAICAgACBAECAQIAAwENCAQJAgUAAwMBAwUDAAAAAAADAAMACAAACQ8IDgUKBQAHAQIIAwcABggIAAUFAQUFAgMAAAgBAQIGCAgIDgAABgQICgMIAgYICA4AAQIbCAcBAgICAgACBwAAAgUFAgYEAwYGAQACAgICBAECAQIDAwEDBQAAAwAIAAAJCwgOAAMHAAMABQYIAAUFBAUFBQoFAgEmAhADECcUExQTAwMUAAEAAhAAAQMCAgABAwABAwICBAQEAQAWFgEEFQEBAwEEEBYEBwoPBQEGKAgcAAEBKQERFxEGKgcrAwMBAgMAAREXLC0REwAAFxERES4vBQYHCgQDBQEEDQQBAQIBAgEEHQYEBQEBAwQDAQECAgIBAwEBAwADAQEBAgIDAgAAAQIBBAUBBAIBAwEDAwEAAQAFAAEFAAEBAwMAARUDAQUABQAAAQICAAEDAQMAAQQDAgABAwEDAAQDBAQDBAEDBAcEAwcCAQcwBgoGBAoGBQQJAQ8DBAkBBRgHBgkeCQcJBwkeCQgfMQkyCQYJEAQEAwkBDwkDBRgJCQkJCQgfCQkJBAoBAQoGCgQOEgoSIAQBBw4ZCgEKAQoOCRIKEiAOGQoEAAALAQkJCQwJDAkICgsLCQkJDAkMCQgKCw8MAw8BAAAAAQAADyEABQUPAQEDAA8hAA8BAAEDGiIjBAkaIiMJBAwMAQACAQUQAQUCAQIEAgIEBwcHAwQDBAcECgECAwQDBAcECgsKCgILBAsKCgEBCgELCwoBCwsKAQIBAgEBAAAAAAAAAAABAgECAAECAQIBAgECAQIBAgECAQIBAgECAQIBAgIBAQUAAQMDAAIBAw0FJCQBAAAFJQEMBQUFBAAlAQgADQQEAwUGBgYGBggMCAgIDAwMAQEBAQECEAIBDRAQEAcAAwMBAwUEAQACAgEBAwMBAQAFDwMAAwEDAQMEBAEBAAABAwEBBgUDBAADAAABAwMDAwQAAwQHAwEDAwAAAAMDAwMAAAEDAwQHBwEEAQMDAwMDBAEBBAEDBwkDAQIABQAAAAAAAwAAAwAAAAAAAAAAAAAAAAAAAgMAAAAHAAAAAAMAAAAAAAcAAAAABAAAAAAHAAAAAAAAAAAAAAAAAAADAwMDAAAAAAADAAAABAAAAAAAAAMDAwAAAAAEAAAAAAAAAwABAAAFAAQACg4PGxgEBwFwAfcF9wUFBwEBgAKAgAIGEwN/AUHw9MICC38BQQALfwFBAAsHuxBABm1lbW9yeQIAEV9fd2FzbV9jYWxsX2N0b3JzAA4ZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEABm1hbGxvYwCFAwRmcmVlAIYDJWVtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzAAvgI3ZW1zY3JpcHRlbl9iaW5kX0FycmFuZ2VtZW50QnVpbGRlcl9BcnJhbmdlbWVudEJ1aWxkZXJfMAC/AjBlbXNjcmlwdGVuX2JpbmRfQXJyYW5nZW1lbnRCdWlsZGVyX2dldFBvbHlnb25zXzEAwAIwZW1zY3JpcHRlbl9iaW5kX0FycmFuZ2VtZW50QnVpbGRlcl9fX2Rlc3Ryb3lfX18wAL4CHWVtc2NyaXB0ZW5fYmluZF9Qb2ludF9Qb2ludF8wAMECHWVtc2NyaXB0ZW5fYmluZF9Qb2ludF9Qb2ludF8yAMICHWVtc2NyaXB0ZW5fYmluZF9Qb2ludF9nZXRfeF8wAMMCHWVtc2NyaXB0ZW5fYmluZF9Qb2ludF9zZXRfeF8xAMQCHWVtc2NyaXB0ZW5fYmluZF9Qb2ludF9nZXRfeV8wAMUCHWVtc2NyaXB0ZW5fYmluZF9Qb2ludF9zZXRfeV8xAMYCI2Vtc2NyaXB0ZW5fYmluZF9Qb2ludF9fX2Rlc3Ryb3lfX18wAL4CIWVtc2NyaXB0ZW5fYmluZF9Qb2x5Z29uX1BvbHlnb25fMgDHAihlbXNjcmlwdGVuX2JpbmRfUG9seWdvbl9nZXRJbnNpZGVQb2ludF8xAMgCLWVtc2NyaXB0ZW5fYmluZF9Qb2x5Z29uX2dldFBvbHlUcmlzdHJpcEFyZWFfMADJAiVlbXNjcmlwdGVuX2JpbmRfUG9seWdvbl9nZXRfY29udG91cl8wAEUlZW1zY3JpcHRlbl9iaW5kX1BvbHlnb25fc2V0X2NvbnRvdXJfMQDKAiNlbXNjcmlwdGVuX2JpbmRfUG9seWdvbl9nZXRfaG9sZXNfMADLAiNlbXNjcmlwdGVuX2JpbmRfUG9seWdvbl9zZXRfaG9sZXNfMQDMAiVlbXNjcmlwdGVuX2JpbmRfUG9seWdvbl9fX2Rlc3Ryb3lfX18wAM0CJWVtc2NyaXB0ZW5fYmluZF9Qb2ludExpc3RfUG9pbnRMaXN0XzAAzgIlZW1zY3JpcHRlbl9iaW5kX1BvaW50TGlzdF9wdXNoX2JhY2tfMQDPAiBlbXNjcmlwdGVuX2JpbmRfUG9pbnRMaXN0X3NpemVfMADQAh5lbXNjcmlwdGVuX2JpbmRfUG9pbnRMaXN0X2F0XzEA0QIhZW1zY3JpcHRlbl9iaW5kX1BvaW50TGlzdF9jbGVhcl8wANICJ2Vtc2NyaXB0ZW5fYmluZF9Qb2ludExpc3RfX19kZXN0cm95X19fMADTAillbXNjcmlwdGVuX2JpbmRfUG9seWdvbkxpc3RfUG9seWdvbkxpc3RfMADOAidlbXNjcmlwdGVuX2JpbmRfUG9seWdvbkxpc3RfcHVzaF9iYWNrXzEA1AIiZW1zY3JpcHRlbl9iaW5kX1BvbHlnb25MaXN0X3NpemVfMADVAiBlbXNjcmlwdGVuX2JpbmRfUG9seWdvbkxpc3RfYXRfMQDWAiNlbXNjcmlwdGVuX2JpbmRfUG9seWdvbkxpc3RfY2xlYXJfMADSAillbXNjcmlwdGVuX2JpbmRfUG9seWdvbkxpc3RfX19kZXN0cm95X19fMADTAiFlbXNjcmlwdGVuX2JpbmRfQ29udG91cl9Db250b3VyXzAAzgIjZW1zY3JpcHRlbl9iaW5kX0NvbnRvdXJfcHVzaF9iYWNrXzEAzwIeZW1zY3JpcHRlbl9iaW5kX0NvbnRvdXJfc2l6ZV8wANACHGVtc2NyaXB0ZW5fYmluZF9Db250b3VyX2F0XzEA0QIfZW1zY3JpcHRlbl9iaW5kX0NvbnRvdXJfY2xlYXJfMADSAiVlbXNjcmlwdGVuX2JpbmRfQ29udG91cl9fX2Rlc3Ryb3lfX18wANMCKWVtc2NyaXB0ZW5fYmluZF9Db250b3VyTGlzdF9Db250b3VyTGlzdF8wAM4CJ2Vtc2NyaXB0ZW5fYmluZF9Db250b3VyTGlzdF9wdXNoX2JhY2tfMQDXAiJlbXNjcmlwdGVuX2JpbmRfQ29udG91ckxpc3Rfc2l6ZV8wANgCIGVtc2NyaXB0ZW5fYmluZF9Db250b3VyTGlzdF9hdF8x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AgAiASACRwRAA0AgASgCBCIDIAEoAgAiAjYCACABKAIAIAM2AgQgACAAKAJEQQFrNgJEQbDGAi0AAEUEQEH4xAJCADcCAEGwxgJBAToAAEGkxQJCIDcCAEGcxQJClICAgIAENwIAQYDFAkIANwIAQYjFAkIANwIAQZDFAkIANwIAQZjFAkEANgIACyABQZDFAigCADYCAEGQxQIgATYCACACIgEgACgCQEcNAAsLC8kCAQN/IwBBEGsiAyQAQa/GAi0AAEUEQEG8xAJCADcCAEGvxgJBAToAAEHoxAJCIDcCAEHgxAJCtICAgIAENwIAQcTEAkIANwIAQczEAkIANwIAQdTEAkIANwIAQdzEAkEANgIACwJAQdTEAigCACIBBEBB1MQCIAEoAgA2AgAMAQtB1MQCEDoiAQ0AIANBCGoiAEHI+gE2AgAgAEGg+gE2AgAgABA7AAsgAUEANgIwIAFBADYCBCABQQA2AiggASABQSBqIgI2AiQgASACNgIgIAFBADYCHCABIAFBFGoiAjYCGCABIAI2AhQgAUEANgIQIAEgAUEIaiICNgIMIAEgAjYCCCABQbgwNgIAIAEgACgCHCICNgIsIAEgAigCMDYCMCACKAIwIAE2AiwgAiABNgIwIAAgACgCIEEBajYCICADQRBqJAAgAQunBAECfyAAQZgBEJ0GEBM2AgBB6AAQnQZBAEHgABDeAiEBQQQQnQYhAiABQgA3AxAgASACNgIAIAEgAkEEajYCCCACQQA2AQAgAUEANgIgIAFCADcDGCABIAI2AgRBBBCdBiECIAFCADcDKCABIAI2AhggASACQQRqNgIgIAJBATYBACABQQA2AjggAUIANwMwIAEgAkECajYCHEEEEJ0GIQIgAUFAa0IANwMAIAEgAjYCMCABIAJBBGo2AjggAkEANgEAIAFBADYCUCABQgA3A0ggASACNgI0QQQQnQYhAiABQgA3A1ggASACNgJIIAEgAkEEajYCUCACQQE2AQAgAUEBNgJgIAEgAkECajYCTCAAIAE2AgRB6AAQnQZBAEHgABDeAiEBQQQQnQYhAiABQgA3AxAgASACNgIAIAEgAkEEajYCCCACQQA2AQAgAUEANgIgIAFCADcDGCABIAI2AgRBBBCdBiECIAFCADcDKCABIAI2AhggASACQQRqNgIgIAJBATYBACABQQA2AjggAUIANwMwIAEgAkECajYCHEEEEJ0GIQIgAUFAa0IANwMAIAEgAjYCMCABIAJBBGo2AjggAkEANgEAIAFBADYCUCABQgA3A0ggASACNgI0QQQQnQYhAiABQgA3A1ggASACNgJIIAEgAkEEajYCUCACQQE2AQAgAUEBNgJgIAEgAkECajYCTCAAQYCAgAg2AgwgACABNgIIIAAL2gQCC38CfCMAQfAAayIDJAAgASsDACEOIANCADcDICADQQA2AhggA0IANwMQIANBEGoiBSAOEBsgAysDICEOIAMoAhQhASADKAIQIQYgAisDACEPIANCADcDICADQQA2AhggA0IANwMQIAUgDxAbIAMrAyAhDyADKAIUIQcgAygCECECIANBADYCGCADQgA3AxACQAJAIAEgBkcEQCABIAZrIgFBAEgNASADIAEQnQYiCDYCECADIAggAUEBdUEBdGoiCzYCGCADIAggBiABENwCIAFqIgw2AhQLIAMgDjkDICADQQIQnQYiBUECaiIJNgIwIAMgBTYCKCAFQQE7AQAgA0IANwM4IAMgCTYCLCADQUBrQgA3AwAgA0EANgJIIAIgB0cEQCAHIAJrIgFBAEgNAiADIAEQnQYiBDYCQCADIAQ2AkQgAyAEIAFBAXVBAXRqIg02AkggBCACIAEQ3AIgAWohCgtBAhCdBiIHQQE7AQBB6AAQnQYiAUEBNgJgIAEgBDYCMCABIAU2AhggASAOOQMQIAEgCzYCCCABIAw2AgQgASAINgIAIAFCADcDWCABIAdBAmoiBDYCUCABIAQ2AkwgASAHNgJIIAFBQGsgDzkDACABIA02AjggASAKNgI0IAFCADcDKCABIAk2AiAgASAJNgIcIAMgATYCCCADIAE2AgAgASABKAJgQQFqNgJgIANBCGoQFRogACABNgIAIAEgASgCYEEBajYCYCADEBUaIAIEQCACEIYDCyAGBEAgBhCGAwsgA0HwAGokACAADwsQFwALEBcAC/0CAQF/IABBAEGQARDeAiEAQQQQnQYhASAAQgA3AxAgACABNgIAIAAgAUEEajYCCCABQQA2AQAgAEEANgIgIABCADcDGCAAIAE2AgRBBBCdBiEBIABCADcDKCAAIAE2AhggACABQQRqNgIgIAFBATYBACAAQQA2AjggAEIANwMwIAAgAUECajYCHEEEEJ0GIQEgAEFAa0IANwMAIAAgATYCMCAAIAFBBGo2AjggAUEANgEAIABBADYCUCAAQgA3A0ggACABNgI0QQQQnQYhASAAQgA3A1ggACABNgJIIAAgAUEEajYCUCABQQE2AQAgAEEANgJoIABCADcDYCAAIAFBAmo2AkxBBBCdBiEBIABCADcDcCAAIAE2AmAgACABQQRqNgJoIAFBADYBACAAQQA2AoABIABCADcDeCAAIAE2AmRBBBCdBiEBIABCADcDiAEgACABNgJ4IAAgAUEEajYCgAEgAUEBNgEAIABBATYCkAEgACABQQJqNgJ8IAALkQgCCH8HfCMAQeAAayICJAAgACgCBCIDIAAoAgBHBEBBAUF/IANBAmsuAQBBAEobIQcLIAAoAhwiCCAAKAIYRiIGRQRAQQFBfyAIQQJrLgEAQQBKGyEFCyABKAIEIgMgASgCAEcEQEEBQX8gA0ECay4BAEEAShshBAsgBSAHbCEFIAEoAhwiCSABKAIYRiIDBH9BAAVBAUF/IAlBAmsuAQBBAEobCyAEbCEEAkAgBUUEQEEAIARrIQUMAQsgBEUNACAEIAVGBEBBACEHQQAhBCAGRQRAQX9BASAIQQJrLgEAQQBMGyEECyADRQRAQX9BASAJQQJrLgEAQQBMGyEHCyACQTBqIgMgACABQRhqEFNBBBCdBiEGIAJCADcDKCACIAY2AhggAiAGQQRqNgIgIAZBADsBAiAGIAQgB2wiBDsBACACIAZBAmogBiAEGzYCHCACQcgAaiADIAJBGGoQUyACKAIYIgMEQCACIAM2AhwgAxCGAwsgAigCMCIDBEAgAiADNgI0IAMQhgMLIAJBGGoiAyABIABBGGoQU0EEEJ0GIQAgAkIANwMQIAIgADYCACACIABBBGo2AgggAEEAOwECIAAgBDsBACACIABBAmogACAEGzYCBCACQTBqIAMgAhBTIAIoAgAiAARAIAIgADYCBCAAEIYDCyACKAIYIgAEQCACIAA2AhwgABCGAwsgAigCNCEBIAIoAjAhAwJ/IAIoAkgiBCACKAJMIgBGBEBBACABIANGDQEaQX9BASABQQJrLgEAQQBKGwwBCyABIANGBEBBAUF/IABBAmsuAQBBAEobDAELIAIrA0AiDCABIANrQQF1uKAiDiACKwNYIg0gACAEa0EBdbigIg8gDiAPZBshCiAMIA0gDCANYxshEANAQQAgCkQAAAAAAADwv6AiCiAQZkUNARpBASAKIA9mRSAKIA1jQX9zcSIBBH8gBAJ/IAogDaEiC5lEAAAAAAAA4EFjBEAgC6oMAQtBgICAgHgLQQF0ai8BAAVBAAtBEHRBEHUgCiAOZkUgCiAMY0F/c3EiAAR/IAMCfyAKIAyhIguZRAAAAAAAAOBBYwRAIAuqDAELQYCAgIB4C0EBdGovAQAFQQALQRB0QRB1Sg0BGiABBH8gBAJ/IAogDaEiC5lEAAAAAAAA4EFjBEAgC6oMAQtBgICAgHgLQQF0ai8BAAVBAAtBEHRBEHUgAAR/IAMCfyAKIAyhIguZRAAAAAAAAOBBYwRAIAuqDAELQYCAgIB4C0EBdGovAQAFQQALQRB0QRB1Tg0AC0F/CyEFIAMEQCACIAM2AjQgAxCGAyACKAJIIQQLIARFDQEgAiAENgJMIAQQhgMMAQtBf0EBIAQgBUobIQULIAJB4ABqJAAgBQuUAQECfwJAIAAoAgAiASgCYEEBRwRAIAEgASgCYCIBQQFrNgJgIAFBAUcNAQsgACgCACIBKAJIIgIEQCABIAI2AkwgAhCGAwsgASgCMCICBEAgASACNgI0IAIQhgMLIAEoAhgiAgRAIAEgAjYCHCACEIYDCyABKAIAIgIEQCABIAI2AgQgAhCGAwsgACgCABCGAwsgAAuIAQEBfyAAKAJ4IgEEQCAAIAE2AnwgARCGAwsgACgCYCIBBEAgACABNgJkIAEQhgMLIAAoAkgiAQRAIAAgATYCTCABEIYDCyAAKAIwIgEEQCAAIAE2AjQgARCGAwsgACgCGCIBBEAgACABNgIcIAEQhgMLIAAoAgAiAQRAIAAgATYCBCABEIYDCwsIAEHrEhAzAAsuAQF/QQQQACIAQcj6ATYCACAAQaD6ATYCACAAQbT6ATYCACAAQaT7AUEBEAEAC60EAQd/IABBsCs2AgAgACgCECICKAIQIgEgAkcEQANAIAEoAggiAwRAIAMQFRCGAyAAKAIQIQILIAEoAhAiASACRw0ACwsgACgCHCIDKAIcIgIgA0cEQANAIAIoAhgiAQRAIAFBCGoQFRogAUEEahAVGgJAIAEoAgAiAygCkAFBAUcEQCADIAMoApABIgNBAWs2ApABIANBAUcNAQsgASgCABAWIAEoAgAQhgMLIAEQhgMgACgCHCEDCyACKAIcKAIcIgIgA0cNAAsLAkAgAC0AfEUNACAAKAJ4IgFFDQAgARCGAyAAQQA2AngLIAAoAnAiASAAQewAaiIFRwRAA0AgASgCBCEDIAEoAggiBCgCBARAIAQgBCgCACgCKBECAAJAIAQoAgQiBigCcCIBIAZB7ABqIgdGDQADQCABKAIEIQIgBCABKAIIRgRAIAEoAgAiByACNgIEIAEoAgQgBzYCACAGIAYoAnRBAWs2AnQgARCGAwwCCyACIgEgB0cNAAsLIARBADYCBCAEIAQoAgAoAiwRAgALIAMiASAFRw0ACwsCQCAAKAJ0RQ0AIAAoAnAiASgCACICIAAoAmwiAygCBDYCBCADKAIEIAI2AgAgAEEANgJ0IAEgBUYNAANAIAEoAgQhAiABEIYDIAIiASAFRw0ACwsgAEGELTYCBCAAQQxqIgEQDwJAIAAtAGBFDQAgACgCXCICRQ0AIAIQhgMgAEEANgJcCyABECAgAAvfBQEHfyMAQRBrIgYkACAAIAAoAgQoAiwiAjYCCCAAQdQAaiEDIAAoAlggACgCVCIEayIHQQxtIQECQCACQR9NBEAgAUEfTQRAIANBICABaxAsDAILIAdBgANGDQEgACAEQYADajYCWAwBCyABIAJJBEAgAyACIAFrECwMAQsgASACTQ0AIAAgBCACQQxsajYCWAsgACgCJCIDQQxqIgEgACgCLCIESQRAIAMgACgCMEEMbGohByAAKAIQIQUgAyECA0AgBSACKAIMRiABIAdJcUUEQCACQQA2AhALIAEiAkEMaiIBIARJDQALCyAAQQxqIQcgAxCGAyAAQoCEgIDwPzcCMCAAQYDIABCdBjYCJEEAIQIDQCACQQxsIgEgACgCJGoiA0IANwIAIANBADYCCCAAKAIkIAJBAXJBDGxqIgNCADcCACADQQA2AgggASAAKAIkaiIDQQA2AiAgA0IANwIYIAEgACgCJGoiA0EANgIsIANCADcCJCABIAAoAiRqIgNBADYCOCADQgA3AjAgASAAKAIkaiIBQQA2AkQgAUIANwI8IAJBBmoiAkGABkcNAAsgACAAKAIkIgJBgDBqNgIsIAAgAkGAyABqNgIoIABBGGohAyAAKAIQIQRBACEBA0AgAiABQQxsaiIFIAQ2AgAgBSADNgIIIAIgAUEBckEMbGoiBSAENgIAIAUgAzYCCCACIAFBAnJBDGxqIgUgBDYCACAFIAM2AgggAiABQQNyQQxsaiIFIAQ2AgAgBSADNgIIIAFBBGoiAUGABEcNAAsgAiAAKAIUNgIAIAAoAgQiASgCKCIDKAIsIgIgA0cEQCABQQRqIQRBACEBA0AgBiAENgIIIAYgAzYCBCAGIAI2AgAgByAGEC0gATYCACAAKAJUIAFBDGxqIgUgBikDADcCACAFIAYoAgg2AgggAUEBaiEBIAIoAiwiAiAAKAIEKAIoRw0ACwsgBkEQaiQAC4gGAgd/AnwCQAJAAkAgAUQAAAAAAAAAAGENACABRBAAEAAQAODAYyABROD/3//f/99AZHIEQCAAKwMQIQkDQCAJRAAAAAAAAPA/oCEJIAFEAAAAAAAA8D6iIgFEEAAQABAA4MBjDQAgAUTg/9//3//fQGQNAAsgACAJOQMQCwJAIAFEEAAQABAA4L9mRQ0AIAFE4P/f/9//3z9lRQ0AIAArAxAhCQNAAkAgCUQAAAAAAADwv6AhCSABRAAAAAAAAPBAoiIBRBAAEAAQAOC/ZkUNACABROD/3//f/98/ZQ0BCwsgACAJOQMQCyABIQkDQCABAn8gAQJ/IAGZRAAAAAAAAOBBYwRAIAGqDAELQYCAgIB4CyICt6EiAUQAAAAAAADgP2QEQCACQQFqDAELIAJBAWsgAUQAAAAAAADgv2MNABogAkEBcSEDAkAgAUQAAAAAAADgP2INACADRQ0AIAJBAWoMAQsgAiABRAAAAAAAAOC/YSADcWsLIgK3oUTg/9//3//fP2YgAmohBwJAIAAoAgQiAiAAKAIIIgRJBEAgAiAHOwEAIAAgAkECaiICNgIEDAELIAIgACgCACIDayIFQX1MDQMgBCADayICIAVBAXUiCEEBaiIEIAIgBEsbQf////8HIAJB/v///wdJGyIGBH8gBkEASA0FIAZBAXQQnQYFQQALIQQgBCAIQQF0aiICIAc7AQAgAkECaiECIAVBAEoEQCAEIAMgBRDcAhoLIAAgBCAGQQF0ajYCCCAAIAI2AgQgACAENgIAIANFDQAgAxCGAyAAKAIEIQILIAkgCiACQQJrIgMuAQC3oCIKoSIBRAAAAAAAAAAAYgRAIAAgACsDEEQAAAAAAADwv6A5AxAgAUQAAAAAAADwQKIhASAJRAAAAAAAAPBAoiEJIApEAAAAAAAA8ECiIQoMAQsLIAAoAgAiACACRg0AIAAgA08NAANAIAAvAQAhAiAAIAMvAQA7AQAgAyACOwEAIABBAmoiACADQQJrIgNJDQALCw8LEBcACxAYAAtPAQF/IABBCGoQFRogAEEEahAVGgJAIAAoAgAiASgCkAFBAUcEQCABIAEoApABIgFBAWs2ApABIAFBAUcNAQsgACgCABAWIAAoAgAQhgMLC7oCAgd/AnwgACAAKAIANgIEIAEoAgAhBQJAAkADQCAFKAIQQX5xKAIIKAIAECEhCSAFKAIQQX5xKAIIKAIAQTBqECEhCgJAIAAoAgQiAiAAKAIIIgNJBEAgAiAKOQMIIAIgCTkDACAAIAJBEGo2AgQMAQsgAiAAKAIAIgJrIgdBBHUiBkEBaiIEQYCAgIABTw0CIAMgAmsiA0EDdSIIIAQgBCAISRtB/////wAgA0Hw////B0kbIgQEfyAEQYCAgIABTw0EIARBBHQQnQYFQQALIgMgBkEEdGoiBiAKOQMIIAYgCTkDACAHQQBKBEAgAyACIAcQ3AIaCyAAIAMgBEEEdGo2AgggACAGQRBqNgIEIAAgAzYCACACRQ0AIAIQhgMLIAUoAgwiBSABKAIARw0ACw8LEBcACxAYAAuuAwEHfwJAAkACQAJAIAAoAgQiAyAAKAIAIghrQQxtIgdBAWoiAkHWqtWqAUkEQCAAKAIIIAhrQQxtIgRBAXQiBiACIAIgBkkbQdWq1aoBIARBqtWq1QBJGyIEBEAgBEHWqtWqAU8NAiAEQQxsEJ0GIQULIAUgB0EMbGoiAkEANgIIIAJCADcCACABKAIEIgYgASgCACIHRwRAIAYgB2siAUEASA0DIAIgARCdBiIGNgIAIAIgBiABQQR1QQR0ajYCCCACIAYgByABENwCIAFqNgIECyAFIARBDGxqIQEgAkEMaiEEIAMgCEYNAwNAIAJBDGsiAiADQQxrIgMoAgA2AgAgAiADKAIENgIEIAIgAygCCDYCCCADQQA2AgggA0IANwIAIAMgCEcNAAsgACABNgIIIAAoAgQhBSAAIAQ2AgQgACgCACEDIAAgAjYCACADIAVGDQQDQCAFQQxrIgAoAgAiAQRAIAVBCGsgATYCACABEIYDCyAAIgUgA0cNAAsMBAsQFwALEBgACxAXAAsgACABNgIIIAAgBDYCBCAAIAI2AgALIAMEQCADEIYDCwurAQEEfyAAQYgINgIAIAAoAlQiAQRAIAAgATYCWCABEIYDCyAAKAI4IgEEQCABEIYDCyAAKAIkEIYDIABByAw2AgACQCAAKAIEIgNFDQAgAygCcCICIANB7ABqIgRGDQADQCACKAIEIQEgACACKAIIRgRAIAIoAgAiBCABNgIEIAIoAgQgBDYCACADIAMoAnRBAWs2AnQgAhCGAyAADwsgASICIARHDQALCyAAC6cEAQV/IAAQDyAAQUBrKAIAIgEoAgAiAiABRwRAIAAoAkQhAwNAIAIoAgQiBCACKAIAIgU2AgAgAigCACAENgIEIANBAWshAyAFIgIgAUcNAAsgACADNgJECyABEIYDIAAoAjQiASgCACICIAFHBEAgACgCOCEDA0AgAigCBCIEIAIoAgAiBTYCACACKAIAIAQ2AgQgA0EBayEDIAUiAiABRw0ACyAAIAM2AjgLIAEQhgMgACgCKCIBKAIAIgIgAUcEQCAAKAIsIQMDQCACKAIEIgQgAigCACIFNgIAIAIoAgAgBDYCBCADQQFrIQMgBSICIAFHDQALIAAgAzYCLAsgARCGAyAAKAIcIgEoAiwiAiABRwRAIAAoAiAhAwNAIAIoAjAiBCACKAIsIgU2AiwgAigCLCAENgIwIANBAWshAyAFIgIgAUcNAAsgACADNgIgCyABIAEoAgAoAgARAQAaIAEQhgMgACgCECIBKAIcIgIgAUcEQCAAKAIUIQMDQCACKAIgIgQgAigCHCIFNgIcIAIoAhwgBDYCICADQQFrIQMgBSICIAFHDQALIAAgAzYCFAsgASABKAIAKAIAEQEAGiABEIYDIAAoAgQiASgCECICIAFHBEAgACgCCCEDA0AgAigCFCIEIAIoAhAiBTYCECACKAIQIAQ2AhQgA0EBayEDIAUiAiABRw0ACyAAIAM2AggLIAEgASgCACgCABEBABogARCGAwueBAIJfAR/An9BACAAKAIAIgsgACgCBCIKRg0AGkQAAAAAAADwPyECRAAAAAAAAPA/QXAQ4QIhByAAKwMQIgMgCiALa0EBdSIKuKAiBEQAAAAAAADwv6AiASABIApBBSAKQQVJG7ehIghkBEADQCAHIAKiIQJBACEKAkAgASADYw0AIAEgBGYNACALAn8gASADoSIJmUQAAAAAAADgQWMEQCAJqgwBC0GAgICAeAtBAXRqLwEAIQoLIAIgCkEQdEEQdbeiIAagIQYgAUQAAAAAAADwv6AiASAIZA0ACwsgBEQAAAAAAAAwQKIiAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIQ0CQCAAKAIYIgsgACgCHCIKRg0ARAAAAAAAAPA/IQJEAAAAAAAA8D9BcBDhAiEHIAArAygiAyAKIAtrQQF1IgC4oCIERAAAAAAAAPC/oCIBIAEgAEEFIABBBUkbt6EiCGQEQANAIAcgAqIhAkEAIQoCQCABIANjDQAgASAEZg0AIAsCfyABIAOhIgmZRAAAAAAAAOBBYwRAIAmqDAELQYCAgIB4C0EBdGovAQAhCgsgAiAKQRB0QRB1t6IgBaAhBSABRAAAAAAAAPC/oCIBIAhkDQALCyAERAAAAAAAADBAoiIBmUQAAAAAAADgQWMEQCABqiEMDAELQYCAgIB4IQwLIAYgBaNEAAAAAAAA8D8gDSAMaxDhAqILMAEBfyAAKAIYIgEEQCAAIAE2AhwgARCGAwsgACgCACIBBEAgACABNgIEIAEQhgMLC7EBAQR/IABBiAg2AgAgACgCVCIBBEAgACABNgJYIAEQhgMLIAAoAjgiAQRAIAEQhgMLIAAoAiQQhgMgAEHIDDYCAAJAIAAoAgQiA0UNACADKAJwIgIgA0HsAGoiBEYNAANAIAIoAgQhASAAIAIoAghGBEAgAigCACIEIAE2AgQgAigCBCAENgIAIAMgAygCdEEBazYCdCACEIYDIAAQhgMPCyABIgIgBEcNAAsLIAAQhgMLAwABCwYAIAAQGgsDAAELzQMBBn8gAEEANgIIIAAoAiQiAUEMaiICIAAoAiwiBUkEQCABIAAoAjBBDGxqIQQgACgCECEGIAEhAwNAIAYgAygCDEYgAiAESXFFBEAgA0EANgIQCyACIgNBDGoiAiAFSQ0ACwsgARCGAyAAQoCEgIDwPzcCMCAAQYDIABCdBjYCJEEAIQMDQCADQQxsIgIgACgCJGoiAUIANwIAIAFBADYCCCAAKAIkIANBAXJBDGxqIgFCADcCACABQQA2AgggAiAAKAIkaiIBQQA2AiAgAUIANwIYIAIgACgCJGoiAUEANgIsIAFCADcCJCACIAAoAiRqIgFBADYCOCABQgA3AjAgAiAAKAIkaiICQQA2AkQgAkIANwI8IANBBmoiA0GABkcNAAsgACAAKAIkIgNBgDBqNgIsIAAgA0GAyABqNgIoIABBGGohASAAKAIQIQVBACECA0AgAyACQQxsaiIEIAU2AgAgBCABNgIIIAMgAkEBckEMbGoiBCAFNgIAIAQgATYCCCADIAJBAnJBDGxqIgQgBTYCACAEIAE2AgggAyACQQNyQQxsaiIEIAU2AgAgBCABNgIIIAJBBGoiAkGABEcNAAsgAyAAKAIUNgIACwMAAQsDAAELAwABC5oBAQJ/IAAgACgCCEEBaiIBNgIIAkAgACgCWCAAKAJUIgVrQQxtIgMgAU8NACADIAFBAXQiBEkEQCAAQdQAaiAEIANrECwgACgCCCEBDAELIAMgBE0NACAAIAUgBEEMbGo2AlgLIABBDGogAhAtIAFBAWs2AgAgACgCVCAAKAIIQQxsakEMayIAIAIpAgA3AgAgACACKAIINgIIC50CAQd/IAEgACgCCCIEIAAoAgQiAmtBDG1NBEAgACABBH8gAkEAIAFBDGxBDGsiACAAQQxwa0EMaiIAEN4CIABqBSACCzYCBA8LAkAgAiAAKAIAIgJrIgVBDG0iBiABaiIDQdaq1aoBSQRAIAQgAmtBDG0iBEEBdCIIIAMgAyAISRtB1arVqgEgBEGq1arVAEkbIgMEQCADQdaq1aoBTw0CIANBDGwQnQYhBwsgBkEMbCAHakEAIAFBDGxBDGsiASABQQxwa0EMaiIEEN4CIgYgBUF0bUEMbGohASAFQQBKBEAgASACIAUQ3AIaCyAAIAcgA0EMbGo2AgggACAEIAZqNgIEIAAgATYCACACBEAgAhCGAwsPCxAXAAsQGAALxAIBBX8gACgCGCIEIAEoAgBBNG4iAiAAKAIocSIBQQxsaiEDIABBBGohBiAAKAIsBEAgBhAxCyACIAMoAgAiBUYEQCAAQUBrIAI2AgAgBCABQQxsakEEag8LAkAgBSAGKAIAIgVGBEAgAyACNgIAIAQgAUEMbGoiASAAKAIQNgIEDAELIABBDGoiBCACNgIAIAMhAQNAIAEoAggiASgCACACRw0ACyABIARHBEAMAQsgACgCICAAKAIcRgRAIAYQMiAAKAIEIQUgACgCGCAAKAIoIAJxQQxsaiEDCyAFIAMoAgBGBEAgAyACNgIAIAMgACgCEDYCBCADQQRqDwsgACAAKAIgIgFBDGo2AiAgASACNgIAIAEgACgCEDYCBCABIAMoAgg2AgggAyABNgIIIAFBBGoPCyAAQUBrIAI2AgAgAUEEagvbAQECfyMAQRBrIgEkACAAIAAoAghBAWsiBDYCCAJAIAAoAlggACgCVCIFa0EMbSIDIARBAXRBAXJNDQAgA0HAAEkNACAAIAUgA0EBdkEMbGo2AlgLIABBDGoiAyACEC0oAgAiAiAAKAIIIgRHBEAgASAAKAJUIARBDGxqIgQoAgg2AgggASAEKQIANwMAIAMgARAtIAI2AgAgACgCVCACQQxsaiICIAEpAwA3AgAgAiABKAIINgIIIAAoAlQgACgCCEEMbGoiAEEANgIIIABCADcCAAsgAUEQaiQAC3YBBH8gAEHIDDYCAAJAIAAoAgQiAkUNACACKAJwIgEgAkHsAGoiA0YNAANAIAEoAgQhBCAAIAEoAghGBEAgASgCACIDIAQ2AgQgASgCBCADNgIAIAIgAigCdEEBazYCdCABEIYDIAAPCyAEIgEgA0cNAAsLIAALfAEEfyAAQcgMNgIAAkAgACgCBCICRQ0AIAIoAnAiASACQewAaiIDRg0AA0AgASgCBCEEIAAgASgCCEYEQCABKAIAIgMgBDYCBCABKAIEIAM2AgAgAiACKAJ0QQFrNgJ0IAEQhgMgABCGAw8LIAQiASADRw0ACwsgABCGAwvTBQENfyAAKAIoIQMgAEEANgIoIAAoAhwhCSAAIAAoAjAiCjYCHCAAKAIUIQUgACADNgIUIAAoAhghCyAAIAAoAiwiDDYCGCAAKAIgIQ0gACAAKAI0NgIgIAAoAiQhByAAIAAoAjgiATYCJAJ/IAMgASAAKAI8IgRxIgFBDGwiBmoiAigCACIIIARGBEAgAyAGakEEagwBCyAAKAIAIgYgCEYEQCACIAQ2AgAgAyABQQxsaiIBIAAoAgw2AgQgAUEEagwBCyAAIAQ2AgggAEEIaiEIIAIhAQNAIAEoAggiASgCACAERw0ACyABQQRqIAEgCEcNABogCiAMRgRAIAAQMiAAKAIAIQYgACgCFCIDIAAoAiQgBHFBDGxqIQILIAYgAigCAEYEQCACIAQ2AgAgAiAAKAIMNgIEIAJBBGoMAQsgACAAKAIcIgFBDGo2AhwgASAENgIAIAEgACgCDDYCBCABIAIoAgg2AgggAiABNgIIIAFBBGoLKAIAIQQgAxCGAyAAIAc2AiQgACANNgIgIAAgCzYCGCAAIAU2AhQgACAJNgIcIAUgACgCPCICIAdxIgFBDGxqIQMgACgCKARAIAAQMQsgAiADKAIAIgZGBEAgACACNgI8IAUgAUEMbGogBDYCBA8LAkAgBiAAKAIAIgdGBEAgAyACNgIAIAUgAUEMbGoiASAAKAIMNgIEDAELIAAgAjYCCCAAQQhqIQUgAyEBA0AgASgCCCIBKAIAIAJHDQALIAEgBUcNACAAKAIcIAAoAhhGBEAgABAyIAAoAgAhByAAKAIUIAAoAiQgAnFBDGxqIQMLIAcgAygCAEYEQCADIAI2AgAgAyAAKAIMNgIEIAMgBDYCBA8LIAAgACgCHCIBQQxqNgIcIAEgAjYCACABIAAoAgw2AgQgASADKAIINgIIIAMgATYCCCABIAQ2AgQPCyAAIAI2AjwgASAENgIEC6wFAQp/IAAgACgCFCIINgIoIAAgACgCICIGNgI0IAAgACgCJDYCOCAAIAApAhg3AiwgACAGQQF0IgQ2AiAgACAEQQFrNgIkIAZB/////wdxIgkgBGoiCkHWqtWqAUkEQCAAIApBDGwQnQYiAjYCFCAKBEAgCkEBa0EDTwRAIApBfHEhB0EAIQIDQCAAKAIUIAFBDGxqIgNCADcCACADQQA2AgggACgCFCABQQFyQQxsaiIDQgA3AgAgA0EANgIIIAAoAhQgAUECckEMbGoiA0IANwIAIANBADYCCCAAKAIUIAFBA3JBDGxqIgNCADcCACADQQA2AgggAUEEaiEBIAJBBGoiAiAHRw0ACwsgCkEDcSIDBEADQCAAKAIUIAFBDGxqIgJCADcCACACQQA2AgggAUEBaiEBIAVBAWoiBSADRw0ACwsgACgCFCECCyAAIAIgBEEMbGoiBTYCHCAAIAUgCUEMbGo2AhggBEEASgRAIABBCGohByAAKAIAIQMgAiEBA0AgASADNgIAIAEgBzYCCCABQQxqIgEgBUkNAAsLIAIgACgCBDYCACAAKAIoIgJBDGoiASAIIAZBDGxqIgZJBEAgACgCJCEIIAAoAhQhCSAAKAIAIQcDQCAHIAIoAgwiBEcEQCAJIAQgCHFBDGxqIgMgBDYCACADIAIoAhA2AgQLIAEiAkEMaiIBIAZJDQALCyAAKAIsIgggAUsEQCAAKAIAIQkgACgCJCEHIAAoAhQhAwNAIAEoAgQhBgJAIAkgAyAHIAEoAgAiAnFBDGxqIgQoAgBGBEAgBCACNgIAIAQgBjYCBAwBCyAFIAY2AgQgBSACNgIAIAUgBCgCCDYCCCAAIAVBDGoiAjYCHCAEIAU2AgggAiEFCyABQQxqIgEgCEkNAAsLDwsQGAALOgEBf0EIEAAiAUHI+gE2AgAgAUG4+wE2AgAgAUEEaiAAEJ8GIAEiAEHo+wE2AgAgAEGI/AFBAhABAAs8AQJ/IABBhC02AgAgAEEIaiIBEA8CQCAALQBcRQ0AIAAoAlgiAkUNACACEIYDIABBADYCWAsgARAgIAALCQAgABAZEIYDC88CAQR/IAAoAnAiASAAQewAaiIERwRAA0AgASgCCCIDIAMoAgAoAhARAgAgASgCBCIBIARHDQALCyAAKAIQIgMoAhAiASADRwRAA0AgASgCCCICBEAgAhAVEIYDIAAoAhAhAwsgASgCECIBIANHDQALCyAAKAIcIgIoAhwiAyACRwRAA0AgAygCGCIBBEAgAUEIahAVGiABQQRqEBUaAkAgASgCACICKAKQAUEBRwRAIAIgAigCkAEiAkEBazYCkAEgAkEBRw0BCyABKAIAEBYgASgCABCGAwsgARCGAyAAKAIcIQILIAMoAhwoAhwiAyACRw0ACwsgAEEMaiIBEA8gARAPIAAgARAQIgE2AmQgASABKAIEQXxxQQFyNgIEIAAoAnAiACAERwRAA0AgBCgCACgCCCIBIAEoAgAoAhQRAgAgBCgCACIEIABHDQALCwsLACAAQQRqECAgAAsDAAALpQEBAX8gASgCFCICIAEoAhA2AhAgASgCECACNgIUIAAgACgCCEEBazYCCCABIAEoAgAoAgARAQAaQa3GAi0AAEUEQEHEwwJCADcCAEGtxgJBAToAAEHwwwJCIDcCAEHowwJCmICAgIAENwIAQczDAkIANwIAQdTDAkIANwIAQdzDAkIANwIAQeTDAkEANgIACyABQdzDAigCADYCAEHcwwIgATYCAAvBAgEGfwJAQQQgACgCDCIDQQQgA0EESxsiAkEDcSIBa0EAIAEbIAJqIgIgACgCECIBbEEIaiIGEJ0GIgQNACABQQVJBEBBAA8LIAAgAUEBdiIBNgIQIAEgAmxBCGoiBhCdBiIEDQBBAA8LAkAgACAAKAIYIgUEfyABIAJsIANuIAVPDQEgAyAFbCACbiIDIAFBAXQiASABIANLGwUgAUEBdAs2AhALIAQgBiACa0EIayIDIAMgAnAiBWtqIgEgACgCADYCACADIAVHBEACQCAEIAFBACACayIFaiIDRgRAIAEhAgwBCwNAIAMiAiABNgIAIAUgAiIBaiIDIARHDQALCyAEIAI2AgALIAQgBmoiAkEIayAAKAIENgIAIAJBBGsgACgCCDYCACAAIAY2AgggACAENgIEIAAgBCgCADYCACAEC0EAQSAQACIAQX82AhwgAEKAgICAcDcCFCAAQgA3AgwgAEGAMDYCCCAAQewvNgIEIABB1C82AgAgAEGkL0EDEAEACzIBAX8gAEGoMDYCCAJAIAAoAgwiAUUNACABIAEoAgAoAhARAQBFDQAgAEEANgIMCyAAC9oFAQp/AkAgACgCDCIKIAFsIgJBBCAKQQQgCkEESxsiBUEDcSIIa0EAIAgbIAVqIgduIgUgAiAFIAdsR2oiBEUNACAAIQIDQCAEIQYgAigCACIIRQ0BAn8DQCAIIgUgBkEBayIGRQ0BGiAFKAIAIgggBSAHakYNAAsgBSECQQALIgVFDQALIAIoAgAhAyACIAUoAgA2AgALAkAgAUUNACADDQAgACAAKAIQIgIgBCACIARLGyIBNgIQIAEgB2xBCGoiCRCdBiIIRQRAQQAhAyACIARNDQEgACABQQF2IgEgBCABIARLGyIBNgIQIAEgB2xBCGoiCRCdBiIIRQ0BCyABIARLBEAgCCAEIAdsIgJqIQQgCSACa0EIayECAkACQAJAIAAoAgAiA0UNACADIARLDQADQCADIgUoAgAiA0EAIAMgBE0bDQALIAQgAiAHayIGIAYgB3AiC2tqIgIgAzYCACAGIAtGDQIgAiAHayIDIARGDQFBACAHayEGA0AgAyACNgIAIAMiAiAGaiIDIARHDQALDAELIAQgAiAHayIGIAYgB3AiC2tqIgIgAzYCACAAIQUgBiALRg0BIAQgAiAHayIFRwRAQQAgB2shAwNAIAUgAjYCACAFIgIgA2oiBSAERw0ACwsgACEFCyAEIAI2AgALIAUgBDYCAAsCQCAAIAAoAhgiAgR/IAEgB2wgCm4gAk8NASACIApsIAduIgIgAUEBdCIBIAEgAksbBSABQQF0CzYCEAsCQCAAKAIEIgNBACADIAhNG0UEQCAIIAlqIgFBCGsgAzYCACABQQRrIABBCGoiBigCADYCACAAIAg2AgQMAQsgAEEIaiEGA0ACQCADIAYoAgBqIgBBBGshBiAAQQhrIgAoAgAiA0UNACADIAhNDQELCyAIIAlqIgFBBGsgBigCADYCACABQQhrIAM2AgAgACAINgIACyAGIAk2AgAgCCEDCyADC8ACAQV/IwBBEGsiBCQAQSAQnQYhAgJAIAAoAgwiA0UEQCAAKAIQIQEgAkGAMDYCCCACQewvNgIEIAJB1C82AgAgAiABNgIQQQAhAQwBCyADIAMoAgAoAgwRAgAgACgCDCEBIAAoAhAhBSACQYAwNgIIIAJB7C82AgQgAkHULzYCACACIAU2AhAgAUUEQEEAIQEMAQsgBEEIaiABIAEoAgAoAhQRAAAgBCgCCCIBRQ0AIAEgASgCACgCDBECACAEKAIIIgVFDQAgBSAFKAIAKAIQEQEAGgsgAiAAKAIUNgIUIAIgACgCGDYCGCACIAAoAhA2AhAgAiAAKAIcNgIcIAMEQCADIAMoAgAoAhARAQAaCyACIAE2AgwgAQRAIAEgASgCACgCDBECACABIAEoAgAoAhARAQAaCyAEQRBqJAAgAgt1AQJ/QSAQACIBQagwNgIIIAFBoPoBNgIEIAFBkDA2AgAgASAAKAIMIgI2AgwgAgRAIAIgAigCACgCDBECAAsgASAAKQIQNwIQIAEgACkCGDcCGCABQYAwNgIIIAFB7C82AgQgAUHULzYCACABQaQvQQMQAQALNQEBfyAAQagwNgIIAkAgACgCDCIBRQ0AIAEgASgCACgCEBEBAEUNACAAQQA2AgwLIAAQhgMLNQEBfyAAQagwNgIEAkAgACgCCCIBRQ0AIAEgASgCACgCEBEBAEUNACAAQQA2AggLIABBBGsLOAEBfyAAQagwNgIEAkAgACgCCCIBRQ0AIAEgASgCACgCEBEBAEUNACAAQQA2AggLIABBBGsQhgMLNQEBfyAAQagwNgIAAkAgACgCBCIBRQ0AIAEgASgCACgCEBEBAEUNACAAQQA2AgQLIABBCGsLOAEBfyAAQagwNgIAAkAgACgCBCIBRQ0AIAEgASgCACgCEBEBAEUNACAAQQA2AgQLIABBCGsQhgMLBAAgAAuZAgEDfyAAQYA0NgIAAkAgACgCKEUNACAAKAIkIgEoAgAiAiAAKAIgIgMoAgQ2AgQgAygCBCACNgIAIABBADYCKCABIABBIGoiA0YNAANAIAEoAgQhAiABEIYDIAIiASADRw0ACwsCQCAAKAIcRQ0AIAAoAhgiASgCACICIAAoAhQiAygCBDYCBCADKAIEIAI2AgAgAEEANgIcIAEgAEEUaiIDRg0AA0AgASgCBCECIAEQhgMgAiIBIANHDQALCwJAIAAoAhBFDQAgACgCDCIBKAIAIgIgACgCCCIDKAIENgIEIAMoAgQgAjYCACAAQQA2AhAgASAAQQhqIgNGDQADQCABKAIEIQIgARCGAyACIgEgA0cNAAsLIAALCQAgABBGEIYDCwwAIAAgASgCBDYCBAs/AQJ/IABBhC02AgAgAEEIaiIBEA8CQCAALQBcRQ0AIAAoAlgiAkUNACACEIYDIABBADYCWAsgARAgIAAQhgMLBwAgACgCYAsRACABKAIAIAIoAggoAgAQFAspACABKAIAIgAgAigCCCgCACICEBQiAQR/IAEFIABBMGogAkEwahAUCwsrAQF/IwBBEGsiAyQAIAMgACgCWDYCCCABIAIoAhgQTiEAIANBEGokACAAC5oBAQN/IAEtAA5FBEAgARBUGgsgAS0ADCECIAEtAA1FBEAgASgCBCIDIAEoAggiASACGyIEIARBMGogASADIAIbIgEgAUEwaiAAKAIAIgAgAEEwahBVDwsgACgCAEEwaiABQQRqIgMgAUEIaiIEIAIbKAIAQTBqEBQiAkEAIAAoAgBBMGogBCADIAEtAAwbKAIAQTBqEBQgAkYbCw4AIABBBGoQICAAEIYDCwcAIAAQhgMLIAAgACABKAIINgIIIAAgAS0ADDoADCAAIAEtAA06AA0LDAAgACABKAIYNgIYC6IJAQp/IwBBIGsiBCQAAkACQCABKAIAIgMgASgCBCIFRwRAIAIoAgAiByACKAIEIgZHDQELIABCADcDECAAQQA2AgggAEIANwMADAELIARBADYCECAEQgA3AwggBCABKwMQIAIrAxCgOQMYIARBADsBBgJAIAYgB2tBAXUgBSADa0EBdWoiByAEKAIQIgMgBCgCCCIFa0EBdU0EQAJAIAQoAgwiCCAFa0EBdSIJIAcgByAJSxsiBkUNACAGQQFrIQoCQCAGQQdxIgtFBEAgBSEDDAELIAUhAwNAIAMgBC8BBjsBACAGQQFrIQYgA0ECaiEDIAxBAWoiDCALRw0ACwsgCkEHSQ0AA0AgAyAELwEGOwEAIAMgBC8BBjsBAiADIAQvAQY7AQQgAyAELwEGOwEGIAMgBC8BBjsBCCADIAQvAQY7AQogAyAELwEGOwEMIAMgBC8BBjsBDiADQRBqIQMgBkEIayIGDQALCyAHIAlLBEAgCCAHIAlrQQF0aiEDA0AgCCAELwEGOwEAIAhBAmoiCCADRw0ACyAEIAM2AgwMAgsgBCAFIAdBAXRqNgIMDAELIAUEQCAEIAU2AgwgBRCGAyAEQQA2AhAgBEIANwIIQQAhAwsCQCAHQQBIDQAgAyAHIAMgB0sbQf////8HIANB/v///wdJGyIDQQBIDQAgBCADQQF0IgMQnQYiBTYCCCAEIAMgBWo2AhAgBC8BBiEGIAUhAyAHQQdxIgkEQANAIAMgBjsBACADQQJqIQMgCEEBaiIIIAlHDQALCyAHQQF0IAVqIQUgB0EBa0H/////B3FBB08EQANAIAMgBjsBDiADIAY7AQwgAyAGOwEKIAMgBjsBCCADIAY7AQYgAyAGOwEEIAMgBjsBAiADIAY7AQAgA0EQaiIDIAVHDQALCyAEIAU2AgwMAQsQFwALAkAgASgCBCIDIAEoAgAiB0YNACADIAdrQQF1IQEgBCgCCCEFIAIoAgQiAyACKAIAIgZHBEAgAyAGa0EBdSICQQEgAkEBSxshCCABQQEgAUEBSxshCUEAIQMDQCAHIANBAXRqIQpBACEBQQAhAgNAIAUgASADakEBdGoiCyALLgEAIAJBEHRBEHVqIAYgAUEBdGouAQAgCi4BAGxqIgI7AQAgAiACQRB0QRB1a0EQdiECIAFBAWoiASAIRw0ACyAFIAMgCGpBAXRqIAI7AQAgA0EBaiIDIAlHDQALDAELIAVBACABQQEgAUEBSxtBAXQQ3gIaCwJAAkAgBCgCCCIDIAQoAgwiAkYNAANAIAJBAmsiAS8BAEUEQCAEIAE2AgwgASICIANHDQEMAgsLIAIgA0YNACADLwEABEAgAyEBDAILIAMhAQNAIAEvAQIhBSABQQJqIQEgBUUNAAsgBCAEKwMYIAEgA2tBAXUiBbegOQMYIAEgA0YEQCADIQEMAgsgAiADIAVBAXRqIgVrIQcgAyEBIAIgBUcEQCADIAUgBxDdAhogBCgCCCEBCyADIAdqIQIMAQsgAyICIQELIAAgAjYCBCAAIAE2AgAgACAEKAIQNgIIIAAgBCsDGDkDEAsgBEEgaiQAC7kZAgt/AXwjAEEgayILJAAgAC0ADkUEQCMAQZABayIEJABBBBCdBiEBIARCADcDcCAEIAE2AmAgBCABQQRqNgJoIAFBADYBACAEIAE2AmRBBBCdBiEBIARCADcDiAEgBCABQQRqNgKAASAEIAE2AnggAUEBNgEAIAQgAUECajYCfEEEEJ0GIQEgBEIANwNAIAQgATYCMCAEIAFBBGo2AjggAUEANgEAIAQgATYCNEEEEJ0GIQEgBEIANwNYIAQgAUEEajYCUCAEIAE2AkggAUEBNgEAIAQgAUECajYCTEEEEJ0GIQEgBEIANwMQIAQgATYCACAEIAFBBGo2AgggAUEANgEAIAQgATYCBEEEEJ0GIQEgBEIANwMoIAQgAUEEajYCICAEIAE2AhggAUEBNgEAIAQgAUECajYCHCAAKAIEIgYhCSAAKAIIIgEhAyAEQeAAaiEFIARBMGohByMAQcABayICJAACQAJAAkACQCAGQTBqIgogAUEwaiIBEFgEQCACQQA2ApABIAUgAkGQAWoQWSAJIAMQFEF/RgRAIAJBATYCkAEgByACQZABahBZIAJCADcDoAEgAkEANgKYASACQgA3A5ABAkAgCigCACAKKAIERgRAIAJCADcDcCACQQA2AmggAkIANwNgDAELIAJB4ABqIAJBkAFqIAoQWiACKAKQASIBRQ0AIAIgATYClAEgARCGAwsgAkGQAWogAkHgAGogCkEYahBbIQMgAigCYCIBBEAgAiABNgJkIAEQhgMLIAQoAgAiAQRAIAQgATYCBCABEIYDCyAEIAMoAgA2AgAgBCADKAIENgIEIAQgAygCCDYCCCADQQA2AgggA0IANwMAIAQgAysDEDkDEEEAIQYgBCgCGCIBBEAgBCABNgIcIAEQhgMgAygCACEGCyAEIAMoAhg2AhggBCADKAIcNgIcIAQgAygCIDYCICADQQA2AiAgA0IANwMYIAQgAysDKDkDKCAGRQ0CIAMgBjYCBCAGEIYDDAILIAMgCRBYBEAgAkEANgKQASAHIAJBkAFqIgEQWSACQQA2ApABIAQgARBZDAILIAJBfzYCkAEgByACQZABahBZIAQgCkcEQCAEIAooAgAgCigCBBBcIAQgCisDEDkDECAEQRhqIAooAhggCigCHBBcCyAEIAorAyg5AygMAQsgAyAJEFgEQCACQQA2ApABIAcgAkGQAWoQWSAKIAEQFEF/RgRAIAJBfzYCkAEgBSACQZABahBZIAQgCUcEQCAEIAkoAgAgCSgCBBBcIAQgCSsDEDkDECAEQRhqIAkoAhggCSgCHBBcCyAEIAkrAyg5AygMAgsgASAKEFgEQCACQQA2ApABIAUgAkGQAWoiARBZIAJBADYCkAEgBCABEFkMAgsgAkEBNgKQASAFIAJBkAFqEFkgAkIANwOgASACQQA2ApgBIAJCADcDkAECQCAJKAIAIAkoAgRGBEAgAkIANwNwIAJBADYCaCACQgA3A2AMAQsgAkHgAGogAkGQAWogCRBaIAIoApABIgFFDQAgAiABNgKUASABEIYDCyACQZABaiACQeAAaiAJQRhqEFshAyACKAJgIgEEQCACIAE2AmQgARCGAwsgBCgCACIBBEAgBCABNgIEIAEQhgMLIAQgAygCADYCACAEIAMoAgQ2AgQgBCADKAIINgIIIANBADYCCCADQgA3AwAgBCADKwMQOQMQQQAhBiAEKAIYIgEEQCAEIAE2AhwgARCGAyADKAIAIQYLIAQgAygCGDYCGCAEIAMoAhw2AhwgBCADKAIgNgIgIANBADYCICADQgA3AxggBCADKwMoOQMoIAZFDQEgAyAGNgIEIAYQhgMMAQsgAkGQAWogChBXIgggARBdIAUoAgAiAQRAIAUgATYCBCABEIYDCyAFIAgoAgA2AgAgBSAIKAIENgIEIAUgCCgCCDYCCCAIQQA2AgggCEIANwMAIAUgCCsDEDkDEEEAIQYgBSgCGCIBBEAgBSABNgIcIAEQhgMgCCgCACEGCyAFIAgoAhg2AhggBSAIKAIcNgIcIAUgCCgCIDYCICAIQQA2AiAgCEIANwMYIAUgCCsDKDkDKCAGBEAgCCAGNgIEIAYQhgMLIAJBkAFqIAMQVyIDIAkQXSAHKAIAIgEEQCAHIAE2AgQgARCGAwsgByADKAIANgIAIAcgAygCBDYCBCAHIAMoAgg2AgggA0EANgIIIANCADcDACAHIAMrAxA5AxBBACEGIAcoAhgiAQRAIAcgATYCHCABEIYDIAMoAgAhBgsgByADKAIYNgIYIAcgAygCHDYCHCAHIAMoAiA2AiAgA0EANgIgIANCADcDGCAHIAMrAyg5AyggBgRAIAMgBjYCBCAGEIYDCyACQgA3A6ABIAJBADYCmAEgAkIANwOQAQJAIAkoAgAgCSgCBEYEQCACQgA3A3AgAkEANgJoIAJCADcDYAwBCyACQeAAaiACQZABaiAJEFogAigCkAEiAUUNACACIAE2ApQBIAEQhgMLIAJBMGogAkHgAGogCUEYahBbIQggAigCYCIBBEAgAiABNgJkIAEQhgMLIAJB4ABqIAggBRBeIAIgCiAHEF4gAkEANgKYASACQgA3A5ABIAIoAmQiASACKAJgIgZHBEAgASAGayIDQQBIDQIgAiADEJ0GIgE2ApABIAIgASADQQF1QQF0ajYCmAEgAiABIAYgAxDcAiADajYClAELIAJBADYCsAEgAkIANwOoASACIAIrA3A5A6ABIAIoAnwiASACKAJ4IgZHBEAgASAGayIDQQBIDQMgAiADEJ0GIgE2AqgBIAIgATYCrAEgAiABIANBAXVBAXRqNgKwASACIAEgBiADENwCIANqNgKsAQsgAiACKwOIATkDuAEgAkGQAWogAhBdIAQoAgAiAQRAIAQgATYCBCABEIYDCyAEIAIoApABNgIAIAQgAigClAE2AgQgBCACKAKYATYCCCACQQA2ApgBIAJCADcDkAEgBCACKwOgATkDEEEAIQYgBCgCGCIBBEAgBCABNgIcIAEQhgMgAigCkAEhBgsgBCACKAKoATYCGCAEIAIoAqwBNgIcIAQgAigCsAE2AiAgAkEANgKwASACQgA3A6gBIAQgAisDuAE5AyggBgRAIAIgBjYClAEgBhCGAwsgAigCGCIBBEAgAiABNgIcIAEQhgMLIAIoAgAiAQRAIAIgATYCBCABEIYDCyACKAJ4IgEEQCACIAE2AnwgARCGAwsgAigCYCIBBEAgAiABNgJkIAEQhgMLIAgoAhgiAQRAIAggATYCHCABEIYDCyAIKAIAIgFFDQAgCCABNgIEIAEQhgMLIAJBwAFqJAAMAgsQFwALEBcACyMAQZABayIGJAAgBiAFEFciA0EwaiAHEFchByADQeAAaiAEEFchAUGYARCdBiIFIAMoAgA2AgAgBSADKAIENgIEIAUgAygCCDYCCCADQQA2AgggA0IANwMAIAUgAysDEDkDECAFIAMoAhg2AhggBSADKAIcNgIcIAUgAygCIDYCICADQQA2AiAgA0IANwMYIAUgAysDKDkDKCAFIAcoAgA2AjAgBSADKAI0NgI0IAUgAygCODYCOCADQgA3AjQgB0EANgIAIAVBQGsgA0FAaysDADkDACAFIAMoAkg2AkggBSADKAJMNgJMIAUgAygCUDYCUCADQQA2AlAgA0IANwNIIAUgAysDWDkDWCAFIAEoAgA2AmAgBSADKAJkNgJkIAUgAygCaDYCaCADQgA3AmQgAUEANgIAIAUgAysDcDkDcCAFIAMoAng2AnggBSADKAJ8NgJ8IAUgAygCgAE2AoABIANBADYCgAEgA0IANwN4IAMrA4gBIQwgBUEBNgKQASAFIAw5A4gBIAsgBTYCGCADKAIAIgEEQCADIAE2AgQgARCGAwsgBkGQAWokACAEKAIYIgEEQCAEIAE2AhwgARCGAwsgBCgCACIBBEAgBCABNgIEIAEQhgMLIAQoAkgiAQRAIAQgATYCTCABEIYDCyAEKAIwIgEEQCAEIAE2AjQgARCGAwsgBCgCeCIBBEAgBCABNgJ8IAEQhgMLIAQoAmAiAQRAIAQgATYCZCABEIYDCyAEQZABaiQAIAsoAhgiASABKAKQAUEBaiIENgKQAQJAIARBAUcEQCABIAEoApABIgRBAWs2ApABIARBAUcNAQsgCygCGBAWIAsoAhgQhgMLIAAoAgAhByAAIAE2AgACQCAHKAKQAUEBRwRAIAcgBygCkAEiBEEBazYCkAEgBEEBRw0BCyAHEBYgBxCGAwsgACAAEFY6AA0gAEEBOgAOCyALQSBqJAAgAAuHAwEBfyMAQaACayIGJAAgBkGQAWogAhBXIgIgABBdIAZB4ABqIAMQVyIDIAEQXSAGQTBqIAQQVyIEIAAQXSAGIAUQVyIAIAEQXSAGQfABaiIBIAIgABBeIAZBwAFqIgUgBCADEF4gASAFEBQhBSAGKALYASIBBEAgBiABNgLcASABEIYDCyAGKALAASIBBEAgBiABNgLEASABEIYDCyAGKAKIAiIBBEAgBiABNgKMAiABEIYDCyAGKALwASIBBEAgBiABNgL0ASABEIYDCyAAKAIYIgEEQCAAIAE2AhwgARCGAwsgACgCACIBBEAgACABNgIEIAEQhgMLIAQoAhgiAARAIAQgADYCHCAAEIYDCyAEKAIAIgAEQCAEIAA2AgQgABCGAwsgAygCGCIABEAgAyAANgIcIAAQhgMLIAMoAgAiAARAIAMgADYCBCAAEIYDCyACKAIYIgAEQCACIAA2AhwgABCGAwsgAigCACIABEAgAiAANgIEIAAQhgMLIAZBoAJqJAAgBQvmAQEDfyMAQeAAayICJAAgAiAAKAIAQTBqEFchAEEEEJ0GIQEgAkIANwNAIAIgATYCMCACIAFBBGo2AjggAUEANgEAIAIgATYCNEEEEJ0GIQEgAkIANwNYIAIgAUEEajYCUCACIAE2AkggAUEBNgEAIAIgAUECajYCTCAAIAJBMGoQWCEDIAIoAkgiAQRAIAIgATYCTCABEIYDCyACKAIwIgEEQCACIAE2AjQgARCGAwsgACgCGCIBBEAgACABNgIcIAEQhgMLIAAoAgAiAQRAIAAgATYCBCABEIYDCyACQeAAaiQAIAMLnQICA38BfCAAQQA2AgggAEIANwMAAkACQCABKAIEIgMgASgCACICRwRAIAMgAmsiAkEASA0BIAAgAhCdBiIDNgIAIAAgAzYCBCAAIAMgAkEBdUEBdGo2AgggACABKAIEIAEoAgAiBGsiAkEASgR/IAMgBCACENwCIAJqBSADCzYCBAsgASsDECEFIABBADYCICAAQgA3AxggACAFOQMQIAEoAhwiAyABKAIYIgJHBEAgAyACayICQQBIDQIgACACEJ0GIgM2AhggACADNgIcIAAgAyACQQF1QQF0ajYCICAAIAEoAhwgASgCGCIEayICQQBKBH8gAyAEIAIQ3AIgAmoFIAMLNgIcCyAAIAErAyg5AyggAA8LEBcACxAXAAvAAQEFfyMAQTBrIgIkACACQRhqIAAgAUEYahBTIAIgAEEYaiABEFMCQCACKAIcIgUgAigCGCIDayACKAIEIAIoAgAiBGtHDQAgAyAFRgRAQQEhBgwBCyAEIQEgAyEAA0AgAC8BACABLwEARw0BIAFBAmohASAAQQJqIgAgBUcNAAsgAisDKCACKwMQYSEGCyAEBEAgAiAENgIEIAQQhgMgAigCGCEDCyADBEAgAiADNgIcIAMQhgMLIAJBMGokACAGC6oCAgR/AXwgASgCACEBQQQQnQYiAiABOwEAIAIgASABQRB0QRB1a0EQdiIDOwECIAJBBGohBAJ/IAJBAmogAiABQf//A3EbIANFDQAaIAQgAUH//wNxDQAaIAIhAQNAIAEvAQIhAyABQQJqIQEgA0UNAAsgASACayIDQQF1IgW3IQYgBCABIAJGDQAaQQQgA2shASACIAVBAXRqIgMgBEcEQCACIAMgARDdAhoLIAEgAmoLIQMgACgCACIBBEAgACABNgIEIAEQhgMLIAAgBjkDECAAIAQ2AgggACADNgIEIAAgAjYCAEEEEJ0GIgFBATYBACAAKAIYIgIEQCAAIAI2AhwgAhCGAwsgACABNgIYIABCADcDKCAAIAFBBGo2AiAgACABQQJqNgIcC5YHAgd/CHwCQCABKAIAIgQgASgCBCIDRgRAIAIrAxAiCyACKAIEIAIoAgBrQQF1uKAhCgwBCyACKwMQIgsgAigCBCACKAIAa0EBdbigIgogASsDECIMIAMgBGtBAXW4oCINIAogDWQbIQogCyAMIAsgDGMbIQsLIAAgCzkDECAAQQA2AgggAEIANwMAAkACfyAKIAuhIgxEAAAAAAAA8D+gIgqZRAAAAAAAAOBBYwRAIAqqDAELQYCAgIB4CyIDIAAiBCgCCCIGIAAoAgQiAGtBAXVNBEAgBCADBH8gAEEAIANBAXQiABDeAiAAagUgAAs2AgQMAQsCQCAAIAQoAgAiB2siCEEBdSIJIANqIgVBAE4EQEEAIQAgBiAHayIGIAUgBSAGSRtB/////wcgBkH+////B0kbIgUEQCAFQQBIDQIgBUEBdBCdBiEACyAAIAlBAXRqQQAgA0EBdCIDEN4CIANqIQMgCEEASgRAIAAgByAIENwCGgsgBCAAIAVBAXRqNgIIIAQgAzYCBCAEIAA2AgAgBwRAIAcQhgMLDAILEBcACxAYAAsgBCgCACIAQQA7AQBEAAAAAAAAAAAhCiAMRAAAAAAAAAAAZARAIAIrAxAiDSACKAIEIAIoAgAiA2tBAXW4oCEPIAErAxAiDiABKAIEIAEoAgAiB2tBAXW4oCEQQQAhAUEAIQIDQCABQRB0QRB1IQUgAkEBdCAAaiEIAn9BACAOIAsgCqAiCmQNABpBACAKIBBmDQAaIAcCfyAKIA6hIhGZRAAAAAAAAOBBYwRAIBGqDAELQYCAgIB4C0EBdGovAQALQRB0QRB1IQZBACEBAkAgCiANYw0AIAogD2YNACADAn8gCiANoSIKmUQAAAAAAADgQWMEQCAKqgwBC0GAgICAeAtBAXRqLwEAIQELIAggBiABQRB0QRB1ayAFaiIBOwEAIAAgAkEBaiICQQF0aiABIAFBEHRBEHVrQRB2IgE7AQAgDCACtyIKZA0ACwsCQCAAIAQoAgQiAUYNAANAIAFBAmsiAi8BAEUEQCAEIAI2AgQgAiIBIABHDQEMAgsLIAAgAUYNACAALwEADQAgACECA0AgAi8BAiEDIAJBAmohAiADRQ0ACyAEIAQrAxAgAiAAa0EBdSIDt6A5AxAgACACRg0AIAEgACADQQF0aiICayEDIAEgAkcEQCAAIAIgAxDdAhoLIAQgACADajYCBAsLnQICA38BfCAAQQA2AgggAEIANwMAAkACQCABKAIEIgMgASgCACIERwRAIAMgBGsiBEEASA0BIAAgBBCdBiIDNgIAIAAgAzYCBCAAIAMgBEEBdUEBdGo2AgggACABKAIEIAEoAgAiBWsiBEEASgR/IAMgBSAEENwCIARqBSADCzYCBAsgASsDECEGIABBADYCICAAQgA3AxggACAGOQMQIAIoAgQiASACKAIAIgNHBEAgASADayIDQQBIDQIgACADEJ0GIgE2AhggACABNgIcIAAgASADQQF1QQF0ajYCICAAIAIoAgQgAigCACIEayIDQQBKBH8gASAEIAMQ3AIgA2oFIAELNgIcCyAAIAIrAxA5AyggAA8LEBcACxAXAAulAgEFfyACIAFrIgVBAXUiBiAAKAIIIgQgACgCACIDa0EBdU0EQCABIAAoAgQgA2siBGogAiAGIARBAXUiB0sbIgQgAWshBSABIARHBEAgAyABIAUQ3QIaCyAGIAdLBEAgACgCBCEBIAAgAiAEayIAQQBKBH8gASAEIAAQ3AIgAGoFIAELNgIEDwsgACADIAVqNgIEDwsgAwRAIAAgAzYCBCADEIYDIABBADYCCCAAQgA3AgBBACEECwJAIAVBAEgNACAEIAYgBCAGSxtB/////wcgBEH+////B0kbIgNBAEgNACAAIANBAXQiBhCdBiIDNgIAIAAgAzYCBCAAIAMgBmo2AgggACABIAJHBH8gAyABIAUQ3AIgBWoFIAMLNgIEDwsQFwALkgMCBX8BfCMAQdAAayICJAAgAkEYaiAAIAFBGGoiBhBTIAIgASAAQRhqIgMQUwJAAkAgAigCACACKAIERgRAIAJBADYCQCACQgA3AzggAigCHCIBIAIoAhgiBEcEQCABIARrIgFBAEgNAyACIAEQnQYiBTYCOCACIAUgAUEBdUEBdGo2AkAgAiAFIAQgARDcAiABajYCPAsgAiACKwMoOQNIDAELIAJBOGogAkEYaiACEFoLIAAoAgAiAQRAIAAgATYCBCABEIYDCyAAIAIoAjg2AgAgACACKAI8NgIEIAAgAigCQDYCCCACQQA2AkAgAkIANwM4IAAgAisDSDkDECACKAIAIgEEQCACIAE2AgQgARCGAwsgAigCGCIBBEAgAiABNgIcIAEQhgMLIAJBOGogAyAGEFMgAygCACIBBEAgACABNgIcIAEQhgMLIAAgAigCODYCGCAAIAIoAjw2AhwgACACKAJANgIgIAIrA0ghByAAQgA3AyggACAAKwMQIAehOQMQIAJB0ABqJAAPCxAXAAvFAQIBfwF8IwBBIGsiAyQAIANBCGogACABEFciACACEFMgACgCACIBBEAgACABNgIEIAEQhgMLIAAgAygCCDYCACAAIAMoAgw2AgQgACADKAIQNgIIIAAgAysDGDkDECADQQhqIABBGGogAkEYahBTIAAoAhgiAQRAIAAgATYCHCABEIYDCyAAIAMoAgg2AhggACADKAIMNgIcIAAgAygCEDYCICADKwMYIQQgAEIANwMoIAAgACsDECAEoTkDECADQSBqJAALzQIBBH8gACgCHCIBKAIcIgIgAUcEQANAAkAgAigCFCIDQQFxRQ0AIANBfnEiBCgCEEECRw0AIARBCGohAQNAIAEoAgAiA0EIaiEBIAMoAhBBAkYNAAsgBCADNgIIIARBAjYCECACIANBAXI2AhQgACgCHCEBCyACKAIcIgIgAUcNAAsLIABBQGsoAgAiAigCACIBIAJHBEADQCABKAIAIQMgASgCEEECRgRAIAEoAgQiBCADNgIAIAEoAgAgBDYCBCAAIAAoAkRBAWs2AkRBsMYCLQAARQRAQfjEAkIANwIAQbDGAkEBOgAAQaTFAkIgNwIAQZzFAkKUgICAgAQ3AgBBgMUCQgA3AgBBiMUCQgA3AgBBkMUCQgA3AgBBmMUCQQA2AgALIAFBkMUCKAIANgIAQZDFAiABNgIAIAAoAkAhAgsgAyIBIAJHDQALCwu3AwEFfyAAQaTQADYCACAAQZgDahAVGiAAQZQDahAVGgJAIAAoApADIgEoApABQQFHBEAgASABKAKQASIBQQFrNgKQASABQQFHDQELIAAoApADEBYgACgCkAMQhgMLIABBiANqEBUaIABBhANqEBUaAkAgACgCgAMiASgCkAFBAUcEQCABIAEoApABIgFBAWs2ApABIAFBAUcNAQsgACgCgAMQFiAAKAKAAxCGAwsgACgC9AIEQCAAKAL4AiIBIAAoAvQCIgRHBEADQCABIgJBEGshAwJAIAFBFGsiASgCACIFQR91IAVGBEAgAxAVGgwBCyACQQhrEBUaIAJBDGsQFRogAygCACICKAKQAUEBRwRAIAIgAigCkAEiAkEBazYCkAEgAkEBRw0BCyADKAIAEBYgAygCABCGAwsgASAERw0ACwsgACAENgL4AiAAKAL0AhCGAwsCQCAAKALwAkUNACAAKALsAiIBKAIAIgIgACgC6AIiAygCBDYCBCADKAIEIAI2AgAgAEEANgLwAiABIABB6AJqIgNGDQADQCABKAIEIQIgARCGAyACIgEgA0cNAAsLIAAQZQumAQEDfyAAQbjCADYCACAAQZgBahBmIAAoAngiAQRAIAEQhgMLIAAoAmQQhgMgACgCOCIBBEAgACABNgI8IAEQhgMLIABBrMsANgIIAkAgACgCJEUNACAAKAIgIgIoAgAiAyAAKAIcIgEoAgQ2AgQgASgCBCADNgIAIABBADYCJCACIABBHGoiA0YNAANAIAIoAgQhASACEIYDIAEiAiADRw0ACwsgAAu4AwEFfyAAQcT+ADYCACAAQcQDahAVGiAAQcADahAVGgJAIAAoArwDIgEoApABQQFHBEAgASABKAKQASIBQQFrNgKQASABQQFHDQELIAAoArwDEBYgACgCvAMQhgMLIABBpANqEBUaIABBoANqEBUaAkAgACgCnAMiASgCkAFBAUcEQCABIAEoApABIgFBAWs2ApABIAFBAUcNAQsgACgCnAMQFiAAKAKcAxCGAwsgACgCkAMEQCAAKAKUAyIBIAAoApADIgRHBEADQCABIgJBIGshAwJAIAFBJGsiASgCACIFQR91IAVGBEAgAxAVGgwBCyACQRhrEBUaIAJBHGsQFRogAygCACICKAKQAUEBRwRAIAIgAigC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C0EwaiANQTBqEBQLQX9HDQELIAMoAhBBfnEhCiADKAIYIQYgAyEFIAchCQsgCCgCBCIIIARHDQALCwJAIAUEfyAAIAVGDQEgBSgCDAUgAgsoAhghAQsgBhBUIAEQVBCEASEAIAxBEGokACAAQQFGC/oBAQN/IwBBEGsiAyQAQbDGAi0AAEUEQEH4xAJCADcCAEGwxgJBAToAAEGkxQJCIDcCAEGcxQJClICAgIAENwIAQYDFAkIANwIAQYjFAkIANwIAQZDFAkIANwIAQZjFAkEANgIACwJAQZDFAigCACIBBEBBkMUCIAEoAgA2AgAMAQtBkMUCEDoiAQ0AIANBCGoiAEHI+gE2AgAgAEGg+gE2AgAgABA7AAsgAUIANwIAIAFBADoAECABQgA3AgggASAAKAIoIgI2AgAgASACKAIENgIEIAIoAgQgATYCACACIAE2AgQgACAAKAIsQQFqNgIsIANBEGokACABC9QNAQl/IwBBwAFrIggkACAIQZABaiAAKAIAEFchBSAIQeAAaiAAKAIAQTBqEFchBCAIQTBqIAEoAgAQVyEGIAggASgCAEEwahBXIQMjAEHQAWsiACQAQQQQnQYhASAAQgA3A6gBIAAgATYCmAEgACABQQRqNgKgASABQQA2AQAgACABNgKcAUEEEJ0GIQEgAEIANwPAASAAIAFBBGo2ArgBIAAgATYCsAEgAUEBNgEAIAAgAUECajYCtAEgBSAAQZgBahBYIQIgACgCsAEiAQRAIAAgATYCtAEgARCGAwsgACgCmAEiAQRAIAAgATYCnAEgARCGAwsCQCACBEBBBBCdBiEBIABCADcDqAEgACABNgKYASAAIAFBBGo2AqABIAFBADYBACAAIAE2ApwBQQQQnQYhASAAQgA3A8ABIAAgAUEEajYCuAEgACABNgKwASABQQE2AQAgACABQQJqNgK0ASADIABBmAFqEFghAiAAKAKwASIBBEAgACABNgK0ASABEIYDCyAAKAKYASIBBEAgACABNgKcASABEIYDC0F/IQEgAg0BIABBmAFqIgEgBhCFASABIAMQhQFsIQEMAQtBBBCdBiEBIABCADcDqAEgACABNgKYASAAIAFBBGo2AqABIAFBADYBACAAIAE2ApwBQQQQnQYhASAAQgA3A8ABIAAgAUEEajYCuAEgACABNgKwASABQQE2AQAgACABQQJqNgK0ASAGIABBmAFqEFghAiAAKAKwASIBBEAgACABNgK0ASABEIYDCyAAKAKYASIBBEAgACABNgKcASABEIYDCyACBEBBBBCdBiEBIABCADcDqAEgACABNgKYASAAIAFBBGo2AqABIAFBADYBACAAIAE2ApwBQQQQnQYhASAAQgA3A8ABIAAgAUEEajYCuAEgACABNgKwASABQQE2AQAgACABQQJqNgK0ASAEIABBmAFqEFghAiAAKAKwASIBBEAgACABNgK0ASABEIYDCyAAKAKYASIBBEAgACABNgKcASABEIYDC0EBIQEgAg0BQQAgAEGYAWoiASAFEIUBIAEgBBCFAWxrIQEMAQtBBBCdBiEBIABCADcDqAEgACABNgKYASAAIAFBBGo2AqABIAFBADYBACAAIAE2ApwBQQQQnQYhASAAQgA3A8ABIAAgAUEEajYCuAEgACABNgKwASABQQE2AQAgACABQQJqNgK0ASAEIABBmAFqEFghAiAAKAKwASIBBEAgACABNgK0ASABEIYDCyAAKAKYASIBBEAgACABNgKcASABEIYDCyACBEBBBBCdBiEBIABCADcDqAEgACABNgKYASAAIAFBBGo2AqABIAFBADYBACAAIAE2ApwBQQQQnQYhASAAQgA3A8ABIAAgAUEEajYCuAEgACABNgKwASABQQE2AQAgACABQQJqNgK0ASADIABBmAFqEFghAiAAKAKwASIBBEAgACABNgK0ASABEIYDCyAAKAKYASIBBEAgACABNgKcASABEIYDCyACQQFzIQEMAQtBBBCdBiEBIABCADcDqAEgACABNgKYASAAIAFBBGo2AqABIAFBADYBACAAIAE2ApwBQQQQnQYhASAAQgA3A8ABIAAgAUEEajYCuAEgACABNgKwASABQQE2AQAgACABQQJqNgK0ASADIABBmAFqEFghAiAAKAKwASIBBEAgACABNgK0ASABEIYDCyAAKAKYASIBBEAgACABNgKcASABEIYDC0F/IQEgAg0AQQAgAEGYAWoiAiAFEIUBIAIgBBCFAWxrIgdBACACIAYQhQEgAiADEIUBbGsiAkgNAEEBIQEgAiAHSA0AIAdBAEoEQCAAQegAaiIHIAUgAxBeIABBmAFqIgkgAEE4aiICIAcQhgEgAEEIaiIKIAYgBBBeIAIgAEHIAWogChCGASAJIAIQFCEBIAIQIiAKECIgCRAiIAcQIgwBCyAAQegAaiIHIAYgBBBeIABBmAFqIgkgAEE4aiICIAcQhgEgAEEIaiIKIAUgAxBeIAIgAEHIAWogChCGASAJIAIQFCEBIAIQIiAKECIgCRAiIAcQIgsgAEHQAWokACADKAIYIgAEQCADIAA2AhwgABCGAwsgAygCACIABEAgAyAANgIEIAAQhgMLIAYoAhgiAARAIAYgADYCHCAAEIYDCyAGKAIAIgAEQCAGIAA2AgQgABCGAwsgBCgCGCIABEAgBCAANgIcIAAQhgMLIAQoAgAiAARAIAQgADYCBCAAEIYDCyAFKAIYIgAEQCAFIAA2AhwgABCGAwsgBSgCACIABEAgBSAANgIEIAAQhgMLIAhBwAFqJAAgAQvLAgECfyMAQTBrIgAkAEEEEJ0GIQIgAEIANwMQIAAgAjYCACAAIAJBBGo2AgggAkEANgEAIAAgAjYCBEEEEJ0GIQIgAEIANwMoIAAgAkEEajYCICAAIAI2AhggAkEBNgEAIAAgAkECajYCHCABIAAQFCEDIAAoAhgiAgRAIAAgAjYCHCACEIYDCyAAKAIAIgIEQCAAIAI2AgQgAhCGAwtBfyECIANBf0cEQEEEEJ0GIQIgAEIANwMQIAAgAjYCACAAIAJBBGo2AgggAkEANgEAIAAgAjYCBEEEEJ0GIQIgAEIANwMoIAAgAkEEajYCICAAIAI2AhggAkEBNgEAIAAgAkECajYCHCAAIAEQFCECIAAoAhgiAQRAIAAgATYCHCABEIYDCyAAKAIAIgEEQCAAIAE2AgQgARCGAwsgAkF/RiECCyAAQTBqJAAgAgvBAgEBfyMAQfAAayIBJABBBBCdBiEDIAFCADcDGCABIAM2AgggASADQQRqNgIQIANBADYBACABIAM2AgxBBBCdBiEDIAFCADcDMCABIANBBGo2AiggASADNgIgIANBATYBACABIANBAmo2AiQCQCACIAFBCGoQFEF/RgRAIAFCADcDYCABQQA2AlggAUIANwNQAkAgAigCACACKAIERgRAIAFCADcDSCABQQA2AkAgAUIANwM4DAELIAFBOGogAUHQAGogAhBaIAEoAlAiA0UNACABIAM2AlQgAxCGAwsgACABQThqIAJBGGoQWxogASgCOCIARQ0BIAEgADYCPCAAEIYDDAELIAAgAhBXGgsgASgCICIABEAgASAANgIkIAAQhgMLIAEoAggiAARAIAEgADYCDCAAEIYDCyABQfAAaiQAC9kCAQV/IAAoAiAiBCABKAIAIgMgACgCMHEiAUEUbGohAiAAQQRqIQYgACgCNARAIAYQfQsgAyACKAIAIgVGBEAgACADNgJIIAQgAUEUbGpBBGoPCwJAIAUgBigCACIFRgRAIAIgAzYCACAEIAFBFGxqIgEgACkCEDcCBCABIAAoAhg2AgwMAQsgAEEMaiIEIAM2AgAgAiEBA0AgASgCECIBKAIAIANHDQALIAEgBEcEQAwBCyAAKAIoIAAoAiRGBEAgBhB+IAAoAgQhBSAAKAIgIAAoAjAgA3FBFGxqIQILIAUgAigCAEYEQCACIAM2AgAgAiAAKQIQNwIEIAIgACgCGDYCDCACQQRqDwsgACAAKAIoIgFBFGo2AiggASADNgIAIAEgACkCEDcCBCABIAAoAhg2AgwgASACKAIQNgIQIAIgATYCECABQQRqDwsgACADNgJIIAFBBGoLzgIBAn9B6AAQnQZBAEHgABDeAiEBQQQQnQYhAiABQgA3AxAgASACNgIAIAEgAkEEajYCCCACQQA2AQAgAUEANgIgIAFCADcDGCABIAI2AgRBBBCdBiECIAFCADcDKCABIAI2AhggASACQQRqNgIgIAJBATYBACABQQA2AjggAUIANwMwIAEgAkECajYCHEEEEJ0GIQIgAUFAa0IANwMAIAEgAjYCMCABIAJBBGo2AjggAkEANgEAIAFBADYCUCABQgA3A0ggASACNgI0QQQQnQYhAiABQgA3A1ggASACNgJIIAEgAkEEajYCUCACQQE2AQAgAUEBNgJgIAEgAkECajYCTCAAQQA2AiAgAEKAgICAgICBggE3AhggACAAQRBqIgI2AhQgACACNgIQIABBADYCDCAAIABBBGoiAjYCCCAAIAI2AgQgACABNgIAIAALCQAgABBgEIYDC7MCAQJ/IAAoAuACIgEEQCAAAn8jAEEQayICJABBxMYCLQAAIQACQCABQQFGBEAgAEUEQEG0xQJCADcCAEHExgJBAToAAEHgxQJCIDcCAEHYxQJC4ICAgIAENwIAQbzFAkIANwIAQcTFAkIANwIAQczFAkIANwIAQdTFAkEANgIAC0HMxQIoAgAiAARAQczFAiAAKAIANgIADAILQczFAhA6IQAMAQsgAEUEQEG0xQJCADcCAEHExgJBAToAAEHgxQJCIDcCAEHYxQJC4ICAgIAENwIAQbzFAkIANwIAQcTFAkIANwIAQczFAkIANwIAQdTFAkEANgIAC0HMxQIgARA9IQALIABFBEAgAkEIaiIAQcj6ATYCACAAQaD6ATYCACAAEDsACyACQRBqJAAgAAs2AiwLC/IDAQZ/AkAgACgC4AJFDQADQAJAIAAoAiwgA0HgAGxqIgIoAlxFDQAgAigCWCIBKAIAIgQgAigCVCIFKAIENgIEIAUoAgQgBDYCACACQQA2AlwgASACQdQAaiIFRg0AA0AgASgCBCEEIAEQhgMgBCIBIAVHDQALCyACEIwBIANBAWoiAyAAKALgAiIBSQ0ACyABRQ0AIAAoAiwgARCNAQsgACgC7AIiAyAAQegCaiIFRwRAA0ACQCADKAIIIgIoAlxFDQAgAigCWCIBKAIAIgQgAigCVCIGKAIENgIEIAYoAgQgBDYCACACQQA2AlwgASACQdQAaiIGRg0AA0AgASgCBCEEIAEQhgMgBCIBIAZHDQALCyACEIwBIAMoAgghAUHExgItAABFBEBBtMUCQgA3AgBBxMYCQQE6AABB4MUCQiA3AgBB2MUCQuCAgICABDcCAEG8xQJCADcCAEHExQJCADcCAEHMxQJCADcCAEHUxQJBADYCAAsgAUHMxQIoAgA2AgBBzMUCIAE2AgAgAygCBCIDIAVHDQALCwJAIAAoAvACRQ0AIAAoAuwCIgEoAgAiBCAAKALoAiIDKAIENgIEIAMoAgQgBDYCACAAQQA2AvACIAEgBUYNAANAIAEoAgQhACABEIYDIAAiASAFRw0ACwsLngEBA38gACgCRCECIABBADYCRCACBEAgAigCCCIBBEADQCABKAIAIQMgARCGAyADIgENAAsLIAIoAgAhASACQQA2AgAgAQRAIAEQhgMLIAIQhgMLIABBFGoQFRogAEEQahAVGgJAIAAoAgwiASgCkAFBAUcEQCABIAEoApABIgFBAWs2ApABIAFBAUcNAQsgACgCDBAWIAAoAgwQhgMLC/oCAQN/QcTGAi0AACECAkACQAJAIAFBAUYEQCACRQRAQbTFAkIANwIAQcTGAkEBOgAAQeDFAkIgNwIAQdjFAkLggICAgAQ3AgBBvMUCQgA3AgBBxMUCQgA3AgBBzMUCQgA3AgBB1MUCQQA2AgALQczFAigCACEBDAELIAJFBEBBtMUCQgA3AgBBxMYCQQE6AABB4MUCQiA3AgBB2MUCQuCAgICABDcCAEG8xQJCADcCAEHExQJCADcCAEHMxQJCADcCAEHUxQJBADYCAAsgAUHYxQIoAgAiAmwiA0EEIAJBBCACQQRLGyIBQQNxIgJrQQAgAhsgAWoiAW4iAiADIAEgAmxHaiICRQ0CIAAgASACbCABayIDIAMgAXAiBGtqIgJBzMUCKAIANgIAIAMgBEYNASAAIAIgAWsiA0YEQCACIQEMAQtBACABayEEA0AgAyIBIAI2AgAgASECIAEgBGoiAyAARw0ACwsgACABNgIAC0HMxQIgADYCAAsLqxEBEH8jAEEgayIKJAAjAEEgayIHJAAgACgCDCIDKAIkIgIgAygCKCIBRwRAIAdCADcCDCAHIAdBCGpBBHIiCTYCCCABIAJrQQN1IgFBASABQQFLGyEPAkACQANAIAMoAiQiBiAIQQN0IgxqKAIAIQUgCSIEIQICQAJAIAcoAgwiAUUNAANAIAEiAigCECIBIAVLBEAgAiEEIAIoAgAiAQ0BDAILIAEgBU8EQCACIQEMAwsgAigCBCIBDQALIAJBBGohBAtBIBCdBiIBIAU2AhAgASACNgIIIAFCADcCACABQQA2AhwgAUIANwIUIAQgATYCACABIQIgBygCCCgCACIFBEAgByAFNgIIIAQoAgAhAgsgBygCDCACELoBIAcgBygCEEEBajYCECADKAIkIQYLIAYgDGohDAJAAkAgASgCGCICIAEoAhxHBEAgAiAMKAIENgIAIAEgAkEEajYCGAwBCyACIAEoAhQiDmsiDUECdSIEQQFqIgVBgICAgARPDQEgDUEBdSICIAUgAiAFSxtB/////wMgDUH8////B0kbIgYEfyAGQYCAgIAETw0EIAZBAnQQnQYFQQALIgUgBEECdGoiAiAMKAIENgIAIA1BAEoEQCAFIA4gDRDcAhoLIAEgBSAGQQJ0ajYCHCABIAJBBGo2AhggASAFNgIUIA5FDQAgDhCGAwsgCEEBaiIIIA9GDQMMAQsLEBcACxAYAAsgCSAHKAIIIgJHBEADQCACKAIYIgEgAigCFCIIayIGQQVPBEAgCCABIAdBGGoQmAMgAigCFCIIIQMCQCAIIgEgAigCGCIERwRAA0AgAyIBQQRqIgMgBEYNAiABKAIAIAEoAgRHDQALCyABIARGDQAgBCABQQhqIgNHBEAgASgCACEGA0AgBiADKAIAIgZHBEAgASAGNgIEIAFBBGohAQsgA0EEaiIDIARHDQALIAIoAhQhCCACKAIYIQQLIAFBBGoiBSAERg0AIAQgBSAEIAVraiIDayEBIAMgBEcEQCAFIAMgARDdAhogAigCFCEICyACIAEgBWoiBDYCGAsgBCAIayEGCyAAIAgoAgAQuwECQCAGQQRGBEAgACACKAIUKAIAIAIoAhAgACgCDBCWAQwBCwJAIAAoAgwiBCgCFCIBIARBEGoiBEYNACACKAIQIQMDQCABKAIIIAMQvAEEQCABIQQMAgsgAyABKAIIELwBBEAgASEEDAILIAMgASgCCBCyAQRAIAEhBAwCCyABKAIEIgEgBEcNAAsLIAZFDQAgBCgCBCEDIAZBAnUiAUEBIAFBAUsbIQRBACEBA0AgACACKAIUIAFBAnRqKAIAIAMoAgAoAgggACgCDBCWASABQQFqIgEgBEcNAAsLAkAgAigCBCIDBEADQCADIgEoAgAiAw0ADAILAAsDQCACKAIIIgEoAgAgAkchBCABIQIgBA0ACwsgCSABIgJHDQALCyAHQQhqIAcoAgwQvQEgACgCDCEDCyADKAIUIgIgA0EQakcEQANAIAAgAigCCBC7ASACKAIEIgIgACgCDEEQakcNAAsLIAdBIGokACAAQQA6AKQBAkACQAJAIAAoAgwiASgCDA0AAkAgAEEwaiABIABBEGogCkEPahCPASICBEAgAi0ABEECSQ0BCyAAIABB4ABqNgKgAQwCCyAAIAotAA8iAToApAEgACACNgKgASABRQ0CIAIoAgAhBCAAKAIMIgMoAhhFBEBBASELIAMtABwiAUEIcQ0CIAMgAUEgcjoAHCADIAQQkAEgACgCDCEDQQwQnQYiAiADQRBqNgIEIAIgBDYCCCACIAMoAhAiATYCACABIAI2AgQgAyACNgIQIAMgAygCGEEBajYCGAwBC0EMEJ0GIgIgA0EEajYCBCACIAQ2AgggAiADKAIEIgE2AgAgASACNgIEIAMgAjYCBCADIAMoAgxBAWo2AgwgAyADLQAcQSByOgAcIAAgAyAEIAAoAgAoAhgRBAAaCyAAEJEBIAAoAgwiAigCCCILIAJBBGpGDQEgAEGQA2ohCCAAQYADaiEFA0ACQCACIAsoAggiAygCCEYEQCAAKALkAiADQQxqIAMQkgFBASEQDAELIAogACgCBDYCCCADQQxqIAIgBSAIEJMBIAAoAuQCIAUgAxCSASAAKAKQAyIBIAEoApABQQFqNgKQASADKAIMIQIgAyABNgIMAkAgAigCkAFBAUcEQCACIAIoApABIgFBAWs2ApABIAFBAUcNAQsgAhAWIAIQhgMLIAAoApQDIgIgAigCYEEBajYCYCADKAIQIQEgAyACNgIQIAogATYCECAKQRBqEBUaIAAoApgDIgIgAigCYEEBajYCYCADKAIUIQEgAyACNgIUIAogATYCGCAKQRhqEBUaIAMgACgCnAM2AhgLIAsoAgQhCyAAIAMoAgAiBDYCoAECQCAEKAIMIgFFBEAgBCEBA0AgASgCCCICRQRAQQAhAgwDCyABIAIoAgxGIQkgAiEBIAkNAAsMAQsDQCABIgIoAhAiAQ0ACwsgACACNgKgASADIABB4ABqIgM2AgACQCAQRQ0AAkAgACgCcCIBRQRAIAMhAQNAIAEoAggiAkUEQEEAIQIMAwsgASACKAIQRiEJIAIhASAJDQALDAELA0AgASICKAIMIgENAAsLIAQgACgCVCIBIAMgARtGDQAgAiAERg0AAkAgBCgCECIBRQRAIAQhAQNAIAEoAggiA0UEQEEAIQMMAwsgASADKAIQRiECIAMhASACDQALDAELA0AgASIDKAIMIgENAAsLAkAgBCgCDCICRQRAIAQhAgNAIAIgAigCCCIBKAIMRiEJIAEhAiAJDQALDAELA0AgAiIBKAIQIgINAAsLIAAgAygCACABKAIAQQAQlgELIABBMGogBBCgASALIAAoAgwiAkEEakcNAAsMAQsgACALOgCkAQsgCkEgaiQAC78DAQN/IwBBIGsiBiQAIANBADoAAAJAIAAoAgQiBUUNAAJAAkAgBS0ABEECTwRAIAUhAAwBCwNAIAUiACgCACEEIAYgAigCADYCCAJ/AkACQCABIARBDGoQTiIEQQFqDgIABQELIABBEGoMAQsgAEEMagsoAgAiBQRAIAUtAARBAU0NAQsLIARBf0YhBAsgBARAIAAhBAwCCyAAKAIMIgUEQANAIAUiBCgCECIFDQAMAwsACwNAIAAoAggiBEUEQEEAIQQMAwsgACAEKAIMRiEBIAQhACABDQALDAELIANBAToAAAJAIAAoAhAiBEUEQCAAIQQDQCAEKAIIIgVFBEAgACEEDAQLIAQgBSgCEEYhAyAFIQQgAw0ACwwBCwNAIAQiBSgCDCIEDQALCyAFLQAEQQFLBEAgACEEDAELIAAhBANAIAUiAygCACEAIAYgAigCADYCECABIABBDGoQTg0BAkAgAyIAKAIQIgQEQANAIAQiBSgCDCIEDQAMAgsACwNAIAAoAggiBUUEQCADIQQMBAsgACAFKAIQRiEEIAUhACAEDQALCyADIQQgBS0ABEECSQ0ACwsgBkEgaiQAIAQLugQBCn8jAEEQayIFJAAgBUEANgIIIAVCADcDAAJAAkACQAJAAkAgACgCCCIDIABBBGoiC0YEQEEAIQMMAQsDQCADKAIIIgIgAUYNAiACIAEQsQENAgJAIAEgAygCCBCyAUUNACABELMBIQggAygCCBCzASECIAMoAgghBCACIAhJBEAgASAEEJgBRQ0BIAYEQCAFKAIIIAdHBEAgByADNgIAIAUgB0EEaiIHNgIEQQEhBgwDCyAHIAUoAgAiCmsiCUECdSIIQQFqIgRBgICAgARPDQcgCUEBdSICIAQgAiAESxtB/////wMgCUH8////B0kbIgYEfyAGQYCAgIAETw0JIAZBAnQQnQYFQQALIgQgCEECdGoiAiADNgIAIAJBBGohByAJQQBKBEAgBCAKIAkQ3AIaCyAFIAQgBkECdGo2AgggBSAHNgIEIAUgBDYCAEEBIQYgCkUNAiAKEIYDDAILIAMgATYCCEEBIQYMAQsgBCABEJgBDQMLIAMoAgQiAyALRw0ACyAHIAUoAgAiA0cEQCADIQIDQCACKAIAIgQoAgAiCCAEKAIENgIEIAQoAgQgCDYCACAAIAAoAgxBAWs2AgwgBBCGAyACQQRqIgIgB0cNAAsLIAYNAgtBDBCdBiICIAs2AgQgAiABNgIIIAIgACgCBCIBNgIAIAEgAjYCBCAAIAI2AgQgACAAKAIMQQFqNgIMDAELIAUoAgAhAwsgAwRAIAMQhgMLIAVBEGokAA8LEBcACxAYAAuyCwEIfwJAAkACQCAAKAIMIgcoAggiBCgCCCgCACIBKAIMIgJFBEAgASECA0AgAigCCCIFRQRAIABB4ABqIQZBACEFDAQLIAIgBSgCDEYhAyAFIQIgAw0ACwwBCwNAIAIiBSgCECICDQALCyAFIABB4ABqIgZGDQELIAdBBGohCANAIAQhAgJAIAQgCEYNACAFKAIAIQMDQCACKAIIIANGDQEgAigCBCICIAhHDQALDAILIAIgCEYNAQJAIAUiAygCDCICBEADQCACIgUoAhAiAg0ADAILAAsDQCADKAIIIgVFBEBBACEFDAILIAMgBSgCDEYhAiAFIQMgAg0ACwsgBSAGRw0ACyAGIQULAkACQCAAKAJUIgAgBiAAGyICIAFGBEAgB0EEaiEGIAEgBUYNAQNAIAQgASgCADYCCAJAIAEiAygCDCICBEADQCACIgEoAhAiAg0ADAILAAsDQCADKAIIIgFFBEBBACEBDAILIAMgASgCDEYhACABIQMgAA0ACwsgBCgCBCEEIAEgBUcNAAsMAQsCQAJAAkACQCABKAIQIgAEQANAIAAiAygCDCIADQAMAgsACwNAIAEoAggiA0UEQEEAIQMMAwsgASADKAIQRiEAIAMhASAADQALCyACIANGDQELIAdBBGohBgNAAkACQAJAIAYgBCIBRg0AIAMoAgAhAANAIAEoAgggAEYNASABKAIEIgEgBkcNAAsMAQsgASAGRw0BCwJAIAMoAgwiAgRAA0AgAiIBKAIQIgINAAwCCwALA0AgAygCCCIBRQRAQQAhAQwCCyADIAEoAgxGIQAgASEDIAANAAsLIAEgBUYNAwNAIAQgASgCADYCCAJAIAEiAygCDCICBEADQCACIgEoAhAiAg0ADAILAAsDQCADKAIIIgFFBEBBACEBDAILIAMgASgCDEYhACABIQMgAA0ACwsgBCgCBCEEIAEgBUcNAAsMAwsCQCADIgAoAhAiAQRAA0AgASIDKAIMIgENAAwCCwALA0AgACgCCCIDRQRAQQAhAwwCCyAAIAMoAhBGIQEgAyEAIAENAAsLIAIgA0cNAAsLAkACQAJAAkAgB0EEaiIGIAQiAUYNACACKAIAIQADQCABKAIIIABGDQEgASgCBCIBIAZHDQALDAELIAEgBkcNAQsCQCACKAIMIgMEQANAIAMiASgCECIDDQAMAgsACwNAIAIoAggiAUUEQEEAIQEMAgsgAiABKAIMRiEAIAEhAiAADQALCyABIAVG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QQpNBEAgAyAHOgALIAMhAAwBCyAHQRBqQXBxIgYQnQYhACADIAZBgICAgHhyNgIIIAMgADYCACADIAc2AgQLIAEgC0cEfyAAIAEgBxDcAiAHagUgAAtBADoAACAEIAMoAgAgAyADLQALIgBBGHRBGHVBAEgiARsgAygCBCAAIAEbEKYGIAMsAAtBAE4NACADKAIAEIYDCyADQRBqJAAMAQsQqgEACyACIAJB8AFqIAIoAiAgBCACLAArIgBBAEgiARsgAigCJCAAQf8BcSABGxCnBiIAKAIINgKoAiACIAApAgA3A6ACIABCADcCACAAQQA2AggCQCAQKAIEIBAtAAsiACAAQRh0QRh1IgFBAEgbIgNFBEAgAkEAOgAQIAJBADoAGyACIAJBoAJqIAJBEGpBABCnBiIAKAIINgKIAiACIAApAgA3A4ACIABCADcCACAAQQA2AgggDCACQYACahCeBiACLACLAkEASARAIAIoAoACEIYDCyACLAAbQQBODQEgAigCEBCGAwwBCyACQRAQnQYiADYCACACQo6AgICAgoCAgH83AgQgAEEAOgAOIABBtSopAAA3AAYgAEGvKikAADcAACACIAIgECgCACAQIAFBAEgbIAMQpwYiACgCCDYCGCACIAApAgA3AxAgAEIANwIAIABBADYCCCACIAJBoAJqIAIoAhAgAkEQaiACLQAbIgBBGHRBGHVBAEgiARsgAigCFCAAIAEbEKcGIgAoAgg2AogCIAIgACkCADcDgAIgAEIANwIAIABBADYCCCAMIAJBgAJqEJ4GIAIsAIsCQQBIBEAgAigCgAIQhgMLIAIsABtBAEgEQCACKAIQEIYDCyACLAALQQBODQAgAigCABCGAwsgAiwAqwJBAEgEQCACKAKgAhCGAwsgAiwAK0EASARAIAIoAiAQhgMLIAIsAPsBQQBIBEAgAigC8AEQhgMLIAIsADtBAEgEQCACKAIwEIYDCyACLADrAUEASARAIAIoAuABEIYDCyACLADbAUEASARAIAIoAtABEIYDCyACLABLQQBIBEAgAigCQBCGAwsgAiwAywFBAEgEQCACKALAARCGAwsgAiwAa0EASARAIAIoAmAQhgMLAkAgE0UNACACLABbQQBODQAgAigCUBCGAwsgAiwAuwFBAEgEQCACKAKwARCGAwsgAiwAe0EASARA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CyACLQAEDQAgAkEBOgAEIAAgACgCDEEBajYCDAsLOQEBfyAAIAFGBEBBAQ8LA0ACQCAAKAIcIgJFDQAgAiABELEBDQAgACgCICIAIAFHDQELCyACQQBHC+cCAQR/IwBBIGsiAiQAIAJBADYCGCACIAJBEGoiAzYCFCACIAM2AhAgAkEANgIIIAIgAjYCBCACIAI2AgAgACADELQBGiABIAIQtAEaAkAgAyACKAIUIgRGDQAgAigCBCIBIAJGDQADQCAEKAIIIQMgASEAAkADQCADIAAoAghHBEAgACgCBCIAIAJHDQEMAgsLIAAgAkYNAEEBIQUMAgsgBCgCBCIEIAJBEGpHDQALCwJAIAIoAghFDQAgAigCBCIAKAIAIgEgAigCACIDKAIENgIEIAMoAgQgATYCACACQQA2AgggACACRg0AA0AgACgCBCEBIAAQhgMgASIAIAJHDQALCwJAIAIoAhhFDQAgAigCFCIAKAIAIgEgAigCECIDKAIENgIEIAMoAgQgATYCACACQQA2AhggACACQRBqRg0AA0AgACgCBCEBIAAQhgMgASIAIAJBEGpHDQALCyACQSBqJAAgBQsyAQJ/IAAoAhwiAkUEQEEBDwsDQCACELMBIAFqIQEgACgCICIAKAIcIgINAAsgAUEBagtfAQF/A0AgACgCHCICBEAgAiABELQBIQEgACgCICEADAELC0EMEJ0GIgIgATYCBCACIAA2AgggAiABKAIAIgA2AgAgACACNgIEIAEgAjYCACABIAEoAghBAWo2AgggAQubAQIDfwF+IwBBMGsiAyQAAkAgASgCHCIERQRAIAMgATYCKCACIANBKGoQuAEgAikCACEGDAELIAMgAikCACIGNwMQIAMgBjcDICADQShqIgUgBCADQRBqELUBIAEoAiAhASADIAMpAygiBjcDCCADIAY3AxggBSABIANBCGoQtQEgAiADKQMoIgY3AgALIAAgBjcCACADQTBqJAALUAECfyMAQRBrIgIkAANAIAAoAhwiAwRAIAMgARC2ASEBIAAoAiAhAAwBCwsgAiAANgIMIAIgATYCCCACQQhqIAJBDGoQuQEgAkEQaiQAIAELIAAgAQRAIAAgASgCABC3ASAAIAEoAgQQtwEgARCGAwsLtQUBCX8jAEEQayIFJAACfyAFQQhqIQIgASEJAkAgACgCACIIIgFBBGoiAyAAKAIEIgRHBEAgCSgCACIGIAQoAhAiB08NAQsgBCgCACEHAkAgBCICIAEoAgBHBEACQCAHRQRAIAQhAQNAIAEoAggiAigCACABRiEGIAIhASAGDQALDAELIAchAQNAIAEiAigCBCIBDQALCyAJKAIAIgYgAigCEE0NAQsgB0UEQCAFIAQ2AgwgBAwDCyAFIAI2AgwgAkEEagwCCyADKAIAIgFFBEAgBSADNgIMIAMMAgsDQAJAIAEiAigCECIBIAZLBEAgAiIDKAIAIgENAgwBCyABIAZPDQAgAkEEaiEDIAIoAgQiAQ0BCwsgBSACNgIMIAMMAQsgBiAHSwRAAkAgBCgCBCIHRQRAIAQhAQNAIAEoAggiAigCACABRyEKIAIhASAKDQALDAELIAchAQNAIAEiAigCACIBDQALCwJAIAIgA0cEQCAGIAIoAhBPDQELIAdFBEAgBSAENgIMIARBBGoMAwsgBSACNgIMIAIMAgsgAygCACIBRQRAIAUgAzYCDCADDAILA0ACQCABIgIoAhAiASAGSwRAIAIiAygCACIBDQIMAQsgASAGTw0AIAJBBGohAyACKAIEIgENAQsLIAUgAjYCDCADDAELIAUgBDYCDCACIAQ2AgAgAgsiBCgCACICRQRAQRQQnQYiAiAJKAIANgIQIAIgBSgCDDYCCCACQgA3AgAgBCACNgIAIAIhASAIKAIAKAIAIgMEQCAIIAM2AgAgBCgCACEBCyAIKAIEIAEQugEgCCAIKAIIQQFqNgIICyAAIAI2AgQCQCACKAIEIgEEQANAIAEiAigCACIBDQAMAgsACwNAIAIgAigCCCICKAIARw0ACwsgACACNgIEIAVBEGokAAvlAQEGfyAAKAIAIgAoAgQiAiAAKAIIIgNJBEAgAiABKAIANgIAIAAgAkEEajYCBA8LAkAgAiAAKAIAIgJrIgZBAnUiBUEBaiIEQYCAgIAESQRAIAMgAmsiA0EBdSIHIAQgBCAHSRtB/////wMgA0H8////B0kbIgQEfyAEQYCAgIAETw0CIARBAnQQnQYFQQALIgMgBUECdGoiBSABKAIANgIAIAZBAEoEQCADIAIgBhDcAhoLIAAgAyAEQQJ0ajYCCCAAIAVBBGo2AgQgACADNgIAIAIEQCACEIYDCw8LEBcACxAYAAuUBAEDfyABIAAgAUYiAjoADAJAIAINAANAIAEoAggiAi0ADA0BAkAgAiACKAIIIgMoAgAiBEYEQAJAIAMoAgQiBEUNACAELQAMDQAMAgsCQCABIAIoAgBGBEAgAiEBDAELIAIgAigCBCIBKAIAIgA2AgQgASAABH8gACACNgIIIAIoAggFIAMLNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCACACIAE2AgggASgCCCIDKAIAIQILIAFBAToADCADQQA6AAwgAyACKAIEIgA2AgAgAARAIAAgAzYCCAsgAiADKAIINgIIIAMoAggiACAAKAIAIANHQQJ0aiACNgIAIAIgAzYCBCADIAI2AggPCwJAIARFDQAgBC0ADA0ADAELAkAgASACKAIARwRAIAIhAQwBCyACIAEoAgQiADYCACABIAAEfyAAIAI2AgggAigCCAUgAws2AgggAigCCCIAIAAoAgAgAkdBAnRqIAE2AgAgASACNgIEIAIgATYCCCABKAIIIQMLIAFBAToADCADQQA6AAwgAyADKAIEIgAoAgAiATYCBCABBEAgASADNgIICyAAIAMoAgg2AgggAygCCCIBIAEoAgAgA0dBAnRqIAA2AgAgACADNgIAIAMgADYCCAwCCyAEQQxqIQEgAkEBOgAMIAMgACADRjoADCABQQE6AAAgAyIBIABHDQALCwurAgEDfyMAQSBrIgQkAAJAIAEoAgAiAiAAQeAAakdBACACGw0AIAAoAgwiAiABKAIERg0AIAQgACgCBDYCCCABQQxqIAIgAEGAA2ogAEGQA2oQkwEgACgCkAMiAyADKAKQAUEBajYCkAEgASgCDCECIAEgAzYCDAJAIAIoApABQQFHBEAgAiACKAKQASIDQQFrNgKQASADQQFHDQELIAIQFiACEIYDCyAAKAKUAyICIAIoAmBBAWo2AmAgASgCECEDIAEgAjYCECAEIAM2AhAgBEEQahAVGiAAKAKYAyICIAIoAmBBAWo2AmAgASgCFCEDIAEgAjYCFCAEIAM2AhggBEEYahAVGiABIAAoApwDNgIYIAAoAgwiACAALQAcQSByOgAcCyAEQSBqJAALLgEBfwN/IAAoAhwiAkUEQCAAIAFGDwsgAiABELwBBH9BAQUgACgCICEADAELCws2ACABBEAgACABKAIAEL0BIAAgASgCBBC9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RP///////+9/IAOZRAAAAAAAAPB/YxuaOQNwIAFBMGoiCiAGIAFB8ABqIgsQ1wEgASsDMCEEIAErAzghBSAHIAIoAgAiAkEwahDVASAIIAJByABqENUBIAEgASsDYDkDGCABIAErA1iaOQMQIAEgASsDSDkDCCABIAErA0CaOQMAIAYgCSABENYBIAFEAQAAAAAAAABEAAAAAAAA8D8gASgCaCABKAJQaxDhAiIDIANEAAAAAAAAAABhGzkDeCABIANE////////738gA5lEAAAAAAAA8H9jG5o5A3AgCiAGIAsQ1wEgASsDMCEDIAAgASsDODkDGCAAIAU5AxAgACADmjkDCCAAIASaOQMAIAFBgAFqJAALpgMBBH8jAEEQayIGJAAgACgCACEIIAEoAgAiACADKAIAIgcQFCIFRQRAIABBMGogB0EwahAUIQULQQEhAAJAAkACQCAFQQFqDgIAAgELIAIoAgAiACADKAIAIgcQFCIFRQRAIABBMGogB0EwahAUIQULQQAhAAJAAkAgBUEBag4CAwABC0EBIQAMAgsgAigCACIAIAQoAgAiBxAUIgVFBEAgAEEwaiAHQTBqEBQhBQtBASEAAkACQCAFQQFqDgIAAwELIAYgASACIAMgBBDTASAGLQAAQQBHIQAMAgsgBiABIAIgAyAEENQBIAYtAABBAEchAAwBCyAEKAIAIgAgASgCACIHEBQiBUUEQCAAQTBqIAdBMGoQFCEFC0EAIQACQAJAIAVBAWoOAgIAAQtBASEADAELIAQoAgAiACACKAIAIgcQFCIFRQRAIABBMGogB0EwahAUIQULQQEhAAJAAkAgBUEBag4CAAIBCyAGIAMgBCABIAIQ0wEgBi0AAEEARyEADAELIAYgAyAEIAEgAhDUASAGLQAAQQBHIQALIAZBEGokACAAC+EDAQJ/IwBBIGsiBCQAIARBAzYCGCAEIAI2AhQgBCABNgIQQegAEJ0GQQBB4AAQ3gIhAkEEEJ0GIQMgAkIANwMQIAIgAzYCACACIANBBGo2AgggA0EANgEAIAJBADYCICACQgA3AxggAiADNgIEQQQQnQYhAyACQgA3AyggAiADNgIYIAIgA0EEajYCICADQQE2AQAgAkEANgI4IAJCADcDMCACIANBAmo2AhxBBBCdBiEDIAJBQGtCADcDACACIAM2AjAgAiADQQRqNgI4IANBADYBACACQQA2AlAgAkIANwNIIAIgAzYCNEEEEJ0GIQMgAkIANwNYIAIgAzYCSCACIANBBGo2AlAgA0EBNgEAIAJBATYCYCACIANBAmo2AkwgBCACNgIcIARBHGohAgJAAkACQAJAIARBEGoQ2AFBAWsOAgECAAsgAEEAOgAADAILIAQoAhhBA0YEQCAEQRBqENgBGgsgBCAEKAIcIgE2AgggASABKAJgQQFqNgJgIAAgATYCCCABIAEoAmBBAWo2AmAgAEEBOgAAIABBADYCBCAEQQhqEBUaDAELIAAgASgCACIBNgIIIAEgASgCkAFBAWo2ApABIABBAToAACAAQQE2AgQLIAIQFRogBEEgaiQAC6EEAQR/IwBBEGsiBCQAAkAgACgCACICIAEoAgAiA0YEQCAAKAIEIQMgACABKAIENgIEIAEgAzYCBCACIAJBH3VGBEAgACABKAIINgIIDAILIAAoAgghAiAAIAEoAgg2AgggASACNgIIIAAoAgwhAiAAIAEoAgw2AgwgASACNgIMIAAgASgCEDYCEAwBCyAEIAA2AgggBCADQR91IgUgA3M2AgwgAyAFRgRAIABBBGohAwJAIAIgAkEfdUYEQCADEBUaDAELIABBDGoQFRogAEEIahAVGiAAKAIEIgAoApABQQFHBEAgACAAKAKQASIAQQFrNgKQASAAQQFHDQELIAMoAgAQFiADKAIAEIYDCyAEKAIIIgAgASgCBCICNgIEIAIgAigCYEEBajYCYCAAIAEoAgg2AgggACAEKAIMNgIADAELIAQoAggiAEEEaiECAkAgACgCACIDQR91IANGBEAgAhAVGgwBCyAAQQxqEBUaIABBCGoQFRogACgCBCIAKAKQAUEBRwRAIAAgACgCkAEiAEEBazYCkAEgAEEBRw0BCyACKAIAEBYgAigCABCGAwsgBCgCCCIAIAEoAgQiAjYCBCACIAIoApABQQFqNgKQASAAIAEoAggiAjYCCCACIAIoAmBBAWo2AmAgACABKAIMIgI2AgwgAiACKAJgQQFqNgJgIAAgASgCEDYCECAEKAIIIAQoAgw2AgALIARBEGokAAupAQEBfyMAQRBrIgQkACAAIAEoAgAiATYCACABIAEoApABQQFqNgKQASAAIAIoAgAiATYCBCABIAEoAmBBAWo2AmAg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SAsgAkHgAGokAAuyCwEIfwJAAkACQCAAKAIMIgcoAhQiBCgCCCgCACIBKAIMIgJFBEAgASECA0AgAigCCCIFRQRAIABB4ABqIQZBACEFDAQLIAIgBSgCDEYhAyAFIQIgAw0ACwwBCwNAIAIiBSgCECICDQALCyAFIABB4ABqIgZGDQELIAdBEGohCANAIAQhAgJAIAQgCEYNACAFKAIAIQMDQCACKAIIIANGDQEgAigCBCICIAhHDQALDAILIAIgCEYNAQJAIAUiAygCDCICBEADQCACIgUoAhAiAg0ADAILAAsDQCADKAIIIgVFBEBBACEFDAILIAMgBSgCDEYhAiAFIQMgAg0ACwsgBSAGRw0ACyAGIQULAkACQCAAKAJUIgAgBiAAGyICIAFGBEAgB0EQaiEGIAEgBUYNAQNAIAQgASgCADYCCAJAIAEiAygCDCICBEADQCACIgEoAhAiAg0ADAILAAsDQCADKAIIIgFFBEBBACEBDAILIAMgASgCDEYhACABIQMgAA0ACwsgBCgCBCEEIAEgBUcNAAsMAQsCQAJAAkACQCABKAIQIgAEQANAIAAiAygCDCIADQAMAgsACwNAIAEoAggiA0UEQEEAIQMMAwsgASADKAIQRiEAIAMhASAADQALCyACIANGDQELIAdBEGohBgNAAkACQAJAIAYgBCIBRg0AIAMoAgAhAANAIAEoAgggAEYNASABKAIEIgEgBkcNAAsMAQsgASAGRw0BCwJAIAMoAgwiAgRAA0AgAiIBKAIQIgINAAwCCwALA0AgAygCCCIBRQRAQQAhAQwCCyADIAEoAgxGIQAgASEDIAANAAsLIAEgBUYNAwNAIAQgASgCADYCCAJAIAEiAygCDCICBEADQCACIgEoAhAiAg0ADAILAAsDQCADKAIIIgFFBEBBACEBDAILIAMgASgCDEYhACABIQMgAA0ACwsgBCgCBCEEIAEgBUcNAAsMAwsCQCADIgAoAhAiAQRAA0AgASIDKAIMIgENAAwCCwALA0AgACgCCCIDRQRAQQAhAwwCCyAAIAMoAhBGIQEgAyEAIAENAAsLIAIgA0cNAAsLAkACQAJAAkAgB0EQaiIGIAQiAUYNACACKAIAIQADQCABKAIIIABGDQEgASgCBCIBIAZHDQALDAELIAEgBkcNAQsCQCACKAIMIgMEQANAIAMi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AkYNAEEBIQUMAgsgBCgCBCIEIAJBEGpHDQALCwJAIAIoAghFDQAgAigCBCIAKAIAIgEgAigCACIDKAIENgIEIAMoAgQgATYCACACQQA2AgggACACRg0AA0AgACgCBCEBIAAQhgMgASIAIAJHDQALCwJAIAIoAhhFDQAgAigCFCIAKAIAIgEgAigCECIDKAIENgIEIAMoAgQgATYCACACQQA2AhggACACQRBqRg0AA0AgACgCBCEBIAAQhgMgASIAIAJBEGpHDQALCyACQSBqJAAgBQsyAQJ/IAAoAiwiAkUEQEEBDwsDQCACEJsCIAFqIQEgACgCMCIAKAIsIgINAAsgAUEBagtfAQF/A0AgACgCLCICBEAgAiABEJwCIQEgACgCMCEADAELC0EMEJ0GIgIgATYCBCACIAA2AgggAiABKAIAIgA2AgAgACACNgIEIAEgAjYCACABIAEoAghBAWo2AgggAQubAQIDfwF+IwBBMGsiAyQAAkAgASgCLCIERQRAIAMgATYCKCACIANBKGoQuAEgAikCACEGDAELIAMgAikCACIGNwMQIAMgBjcDICADQShqIgUgBCADQRBqEJ0CIAEoAjAhASADIAMpAygiBjcDCCADIAY3AxggBSABIANBCGoQnQIgAiADKQMoIgY3AgALIAAgBjcCACADQTBqJAALIAAgAQRAIAAgASgCABCeAiAAIAEoAgQQngIgARCGAwsL+gICA38BfiMAQSBrIgQkAAJAIAEoAgAiAiAAQeAAakdBACACGw0AIAAoAgwiAiABKAIERg0AIAQgACgCBCgCADYCCCABQQxqIAIgAEGcA2ogAEG8A2oQkwEgASkCHCEFIAAgASgCJDYCtAMgACAFNwKsAyABKQIcIQUgACABKAIkNgLUAyAAIAU3AswDIAAoArwDIgMgAygCkAFBAWo2ApABIAEoAgwhAiABIAM2AgwCQCACKAKQAUEBRwRAIAIgAigCkAEiA0EBazYCkAEgA0EBRw0BCyACEBYgAhCGAwsgACgCwAMiAiACKAJgQQFqNgJgIAEoAhAhAyABIAI2AhAgBCADNgIQIARBEGoQFRogACgCxAMiAiACKAJgQQFqNgJgIAEoAhQhAyABIAI2AhQgBCADNgIYIARBGGoQFRogASAAKALIAzYCGCABIAApANEDNwAhIAEgACkCzAM3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ICIgASsDGKGiIAErAxCgOQM4CyABKAJ4IgENAAsgBSACNgLUBSACIgYLIQEgBSgCyAUiAyAFKALEBSITSARAIAYhAyMAQUBqIgckACAFQdgFaiIEKAIAIgEEQANAIAEoAhghAiABEIYDIAQgAjYCACACIgENAAsLIAdBADYCPAJAAkACQAJAIANFDQADQAJAAkAgAygCZEEBRg0AIAMoAkwNACADKAJQRQ0BCwJAAkAgBygCPCICRQRAIAdBPGohCAwBCyADQUBrIQogAysDOCIdIAMrAzAiH6EhIUGIvwIrAwAhIyAHQTxqIQgDQAJAAkACQAJAAkACQCAdIAIrAxAiHGYNACAKKwMAIAIrAxhhDQAgHCACKwMIIiChIiUgIaEiHJkgI2VFDQELIAhBKBCFAyIBNgIAIAFFDQEgASAdOQMQIAEgHzkDCCABIAM2AgAMBwsgHyAgoSAcoyImICSiIRwgAigCACELIAQiASgCACICRQ0CIAIrAxAgHGQEfyABBQNAIAIiASgCGCICRQRAIAFBGGohAQwFCyACKwMQIBxkRQ0ACyABQRhqC0EgEIUDIgE2AgAgAUUNAQwDCyAHQacUNgIwQbiRASgCACAHQTBqEOACDAoLIAdBwhQ2AiBBuJEBKAIAIAdBIGoQ4AIMCQsgAUEgEIUDIgE2AgBBACECIAENACAHQcIUNgIQQbiRASgCACAHQRBqEOACDAgLIAEgAjYCGCABICYgJaIgIKA5AwggASADNgIEIAEgCzYCACABIBw5AxAgCCgCACIBQSBqIQggASgCICICDQALCyAIQSgQhQMiATYCACABRQ0EIAEgAzYCACABIAMrAzA5AwggASADKwM4OQMQIANBQGshCkEAIQILIAorAwAhHCABIAI2AiAgASAcOQMYCyADKAJ4IgMNAAsgBygCPCICRQ0AA0AgAigCICEBIAIQhgMgASICDQALCyAHQUBrJAAMAgsgB0GnFDYCAEG4kQEoAgAgBxDgAgtBABADAAsgBSgC2AUiCgRAA0AgCigCBCEDAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJ/AkACQAJAAkAgCigCACIHKAJMIhlFBEAgBygCUEUNByADKAJMIgINASADKAJQRQ0HIANB7ABq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lRY2AlBBuJEBKAIAIA1B0ABqEOACDAELIA1B4ABqJAAgCg8LQQAQAwALQgEBfwNAIAIoAggiAwRAIAAgASADELoCCyABIAAoAgAiA0EDdGogAisDADkDACAAIANBAWo2AgAgAigCDCICDQALCzoBAX8CQCAAKAIAIgFFDQAgAUEIahC7AiAAKAIAQQxqELsCIAAoAgAiAUUNACABEIYDIABBADYCAAsL7wICCX8GfCMAQRBrIgMkAAJAAkAgACgCACIFQQV0IgFFBEAMAQsgARCFAyIERQ0BCyAFQQBKBEAgACgCCCEGA0AgBCACQQV0aiIBQv////////93NwMYIAFC/////////3c3AxAgAUL/////////9/8ANwMIIAFC//////////f/ADcDACAGIAJBA3RqIgAoAgAiB0EASgRAIAAoAgQhCEEAIQBE////////738hDET////////v/yENRP///////+//IQ5E////////738hDwNAIA8gCCAAQQR0aiIJKwMAIgpkBEAgASAKOQMAIAohDwsgDCAJKwMIIgtkBEAgASALOQMIIAshDAsgCiAOZARAIAEgCjkDECAKIQ4LIAsgDWQEQCABIAs5AxggCyENCyAAQQFqIgAgB0cNAAsLIAJBAWoiAiAFRw0ACwsgA0EQaiQAIAQPCyADQZkVNgIAQbiRASgCACADEOACQQAQAwALsQEBA38jAEEgayIEJAADQCAAIgUoAgAiBkEQaiEAIAYNAAsgBUEYEIUDIgA2AgACQCAABEAgAEEBNgIAIABCADcCDCAAQRgQhQMiADYCCCAARQ0BIABBADYCECAAIAM5AwggACACOQMAIAEgBSgCADYCbCAEQSBqJAAPCyAEQakWNgIAQbiRASgCACAEEOACQQAQAwALIARBrxU2AhBBuJEBKAIAIARBEGoQ4AJBABADAAsMACAABEAgABCGAwsLBwBBARCdBgvEjwEDFn8BfAF+IwBBoAJrIg8kACAPQYQtNgKkASAPQbArNgKgASAPQawBaiIEQQA2AghBGBCdBiIAQgA3AgQgAEGECDsBDCAAQZQ6NgIAIAQgADYCBCAAIAA2AhQgACAANgIQIARBADYCFEEkEJ0GIgBCADcCBCAAQaA+NgIAIABCADcCFCAAQgA3AgwgBCAANgIQIAAgADYCICAAIAA2Ahwg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IAYoAiggChDdASAGKAIoIgAoAlQiASAAQeAAaiIAIAEbIgogAEcNAAsLIAYgBigCACgCDBECACAGKALkAiIAKAIoEF8gACgCKEEAOgB9IAYQYBogEBBhGiAGQZAFaiQADAELIARBADYCCCAEIAQ2AgQgBCAENgIAIBQhACMAQcAGayITJAAgAygCeCEFIBNBkARqIhFBADYCBCARQgA3AjQgESADNgIwIBEgAzYCKCARQQA2AiQgESARQRxqIgI2AiAgEUEANgIYIBFCADcCECARIANBBGoiATYCDCARQcz1ADYCACARIAE2AiwgEUHw9QA2AgggEUIANwI8IBEgAjYCHCARQQwQnQYiAjYCOCARQUBrIAJBDGoiATYCACACQQA2AgggAkIANwIAIBFBADYCeCARQQA2AlwgEUIANwJUIBFCgICAgBA3AkggESABNgI8IBFCgISAgPA/NwJwIBFBgPgAEJ0GNgJkQQAhCQNAIAlBFGwiAiARKAJkaiIBQgA3AgAgAUEANgIQIAFCADcCCCARKAJkIAlBAXJBFGxqIgFCADcCACABQQA2AhAgAUIANwIIIAIgESgCZGoiAUEANgI4IAFCADcCMCABQgA3AiggAiARKAJkaiIBQQA2AkwgAUIANwJEIAFCADcCPCACIBEoAmRqIgFBADYCYCABQgA3AlggAUIANwJQIAIgESgCZGoiAUEANgJ0IAFCADcCbCABQgA3AmQgCUEGaiIJQYAGRw0ACyARIBEoAmQiCkGA0ABqNgJsIBEgCkGA+ABqNgJoIBFB0ABqIQcgESgCSCECQQAhCQNAIAogCUEUbGoiASACNgIAIAEgBzYCECAKIAlBAXJBFGxqIgEgAjYCACABIAc2AhAgCiAJQQJyQRRsaiIBIAI2AgAgASAHNgIQIAogCUEDckEUbGoiASACNgIAIAEgBzYCECAJQQRqIglBgARHDQALIAogESgCTDYCACARQQA2AlwgEUIANwJUIBFBlAFqEGQgEUEANgLsASARQgA3AuQBIBFB3OIANgIAIBFB8AFqEBEaIBFCADcAhQIgEUIANwKAAiARQZACahARGiARQgA3AKUCIBFCADcCoAIgEyAFNgKIBCATQQA2AoAEIBMgE0H4A2oiBjYC/AMgEyAGNgL4AyATQQA2AvADIBMgE0HoA2oiEDYC7AMgEyAQ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IQAgAUEIahAVGiABEIYDIAAiASAERw0ACwsgAygCcCIBIAtHBEADQCALKAIAKAIIIgAgACgCACgCHBECACALKAIAIgsgAUcNAAsLIARBEGokACAPKAKwASIEKAIQIgAgBEcEQCAEIQIDQCAAKAIQIQEgAC0ABEEBcQRAIA8gFjYCGCAPIBY2AgggDyAENgIUIA8gADYCECAPIA8pAxA3AwAjAEEgayIOJAAgDygCACINKAIEQX5xIgwoAgghBSAPQQA2AjggDyAFNgI0IA8gBTYCMCAOIA8oAgg2AhggDiAPKQIANwMQIA9BoAFqIgsoAnAiByALQewAaiIKRwRAA0AgBygCCCICKAIAKALcASEAIA4gDigCGDYCCCAOIA4pAxA3AwAgAiAOIAARAAAgBygCBCIHIApHDQALCyAMKAIMIgIoAgAiACACKAIENgIEIAIoAgQgADYCACAFIAUoAihBAWs2AiggAhCGAyAMKAIEIgAgDCgCADYCACAMKAIAIAA2AgQgCyALKAJQQQFrNgJQQbDGAi0AAEUEQEH4xAJCADcCAEGwxgJBAToAAEGkxQJCIDcCAEGcxQJClICAgIAENwIAQYDFAkIANwIAQYjFAkIANwIAQZDFAkIANwIAQZjFAkEANgIACyAMQZDFAigCADYCAEGQxQIgDDYCACANKAIIEBUQhgMgDSgCFCIAIA0oAhA2AhAgDSgCECAANgIUIAsgCygCFEEBazYCFCANIA0oAgAoAgARAQAaQa3GAi0AAEUEQEHEwwJCADcCAEGtxgJBAToAAEHwwwJCIDcCAEHowwJCmICAgIAENwIAQczDAkIANwIAQdTDAkIANwIAQdzDAkIANwIAQeTDAkEANgIACyANQdzDAigCADYCAEHcwwIgDTYCACALKAJwIgIgCkcEQANAIAooAgAoAggiACAAKAIAKALgARECACAKKAIAIgogAkcNAAsLIA5BIGokACAPKAKwASECCyABIgAgAkcNAAsLIA8oArwBIgAoAhwiAiAARwRAA0AgAigCHCgCHCEQAn8gAigCFCIAQQFxRQRAIABBCGoMAQsCQCAAQX5xIgEoAhBBAkcEQCABIQAMAQsgAUEIaiEFA0AgBSgCACIAQQhqIQUgACgCEEECRg0ACyABIAA2AgggAUECNgIQIAIgAEEBcjYCFAsgAEEIagso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CxAAIAAoAgQgACgCAGtBBHULDQAgACgCACABQQR0agsMACAAIAAoAgA2AgQLJAEBfyAABEAgACgCACIBBEAgACABNgIEIAEQhgMLIAAQhgMLC9MBAQV/IAAoAgQiAiAAKAIIRwRAIAIgATYCACAAIAJBBGo2AgQPCwJAIAIgACgCACIFayICQQJ1IgZBAWoiA0GAgICABEkEQCACQQF1IgQgAyADIARJG0H/////AyACQfz///8HSRsiAwR/IANBgICAgARPDQIgA0ECdBCdBgVBAAsiBCAGQQJ0aiIGIAE2AgAgAkEASgRAIAQgBSACENwCGgsgACAEIANBAnRqNgIIIAAgBkEEajYCBCAAIAQ2AgAgBQRAIAUQhgMLDwsQFwALEBgACxAAIAAoAgQgACgCAGtBAnULEAAgACgCACABQQJ0aigCAAukAQEDfwJAIAAoAgQiAiAAKAIIRwRAIAJBADYCCCACQgA3AgAgASgCBCIDIAEoAgAiBEcEQCADIARrIgRBAEgNAiACIAQQnQYiAzYCACACIAM2AgQgAiADIARBBHVBBHRqNgIIIAIgASgCBCABKAIAIgRrIgFBAEoEfyADIAQgARDcAiABagUgAws2AgQLIAAgAkEMajYCBA8LIAAgARAeDwsQFwALEAAgACgCBCAAKAIAa0EMbQsNACAAKAIAIAFBDGxqC0cBBH8gACgCBCIBIAAoAgAiAkcEQANAIAFBDGsiBCgCACIDBEAgAUEIayADNgIAIAMQhgMLIAQiASACRw0ACwsgACACNgIEC2YBBH8gAARAIAAoAgAiAgRAIAIhASACIAAoAgQiA0cEQANAIANBDGsiASgCACIEBEAgA0EIayAENgIAIAQQhgMLIAEiAyACRw0ACyAAKAIAIQELIAAgAjYCBCABEIYDCyAAEIYDCwuABAEDfyACQYAETwRAIAAgASACEAQgAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCAAQQNxRQRAIAAhAgwBCyACRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAkEDcUUNASACIANJDQALCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiABKAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJBEAgACECDAELIAAgA0EEayIESwRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL6QIBAn8CQCAAIAFGDQAgASAAIAJqIgRrQQAgAkEBdGtNBEAgACABIAIQ3AIPCyAAIAFzQQNxIQMCQAJAIAAgAUkEQCADBEAgACEDDAMLIABBA3FFBEAgACEDDAILIAAhAwNAIAJFDQQgAyABLQAAOgAAIAFBAWohASACQQFrIQIgA0EBaiIDQQNxDQALDAELAkAgAw0AIARBA3EEQANAIAJFDQUgACACQQFrIgJqIgMgASACai0AADoAACADQQNxDQALCyACQQNNDQADQCAAIAJBBGsiAmogASACaigCADYCACACQQNLDQALCyACRQ0CA0AgACACQQFrIgJqIAEgAmotAAA6AAAgAg0ACwwCCyACQQNNDQADQCADIAEoAgA2AgAgAUEEaiEBIANBBGohAyACQQRrIgJBA0sNAAsLIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQQFrIgINAAsLIAAL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyAB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ABDtAhoLC3IBA38gACgCACwAAEEwa0EKTwRAQQAPCwNAIAAoAgAhA0F/IQEgAkHMmbPmAE0EQEF/IAMsAABBMGsiASACQQpsIgJqIAFB/////wcgAmtKGyEBCyAAIANBAWo2AgAgASECIAMsAAFBMGtBCkkNAAsgAgvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC4MBAgN/AX4CQCAAQoCAgIAQVARAIAAhBQwBCwNAIAFBAWsiASAAIABCCoAiBUIKfn2nQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQQFrIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQtyAQF/IwBBgAJrIgUkAAJAIAIgA0wNACAEQYDABHENACAFIAFB/wFxIAIgA2siA0GAAiADQYACSSIBGxDeAhogAUUEQANAIAAgBUGAAhDxAiADQYACayIDQf8BSw0ACwsgACAFIAMQ8QILIAVBgAJqJAALxxgDEn8BfAJ+IwBBsARrIgskACALQQA2AiwCQCABvSIZQgBTBEBBASEQQfIPIRMgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEEH1DyETDAELQfgPQfMPIARBAXEiEBshEyAQRSEVCwJAIBlCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiAQQQNqIgMgBEH//3txEPUCIAAgEyAQEPECIABBzRZBnR8gBUEgcSIFG0GaHEHdHyAFGyABIAFiG0EDEPECIABBICAC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BEEQaiABIAJCAEKAgICAgICA//8AEJMDIANB/f8CIANB/f8CSBtB/v8BayEDIAQpAxghAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEFAayABIAJCAEKAgICAgICAORCTAyAEKQNIIQIgBCkDQCEBIANB9IB+SwRAIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQkwMgA0HogX0gA0HogX1KG0Ga/gFqIQMgBCkDOCECIAQpAzAhAQsgBCABIAJCACADQf//AGqtQjCGEJMDIAAgBCkDCDcDCCAAIAQpAwA3AwAgBEHQAGokAAvXBgIEfwN+IwBBgAFrIgUkAAJAAkACQCADIARCAEIAEIwDRQ0AAn8gBEL///////8/gyEJAn8gBEIwiKdB//8BcSIGQf//AUcEQEEEIAYNARpBAkEDIAMgCYRQGwwCCyADIAmEUAsLIQcgAkIwiKciCEH//wFxIgZB//8BRg0AIAcNAQsgBUEQaiABIAIgAyAEEJMDIAUgBSkDECIBIAUpAxgiAiABIAIQjgMgBSkDCCECIAUpAwAhBAwBCyABIAJC////////P4MgBq1CMIaEIgogAyAEQv///////z+DIARCMIinQf//AXEiB61CMIaEIgkQjANBAEwEQCABIAogAyAJEIwDBEAgASEEDAILIAVB8ABqIAEgAkIAQgAQkwMgBSkDeCECIAUpA3AhBAwBCyAGBH4gAQUgBUHgAGogASAKQgBCgICAgICAwLvAABCTAyAFKQNoIgpCMIinQfgAayEGIAUpA2ALIQQgB0UEQCAFQdAAaiADIAlCAEKAgICAgIDAu8AAEJMDIAUpA1giCUIwiKdB+ABrIQcgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCEJIApC////////P4NCgICAgICAwACEIQogBiAHSgRAA0ACfiAKIAl9IAMgBFatfSILQgBZBEAgCyAEIAN9IgSEUARAIAVBIGogASACQgBCABCTAyAFKQMoIQIgBSkDICEEDAULIAtCAYYgBEI/iIQMAQsgCkIBhiAEQj+IhAshCiAEQgGGIQQgBkEBayIGIAdKDQALIAchBgsCQCAKIAl9IAMgBFatfSIJQgBTBEAgCiEJDAELIAkgBCADfSIEhEIAUg0AIAVBMGogASACQgBCABCTAyAFKQM4IQIg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BEEddiECIARBAXQhBCADIAJBBHFqIgdBEGooAgAiAg0ACyAHIAA2AhAgACADNgIYCyAAIAA2AgwgACAANgIIDwsgAygCCCIBIAA2AgwgAyAANgIIIABBADYCGCAAIAM2AgwgACABNgIICwtSAQJ/QaTAAigCACIBIABBA2pBfHEiAmohAAJAIAJBACAAIAFNGw0AIAA/AEEQdEsEQCAAEAdFDQELQaTAAiAANgIAIAEPC0HYxgJBMDYCAEF/C8wJAgR+BH8jAEHwAGsiCiQAIARC////////////AIMhBQJAAkAgAVAiCSACQv///////////wCDIgZCgICAgICAwP//AH1CgICAgICAwICAf1QgBlAbRQRAIANCAFIgBUKAgICAgIDA//8AfSIIQoCAgICAgMCAgH9WIAhCgICAgICAwICAf1EbDQELIAkgBkKAgICAgIDA//8AVCAGQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgBkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACACIAEgA4UgAiAEhUKAgICAgICAgIB/hYRQIgkbIQRCACABIAkbIQMMAgsgAyAFQoCAgICAgMD//wCFhFANASABIAaEUARAIAMgBYRCAFINAiABIAODIQMgAiAEgyEEDAILIAMgBYRQRQ0AIAEhAyACIQQMAQsgAyABIAEgA1QgBSAGViAFIAZRGyIMGyEFIAQgAiAMGyIIQv///////z+DIQYgAiAEIAwbIgdCMIinQf//AXEhCyAIQjCIp0H//wFxIglFBEAgCkHgAGogBSAGIAUgBiAGUCIJG3kgCUEGdK18pyIJQQ9rEIsDIAopA2ghBiAKKQNgIQVBECAJayEJCyABIAMgDBshAyAHQv///////z+DIQQgC0UEQCAKQdAAaiADIAQgAyAEIARQIgsbeSALQQZ0rXynIgtBD2sQiwNBECALayELIAopA1ghBCAKKQNQIQMLIARCA4YgA0I9iIRCgICAgICAgASEIQIgBkIDhiAFQj2IhCEEIANCA4YhASAHIAiFIQMCQCAJIAtGDQAgCSALayILQf8ASwRAQgAhAkIBIQEMAQsgCkFAayABIAJBgAEgC2sQiwMgCkEwaiABIAIgCxCSAyAKKQMwIAopA0AgCikDSIRCAFKthCEBIAopAzghAgsgBEKAgICAgICABIQhByAFQgOGIQYCQCADQgBTBEBCACEDQgAhBCABIAaFIAIgB4WEUA0CIAYgAX0hBSAHIAJ9IAEgBlatfSIEQv////////8DVg0BIApBIGogBSAEIAUgBCAEUCILG3kgC0EGdK18p0EMayILEIsDIAkgC2shCSAKKQMoIQQgCikDICEFDAELIAEgBnwiBSABVK0gAiAHfHwiBEKAgICAgICACINQDQAgBUIBgyAEQj+GIAVCAYiEhCEFIAlBAWohCSAEQgGIIQQLIAhCgICAgICAgICAf4MhASAJQf//AU4EQCABQoCAgICAgMD//wCEIQRCACEDDAELQQAhCwJAIAlBAEoEQCAJIQsMAQsgCkEQaiAFIAQgCUH/AGoQiwMgCiAFIARBASAJaxCSAyAKKQMAIAopAxAgCikDGIRCAFKthCEFIAopAwghBAsgBEI9hiAFQgOIhCICIAWnQQdxIglBBEutfCIDIAJUrSAEQgOIQv///////z+DIAutQjCGhCABhHwhBAJAIAlBBEYEQCAEIANCAYMiASADfCIDIAFUrXwhBAwBCyAJRQ0BCwsgACADNwMAIAAgBDcDCCAKQfAAaiQAC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLxAECAX8CfkF/IQMCQCAAQgBSIAFC////////////AIMiBEKAgICAgIDA//8AViAEQoCAgICAgMD//wBRGw0AQQAgAkL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgACAEIAWEhFAEQEEADwsgASACg0IAWQRAQQAgASACUyABIAJRGw0BIAAgASAChYRCAFIPCyAAQgBSIAEgAlUgASACURsNACAAIAEgAoWEQgBSIQMLIAMLtg8CBX8OfiMAQdACayIFJAAgBEL///////8/gyEKIAJC////////P4MhDCACIASFQoCAgICAgICAgH+DIQ0gBEIwiKdB//8BcSEIAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgCEH//wFrQYGAfksNAQsgAVAgAkL///////////8AgyIPQoCAgICAgMD//wBUIA9CgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhDQwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCENIAMhAQwCCyABIA9CgICAgICAwP//AIWEUARAIAMgAkKAgICAgIDA//8AhYRQBEBCACEBQoCAgICAgOD//wAhDQwDCyANQoCAgICAgMD//wCEIQ1CACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEBCACEBDAILIAEgD4RQBEBCgICAgICA4P//ACANIAIgA4RQGyENQgAhAQwCCyACIAOEUARAIA1CgICAgICAwP//AIQhDUIAIQEMAgsgD0L///////8/WARAIAVBwAJqIAEgDCABIAwgDFAiBht5IAZBBnStfKciBkEPaxCLA0EQIAZrIQYgBSkDyAIhDCAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyAKIAMgCiAKUCIHG3kgB0EGdK18pyIHQQ9rEIsDIAYgB2pBEGshBiAFKQO4AiEKIAUpA7ACIQMLIAVBoAJqIApCgICAgICAwACEIhJCD4YgA0IxiIQiAkIAQoCAgICw5ryC9QAgAn0iBEIAEJQDIAVBkAJqQgAgBSkDqAJ9QgAgBEIAEJQDIAVBgAJqIAUpA5gCQgGGIAUpA5ACQj+IhCIEQgAgAkIAEJQDIAVB8AFqIARCAEIAIAUpA4gCfUIAEJQDIAVB4AFqIAUpA/gBQgGGIAUpA/ABQj+IhCIEQgAgAkIAEJQDIAVB0AFqIARCAEIAIAUpA+gBfUIAEJQDIAVBwAFqIAUpA9gBQgGGIAUpA9ABQj+IhCIEQgAgAkIAEJQDIAVBsAFqIARCAEIAIAUpA8gBfUIAEJQDIAVBoAFqIAJCACAFKQO4AUIBhiAFKQOwAUI/iIRCAX0iAkIAEJQDIAVBkAFqIANCD4ZCACACQgAQlAMgBUHwAGogAkIAQgAgBSkDqAEgBSkDoAEiDyAFKQOYAXwiBCAPVK18IARCAVatfH1CABCUAyAFQYABakIBIAR9QgAgAkIAEJQDIAYgCSAIa2ohBgJ/IAUpA3AiEEIBhiIUIAUpA4gBIg5CAYYgBSkDgAFCP4iEfCILQufsAH0iFUIgiCICIAxCgICAgICAwACEIhZCAYYgAUI/iIQiDEIgiCIEfiIRIAFCAYYiD0IgiCIKIAsgFVatIAsgFFStIAUpA3hCAYYgEEI/iIQgDkI/iHx8fEIBfSIQQiCIIgt+fCIOIBFUrSAOIA4gEEL/////D4MiECAMQv////8PgyIUfnwiDlatfCAEIAt+fCAEIBB+IhMgCyAUfnwiESATVK1CIIYgEUIgiIR8IA4gDiARQiCGfCIOVq18IA4gDiAVQv////8PgyIVIBR+IhMgAiAKfnwiESATVK0gESARIBAgD0L+////D4MiE358IhFWrXx8Ig5WrXwgDiAEIBV+IhcgCyATfnwiBCACIBR+fCILIAogEH58IhBCIIggCyAQVq0gBCAXVK0gBCALVq18fEIghoR8IgQgDlStfCAEIBEgAiATfiICIAogFX58IgpCIIggAiAKVq1CIIaEfCICIBFUrSACIBBCIIZ8IAJUrXx8IgIgBFStfCIEQv////////8AWARAIAVB0ABqIAIgBCADIBIQlAMgAUIxhiAFKQNYfSAFKQNQIgFCAFKtfSELQgAgAX0hCiAGQf7/AGoMAQsgBUHgAGogBEI/hiACQgGIhCICIARCAYgiBCADIBIQlAMgAUIwhiAFKQNofSAFKQNgIgxCAFKtfSELQgAgDH0hCiABIQ8gFiEMIAZB//8AagsiBkH//wFOBEAgDUKAgICAgIDA//8AhCENQgAhAQwBCwJ+IAZBAEoEQCALQgGGIApCP4iEIQsgBEL///////8/gyAGrUIwhoQhDCAKQgGGDAELIAZBj39MBEBCACEBDAILIAVBQGsgAiAEQQEgBmsQkgMgBUEwaiAPIAwgBkHwAGoQiwMgBUEgaiADIBIgBSkDQCICIAUpA0giDBCUAyAFKQM4IAUpAyhCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiAVStfSELIAQgAX0LIQQgBUEQaiADIBJCA0IAEJQDIAUgAyASQgVCABCUAyAMIAIgAiADIAJCAYMiASAEfCIDVCALIAEgA1atfCIBIBJWIAEgElEbrXwiAlatfCIEIAIgAiAEQoCAgICAgMD//wBUIAMgBSkDEFYgASAFKQMYIgRWIAEgBFEbca18IgJWrXwiBCACIARCgICAgICAwP//AFQgAyAFKQMAViABIAUpAwgiA1YgASADURtxrXwiASACVK18IA2EIQ0LIAAgATcDACAAIA03AwggBUHQAmokAAv6AQIDfgJ/IwBBEGsiBSQAAn4gAb0iA0L///////////8AgyICQoCAgICAgIAIfUL/////////7/8AWARAIAJCPIYhBCACQgSIQoCAgICAgICAPHwMAQsgAkKAgICAgICA+P8AWgRAIANCPIYhBCADQgSIQoCAgICAgMD//wCEDAELIAJQBEBCAAwBCyAFIAJCACADp2dBIGogAkIgiKdnIAJCgICAgBBUGyIGQTFqEIsDIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAt/AgJ/AX4jAEEQayIDJAAgAAJ+IAFFBEBCAAwBCyADIAEgAUEfdSICcyACayICrUIAIAJnIgJB0QBqEIsDIAMpAwhCgICAgICAwACFQZ6AASACa61CMIZ8IAFBgICAgHhxrUIghoQhBCADKQMACzcDACAAIAQ3AwggA0EQaiQAC2QCAX8BfiMAQRBrIgIkACAAAn4gAUUEQEIADAELIAIgAa1CACABZyIBQdEAahCLAyACKQMIQoCAgICAgMAAhUGegAEgAWutQjCGfCEDIAIpAwALNwMAIAAgAzcDCCACQRBqJAALUAEBfgJAIANBwABxBEAgAiADQUBqrYghAUIAIQIMAQsgA0UNACACQcAAIANrrYYgASADrSIEiIQhASACIASIIQILIAAgATcDACAAIAI3AwgLyQoCBX8PfiMAQeAAayIFJAAgBEL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghDiAEQjCIp0H//wFxIQcCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAHQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAuEIQJCACEBIAJQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIAuEUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyALQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIGG3kgBkEGdK18pyIGQQ9rEIsDQRAgBmshBiAFKQNYIg1CIIghDiAFKQNQIQELIAJC////////P1YNACAFQUBrIAMgDCADIAwgDFAiCBt5IAhBBnStfKciCEEPaxCLAyAGIAhrQRBqIQYgBSkDSCEMIAUpA0AhAwsgA0IPhiILQoCA/v8PgyICIAFCIIgiBH4iECALQiCIIhMgAUL/////D4MiAX58Ig9CIIYiESABIAJ+fCILIBFUrSACIA1C/////w+DIg1+IhUgBCATfnwiESAMQg+GIANCMYiEIhJC/////w+DIgMgAX58IhQgDyAQVK1CIIYgD0IgiIR8Ig8gAiAOQoCABIQiDH4iFiANIBN+fCIOIBJCIIhCgICAgAiEIgIgAX58IhAgAyAEfnwiEkIghnwiF3whASAHIAlqIAZqQf//AGshBgJAIAIgBH4iGCAMIBN+fCIEIBhUrSAEIAQgAyANfnwiBFatfCACIAx+fCAEIAQgESAVVK0gESAUVq18fCIEVq18IAMgDH4iAyACIA1+fCICIANUrUIghiACQiCIhHwgBCACQiCGfCICIARUrXwgAiACIBAgElatIA4gFlStIA4gEFatfHxCIIYgEkIgiIR8IgJWrXwgAiACIA8gFFStIA8gF1atfHwiAlatfCIEQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIAtCAYYhCyADIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQYABTwRAQgAhAQwDCyAFQTBqIAsgASAGQf8AaiIGEIsDIAVBIGogAiAEIAYQiwMgBUEQaiALIAEgBxCSAyAFIAIgBCAHEJIDIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAELIARC////////P4MgBq1CMIaECyAKhCEKIAtQIAFCAFkgAUKAgICAgICAgIB/URtFBEAgCiACQgF8IgEgAlStfCEKDAELIAsgAUKAgICAgICAgIB/hYRQRQRAIAIhAQwBCyAKIAIgAkIBg3wiASACVK18IQoLIAAgATcDACAAIAo3AwggBUHgAGokAAt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALRQEBfyMAQRBrIgUkACAFIAEgAiADIARCgICAgICAgICAf4UQigMgBSkDACEBIAAgBSkDCDcDCCAAIAE3AwAgBUEQaiQAC9MDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEIsDIAQgACACQYH4ACAFaxCSAyAEKQMIQgSGIAQpAwAiAEI8iIQhAiAEKQMQIAQpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILIARBIGokACACIAFCgICAgICAgICAf4OEvwu2AwIDfwF+IwBBIGsiAyQAAkAgAUL///////////8AgyIFQoCAgICAgMDAP30gBUKAgICAgIDAv8AAfVQEQCABQhmIpyEEIABQIAFC////D4MiBUKAgIAIVCAFQoCAgAhRG0UEQCAEQYGAgIAEaiECDAILIARBgICAgARqIQIgACAFQoCAgAiFhEIAUg0BIAIgBEEBcWohAgwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCGYinQf///wFxQYCAgP4HciECDAELQYCAgPwHIQIgBUL///////+/v8AAVg0AQQAhAiAFQjCIpyIEQZH+AEkNACADQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBSAEQYH+AGsQiwMgAyAAIAVBgf8AIARrEJIDIAMpAwgiAEIZiKchAiADKQMAIAMpAxAgAykDGIRCAFKthCIFUCAAQv///w+DIgBCgICACFQgAEKAgIAIURtFBEAgAkEBaiECDAELIAUgAEKAgIAIhYRCAFINACACQQFxIAJqIQILIANBIGokACACIAFCIIinQYCAgIB4cXK+CzwAIAAgASACAn8gASAAa0ECdSEAQQAhAQNAIABBAk4EQCAAQQF2IQAgAUEBaiEBDAELCyABQQF0CxCZAwvNCQEHfwNAIAFBBGshCANAIAAhBANAAkACfwJAAkACQAJAAkACQAJAIAEgBGsiAEECdSIFDgYICAAEAQIDCyABQQRrIgAoAgAgBCgCAE8NByAEKAIAIQEgBCAAKAIANgIAIAAgATYCAA8LIAQgBEEEaiAEQQhqIAFBBGsQmgMaDwsgBCAEQQRqIARBCGogBEEMaiABQQRrEJsDGg8LIABB+wBMBEAgASEDIwBBEGsiBSQAIAQgBEEEaiAEQQhqIgIQnAMaIARBDGohAQNAIAEgA0cEQCABKAIAIAIoAgBJBEAgBSABKAIANgIMIAEhAANAAkAgACACIgAoAgA2AgAgACAERgRAIAQhAAwBCyAFKAIMIABBBGsiAigCAEkNAQsLIAAgBSgCDDYCAAsgASICQQRqIQEMAQsLIAVBEGokAA8LIANFBEACQCABIgAgBEYNAAJAIAAgBGsiAkEFSA0AIAJBAnUiA0ECa0ECbSECA0AgAkEASA0BIAQgAyAEIAJBAnRqEJ4DIAJBAWshAgwACwALIAAgBGtBAnUhAgNAIAAgAUYEQCAAIARrQQJ1IQEDQCABQQFKBEAgAUECTgRAIAQoAgAhAiAEIABBBGsiAygCADYCACADIAI2AgAgBCABQQFrIAQQngMLIAFBAWshASAAQQRrIQAMAQsLDAILIAEoAgAgBCgCAEkEQCABKAIAIQMgASAEKAIANgIAIAQgAzYCACAEIAIgBBCeAwsgAUEEaiEBDAALAAsPCyAEIAVBAm1BAnRqIQYCfyAAQZ0fTwRAIAQgBCAFQQRtQQJ0IgBqIAYgACAGaiAIEJsDDAELIAQgBiAIEJwDCyEJIANBAWshAyAIIQAgBCgCACAGKAIATwRAA0AgAEEEayIAIARGBEAgBEEEaiEFIAQoAgAgCCgCAEkNBQNAIAUgCEYNCCAEKAIAIAUoAgBJBEAgBSgCACEAIAUgCCgCADYCACAIIAA2AgAgBUEEaiEFDAcFIAVBBGohBQwBCwALAAsgACgCACAGKAIATw0ACyAEKAIAIQUgBCAAKAIANgIAIAAgBTYCACAJQQFqIQkLIARBBGoiBSAATw0BA0AgBSIHQQRqIQUgBygCACAGKAIASQ0AA0AgAEEEayIAKAIAIAYoAgBPDQALIAAgB0kEQCAHIQUMAwUgBygCACEKIAcgACgCADYCACAAIAo2AgAgACAGIAYgB0YbIQYgCUEBaiEJDAELAAsACyAEIARBBGogAUEEaxCcAxoMAwsCQCAFIAZGDQAgBigCACAFKAIATw0AIAUoAgAhACAFIAYoAgA2AgAgBiAANgIAIAlBAWohCQsgCUUEQCAEIAUQnQMhByAFQQRqIgAgARCdAwRAIAUhASAEIQAgB0UNBwwEC0ECIAcNAhoLIAUgBGsgASAFa0gEQCAEIAUgAiADEJkDIAVBBGohAAwFCyAFQQRqIAEgAiADEJkDIAUhASAEIQAMBQsgBSAIIgZGDQEDfyAFIgBBBGohBSAEKAIAIAAoAgBPDQADQCAEKAIAIAZBBGsiBigCAEkNAAsgACAGTwR/QQQFIAAoAgAhByAAIAYoAgA2AgAgBiAHNgIADAELCwshBSAAIQQgBUECaw4DAgABAAsLCwsLlQEBAn8gACABIAIQnAMhBCADKAIAIAIoAgBJBH8gAigCACEFIAIgAygCADYCACADIAU2AgAgAigCACABKAIATwRAIARBAWoPCyABKAIAIQMgASACKAIANgIAIAIgAzYCACABKAIAIAAoAgBPBEAgBEECag8LIAAoAgAhAiAAIAEoAgA2AgAgASACNgIAIARBA2oFIAQLC8MBAQJ/IAAgASACIAMQmgMhBSAEKAIAIAMoAgBJBH8gAygCACEGIAMgBCgCADYCACAEIAY2AgAgAygCACACKAIATwRAIAVBAWoPCyACKAIAIQQgAiADKAIANgIAIAMgBDYCACACKAIAIAEoAgBPBEAgBUECag8LIAEoAgAhAyABIAIoAgA2AgAgAiADNgIAIAEoAgAgACgCAE8EQCAFQQNqDwsgACgCACECIAAgASgCADYCACABIAI2AgAgBUEEagUgBQsL0AEBAn8gASgCACIEIAIoAgBLIQMCfwJAIAQgACgCAE8EQEEAIANFDQIaIAEoAgAhAyABIAIoAgA2AgAgAiADNgIAQQEgASgCACAAKAIATw0CGiAAKAIAIQIgACABKAIANgIAIAEgAjYCAAwBCyADBEAgACgCACEBIAAgAigCADYCACACIAE2AgBBAQ8LIAAoAgAhAyAAIAEoAgA2AgAgASADNgIAQQEgAigCACABKAIATw0BGiABKAIAIQAgASACKAIANgIAIAIgADYCAAtBAgsLzQIBBn8jAEEQayIEJABBASEGAkACQAJAAkACQAJAIAEgAGtBAnUOBgUFAAECAwQLIAFBBGsiASgCACAAKAIATw0EIAAoAgAhAiAAIAEoAgA2AgAgASACNgIADAQLIAAgAEEEaiABQQRrEJwDGgwDCyAAIABBBGogAEEIaiABQQRrEJoDGgwCCyAAIABBBGogAEEIaiAAQQxqIAFBBGsQmwMaDAELIAAgAEEEaiAAQQhqIgUQnAMaIABBDGohAwNAIAEgA0YNAQJAIAMoAgAgBSgCAEkEQCAEIAMoAgA2AgwgAyECA0ACQCACIAUiAigC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IAIgASADbEYNAiACIABB0AFqIgFuIgMgAUkNBCAAQdIBaiEAIAIgASADbEcNAAsMAQsgAiAAQQJ0QdCZAWooAgAiAW4iAyABSQ0CIABBAWohACACIAEgA2xHDQELC0EAIAVBAWoiACAAQTBGIgAbIQUgACAGaiIGQdIBbCECDAELCyAEIAI2AgwLIARBEGokACACC4EBAQR/IwBBEGsiBSQAIwBBEGsiAyQAIAEgAGtBAnUhAQNAIAEEQCADIAA2AgwgAyADKAIMIAFBAXYiBEECdGo2AgwgASAEQX9zaiAEIAMoAgwiBCgCACACKAIASSIGGyEBIARBBGogACAGGyEADAELCyADQRBqJAAgBUEQaiQAIAALBQAQAgAL4wEBBH8jAEEgayIEJAAgBCABNgIQIAQgAiAAKAIwIgNBAEdrNgIUIAAoAiwhBSAEIAM2AhwgBCAFNgIYAkACQCAAIAAoAjwgBEEQakECIARBDGoQCCIDBH9B2MYCIAM2AgBBfwVBAAsEf0EgBSAEKAIMIgNBAEoNAUEgQRAgAxsLIAAoAgByNgIADAELIAQoAhQiBSADIgZPDQAgACAAKAIsIgM2AgQgACADIAYgBWtqNgIIIAAoAjAEQCAAIANBAWo2AgQgASACakEBayADLQAAOgAACyACIQYLIARBIGokACAGC/ABAQN/IABFBEBByMICKAIABEBByMICKAIAEKMDIQELQaDAAigCAARAQaDAAigCABCjAyABciEBC0HUxgIoAgAiAARAA0AgACgCTBogACgCFCAAKAIcRwRAIAAQowMgAXIhAQsgACgCOCIADQALCyABDwsgACgCTEEATiECAkACQCAAKAIUIAAoAhxGDQAgAEEAQQAgACgCJBEEABogACgCFA0AQX8hAQwBCyAAKAIEIgEgACgCCCIDRwRAIAAgASADa6xBASAAKAIoERUAGgtBACEBIABBADYCHCAAQgA3AxAgAEIANwIEIAJFDQALIAELBwAgABDjAwsNACAAEOMDGiAAEIYDCzgBAn8gAEHYnAE2AgAgACgCBCIBIAEoAgRBAWsiAjYCBCACQX9GBEAgASABKAIAKAIIEQIACyAACw0AIAAQpgMaIAAQhgMLKwAgAEHYnAE2AgAgAEEEahC1BRogAEIANwIYIABCADcCECAAQgA3AgggAAsEACAACxAA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IGprQZ8BSg0AIAAgA0EEajYCHCADIAAoAhg2AgALIAAgAiAAKALMASAEELIEIAApAwAhBiAFIAApAwg3AwggBSAGNwMAIABB4AFqIABBIGogACgCHCAEEKIEIABBmAJqIABBkAJqELwDBEAgBCAEKAIAQQJyNgIACyAAKAKYAiECIAEQogYaIABB4AFqEKIGGiAAQaACaiQAIAILsgICBH4FfyMAQSBrIggkAAJAAkACQCABIAJHBEBB2MYCKAIAIQxB2MYCQQA2AgAjAEEQayIJJAAQtAQaIwBBEGsiCiQAIwBBEGsiCyQAIAsgASAIQRxqQQIQkAQgCykDACEEIAogCykDCDcDCCAKIAQ3AwAgC0EQaiQAIAopAwAhBCAJIAopAwg3AwggCSAENwMAIApBEGokACAJKQMAIQQgCCAJKQMINwMQIAggBDcDCCAJQRBqJAAgCCkDECEEIAgpAwghBUHYxgIoAgAiAUUNASAIKAIcIAJHDQIgBSEGIAQhByABQcQARw0DDAILIANBBDYCAAwCC0HYxgIgDDYCACAIKAIcIAJGDQELIANBBDYCACAGIQUgByEECyAAIAU3AwAgACAENwMIIAhBIGokAAvtBAECfyMAQZACayIAJAAgACACNgKAAiAAIAE2AogCIABB0AFqENcDIQcgAEEQaiIGIAMoAhwiATYCACABIAEoAgRBAWo2AgQgBhC4AyIBQeDAAUH6wAEgAEHgAWogASgCACgCIBEHABogBigCACIBIAEoAgRBAWsiAjYCBCACQX9GBEAgASABKAIAKAIIEQIACyAAQcABahDXAyICIAItAAtBB3YEfyACKAIIQf////8HcUEBawVBCgsQ2gMgAAJ/IAItAAtBB3YEQCACKAIADAELIAILIgE2ArwBIAAgBjYCDCAAQQA2AggDQAJAIABBiAJqIABBgAJqELkDRQ0AIAAoArwBAn8gAi0AC0EHdgRAIAIoAgQMAQsgAi0ACwsgAWpGBEACfyACLQALQQd2BEAgAigCBAwBCyACLQALCyEDIAICfyACLQALQQd2BEAgAigCBAwBCyACLQALC0EBdBDaAyACIAItAAtBB3YEfyACKAIIQf////8HcUEBawVBCgsQ2gMgACADAn8gAi0AC0EHdgRAIAIoAgAMAQsgAgsiAWo2ArwBCyAAQYgCahC6A0EQ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AgwBCwsQoQMACxChAwALIABBmAJqIABBkAJqELwDBEAgBSAFKAIAQQJyNgIACyAAKAKYAiECIAAoApABIgEgASgCBEEBayIDNgIEIANBf0YEQCABIAEoAgAoAggRAgALIAcoAgAhASAHQQA2AgAgAQRAIAEgBygCBBECAAsgAEGgAmokACACC6YVAQp/IwBBsARrIgskACALIAo2AqQEIAsgATYCqAQCQCAAIAtBqARqELwDBEAgBSAFKAIAQQRyNgIAQQAhAAwBCyALQZACNgJoIAsgC0GIAWogC0GQAWogC0HoAGoiARCcBCIPKAIAIgo2AoQBIAsgCkGQA2o2AoABIAEQ1wMhESALQdgAahDXAyEOIAtByABqENcDIQ0gC0E4ahDXAyEMIAtBKGoQ1wMhECMAQRBrIgEkACALAn8gAgRAIAEgAxCUBSICIAIoAgAoAiwRAAAgCyABKAIANgB4IAEgAiACKAIAKAIgEQAAIAwgARDYAyABEKIGGiABIAIgAigCACgCHBEAACANIAEQ2AMgARCiBhogCyACIAIoAgAoAgwRAQA6AHcgCyACIAIoAgAoAhARAQA6AHYgASACIAIoAgAoAhQRAAAgESABENgDIAEQogYaIAEgAiACKAIAKAIYEQAAIA4gARDYAyABEKIGGiACIAIoAgAoAiQRAQAMAQsgASADEJUFIgIgAigCACgCLBEAACALIAEoAgA2AHggASACIAIoAgAoAiARAAAgDCABENgDIAEQogYaIAEgAiACKAIAKAIcEQAAIA0gARDYAyABEKIGGiALIAIgAigCACgCDBEBADoAdyALIAIgAigCACgCEBEBADoAdiABIAIgAigCACgCFBEAACARIAEQ2AMgARCiBhogASACIAIoAgAoAhgRAAAgDiABENgDIAEQogYaIAIgAigCACgCJBEBAAs2AiQgAUEQaiQAIAkgCCgCADYCACAEQYAEcSISQQl2IRNBACEDQQAhAQNAIAEhAgJAAkACQAJAIANBBEYNACAAIAtBqARqELkDRQ0AQQAhCgJAAkACQAJAAkACQCALQfgAaiADaiwAAA4FAQAEAwUJCyADQQNGDQcgABC6AyIBQQBOBH8gBygCCCABQf8BcUECdGooAgBBAXEFQQALBEAgC0EYaiAAEJAFIBAgCywAGBCoBgwCCyAFIAUoAgBB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IA8oAgAgCygChAFGDQBBACEAIAtBADYCGCARIA8oAgAgCygChAEgC0EYahCiBCALKAIYBEAgBSAFKAIAQQRyNgIADAELQQEhAAsgEBCiBhogDBCiBhogDRCiBhogDhCiBhogERCiBhogDygCACEBIA9BADYCACABBEAgASAPKAIEEQIACwwDCyACIQELIANBAWohAwwACwALIAtBsARqJAAgAAslAQF/IAEoAgAQvwNBGHRBGHUhAiAAIAEoAgA2AgQgACACOgAAC+MBAQZ/IwBBEGsiBSQAIAAoAgQhAwJ/IAIoAgAgACgCAGsiBEH/////B0kEQCAEQQF0DAELQX8LIgRBASAEGyEEIAEoAgAhByAAKAIAIQggA0GQAkYEf0EABSAAKAIACyAEEIcDIgYEQCADQZACRwRAIAAoAgAaIABBADYCAAsgBUGPAjYCBCAAIAVBCGogBiAFQQRqEJwEIgMQlwUgAygCACEGIANBADYCACAGBEAgBiADKAIEEQIACyABIAAoAgAgByAIa2o2AgAgAiAEIAAoAgBqNgIAIAVBEGokAA8LEKEDAAvmAQEGfyMAQRBrIgUkACAAKAIEIQMCfyACKAIAIAAoAgBrIgRB/////wdJBEAgBEEBdAwBC0F/CyIEQQQgBBshBCABKAIAIQcgACgCACEIIANBkAJGBH9BAAUgACgCAAsgBBCHAyIGBEAgA0GQAkcEQCAAKAIAGiAAQQA2AgALIAVBjwI2AgQgACAFQQhqIAYgBUEEahCcBCIDEJcFIAMoAgAhBiADQQA2AgAgBgRAIAYgAygCBBECAAsgASAAKAIAIAcgCGtqNgIAIAIgACgCACAEQXxxajYCACAFQRBqJAAPCxChAwAL6gYBBH8jAEGgAWsiACQAIAAgAjYCkAEgACABNgKYASAAQZACNgIUIABBGGogAEEgaiAAQRRqIggQnAQhCSAAQRBqIgcgBCgCHCIBNgIAIAEgASgCBEEBajYCBCAHELgDIQEgAEEAOgAPIABBmAFqIAIgAyAHIAQoAgQgBSAAQQ9qIAEgCSAIIABBhAFqEI8FBEAjAEEQayICJAACQCAGLQALQQd2BEAgBigCACEDIAJBADoADyADIAItAA86AAAgBkEANgIEDAELIAJBADoADiAGIAItAA46AAAgBkEAOgALCyACQRBqJAAgAC0ADwRAIAYgAUEtIAEoAgAoAhwRAwAQqAYLIAFBMCABKAIAKAIcEQMAIQEgCSgCACECIAAoAhQiCEEBayEDIAFB/wFxIQEDQAJAIAIgA08NACACLQAAIAFHDQAgAkEBaiECDAELCyMAQRBrIgEkAAJ/IAYtAAtBB3YEQCAGKAIEDAELIAYtAAsLIQcgBiIDLQALQQd2BH8gAygCCEH/////B3FBAWsFQQoLIQQCQCAIIAJrIgpFDQACfyADLQALQQd2BEAgBigCAAwBCyAGCyACTQR/An8gBi0AC0EHdgRAIAYoAgAMAQsgBgsCfyAGLQALQQd2BEAgBigCBAwBCyAGLQALC2ogAk8FQQALRQRAIAogBCAHa0sEQCAGIAQgByAKaiAEayAHIAdBABCjBgsCfyAGLQALQQd2BEAgBigCAAwBCyAGCyAHaiEEA0AgAiAIRwRAIAQgAi0AADoAACACQQFqIQIgBEEBaiEEDAELCyABQQA6AA8gBCABLQAPOgAAIAcgCmohAgJAIAYtAAtBB3YEQCAGIAI2AgQMAQsgBiACOgALCwwBCyMAQRBrIgMkACABIAIgCBDZAyADQRBqJAAgBgJ/IAEtAAtBB3YEQCABKAIADAELIAELAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0ACwsQpwYaIAEQogYaCyABQRBqJAALIABBmAFqIABBkAFqELwDBEAgBSAFKAIAQQJyNgIACyAAKAKYASECIAAoAhAiASABKAIEQQFrIgM2AgQgA0F/RgRAIAEgASgCACgCCBECAAsgCSgCACEBIAlBADYCACABBEAgASAJKAIEEQIACyAAQaABaiQAIAILCwAgAEHE5QIQmwQLCwAgAEG85QIQmwQLNAEBfyMAQRBrIgIkACACIAAoAgA2AgggAiACKAIIIAFqNgIIIAIoAgghACACQRBqJAAgAAs9AQJ/IAEoAgAhAiABQQA2AgAgAiEDIAAoAgAhAiAAIAM2AgAgAgRAIAIgACgCBBECAAsgACABKAIENgIEC+wEAQJ/IwBB8ARrIgAkACAAIAI2AuAEIAAgATYC6AQgAEGQAjYCECAAQcgBaiAAQdABaiAAQRBqEJwEIQcgAEHAAWoiCCAEKAIcIgE2AgAgASABKAIEQQFqNgIEIAgQ0AMhASAAQQA6AL8BAkAgAEHoBGogAiADIAggBCgCBCAFIABBvwFqIAEgByAAQcQBaiAAQeAEahCZBUUNACAAQfwjKAAANgC3ASAAQfUjKQAANwOwASABIABBsAFqIABBugFqIABBgAFqIAEoAgAoAjARBwAaIABBjwI2AhAgAEEIakEAIABBEGoiBBCcBCEBAkAgACgCxAEgBygCAGtBiQNOBEAgACgCxAEgBygCAGtBAnVBAmoQhQMhAyABKAIAIQIgASADNgIAIAIEQCACIAEoAgQRAgALIAEoAgBFDQEgASgCACEECyAALQC/AQRAIARBLToAACAEQQFqIQQLIAcoAgAhAgNAIAAoAsQBIAJNBEACQCAEQQA6AAAgACAGNgIAIABBEGogABCKBEEBRw0AIAEoAgAhAiABQQA2AgAgAgRAIAIgASgCBBECAAsMBAsFIAQgAEGwAWogAEGAAWoiAyADQShqIAIQyQQgA2tBAnVqLQAAOgAAIARBAWohBCACQQRqIQIMAQsLEKEDAAsQoQMACyAAQegEaiAAQeAEahDTAwRAIAUgBSgCAEECcjYCAAsgACgC6AQhAiAAKALAASIBIAEoAgRBAWsiAzYCBCADQX9GBEAgASABKAIAKAIIEQIACyAHKAIAIQEgB0EANgIAIAEEQCABIAcoAgQRAgALIABB8ARqJAAgAgvGFwEKfyMAQbAEayILJAAgCyAKNgKkBCALIAE2AqgEAkAgACALQagEahDTAwRAIAUgBSgCAEEEcjYCAEEAIQAMAQsgC0GQAjYCYCALIAtBiAFqIAtBkAFqIAtB4ABqIgEQnAQiDygCACIKNgKEASALIApBkANqNgKAASABENcDIREgC0HQAGoQ1wMhDiALQUBrENcDIQ0gC0EwahDXAyEMIAtBIGoQ1wMhECMAQRBrIgEkACALAn8gAgRAIAEgAxCcBSICIAIoAgAoAiwRAAAgCyABKAIANgB4IAEgAiACKAIAKAIgEQAAIAwgARCdBSABEKoGGiABIAIgAigCACgCHBEAACANIAEQnQUgARCqBhogCyACIAIoAgAoAgwRAQA2AnQgCyACIAIoAgAoAhARAQA2AnAgASACIAIoAgAoAhQRAAAgESABENgDIAEQogYaIAEgAiACKAIAKAIYEQAAIA4gARCdBSABEKoGGiACIAIoAgAoAiQRAQAMAQsgASADEJ4FIgIgAigCACgCLBEA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LQALC2pqQQJqCyIOQeUATwRAIA4QhQMhDiALKAIAIQIgCyAONgIAIAIEQCACIAsoAgQRAgALIAsoAgAiAkUNAQsgAiAAQSRqIABBIGogAygCBCAMIAkgDGogESAPIABB0AFqIAAsAM8BIAAsAM4BIBAgByAIIAAoApwBEKIFIAEgAiAAKAIkIAAoAiAgAyAEEK0BIQIgCygCACEBIAtBADYCACABBEAgASALKAIEEQIACyAIEKIGGiAHEKIGGiAQEKIGGiAAKALYASIBIAEoAgRBAWsiAzYCBCADQX9GBEAgASABKAIAKAIIEQIACyAKKAIAIQEgCkEANgIAIAEEQCABIAooAgQRAgALIA0oAgAhASANQQA2AgAgAQRAIAEgDSgCBBECAAsgAEHQA2okACACDwsQoQMAC9EDAQF/IwBBEGsiCiQAIAkCfyAABEAgAhCUBSEAAkAgAQRAIAogACAAKAIAKAIsEQAAIAMgCigCADYAACAKIAAgACgCACgCIBEAAAwBCyAKIAAgACgCACgCKBEAACADIAooAgA2AAAgCiAAIAAoAgAoAhwRAAALIAggChDYAyAKEKIGGiAEIAAgACgCACgCDBEBADoAACAFIAAgACgCACgCEBEBADoAACAKIAAgACgCACgCFBEAACAGIAoQ2AMgChCiBhogCiAAIAAoAgAoAhgRAAAgByAKENgDIAoQogYaIAAgACgCACgCJBEBAAwBCyACEJUFIQACQCABBEAgCiAAIAAoAgAoAiwRAAAgAyAKKAIANgAAIAogACAAKAIAKAIgEQAADAELIAogACAAKAIAKAIoEQAAIAMgCigCADYAACAKIAAgACgCACgCHBEAAAsgCCAKENgDIAoQogYaIAQgACAAKAIAKAIMEQEAOgAAIAUgACAAKAIAKAIQEQEAOgAAIAogACAAKAIAKAIUEQAAIAYgChDYAyAKEKIGGiAKIAAgACgCACgCGBEAACAHIAoQ2AMgChCiBhogACAAKAIAKAIkEQEACzYCACAKQRBqJAALzQcBCn8jAEEQayITJAAgAiAANgIAIANBgARxIRYDQCAUQQRGBEACfyANLQALQQd2BEAgDSgCBAwBCyANLQALC0EBSwRAIBMgDRDLBDYCCCACIBNBCGpBARCWBSANEMwEIAIoAgAQowU2AgALIANBsAFxIgNBEEcE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EGsiAyQAIAMgATYCDAJAAkACQCAALQALQQd2RQRAQQEhAiAALQALIgFBAUYNASAAIgIgAUEBajoACwwDCyAAKAIEIgEgACgCCEH/////B3FBAWsiAkcNAQsgACACQQEgAiACEKsGIAIhAQsgACgCACECIAAgAUEBajYCBAsgAiABQQJ0aiIAIAMoAgw2AgAgA0EANgIIIAAgAygCCDYCBCADQRBqJAALEABBzMICKAIAEQ0AEKEDAAstACACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAAoAgQgASgCBBCDBEULogEBAn8jAEFAaiIDJAACf0EBIAAgAUEAEK4GDQAaQQAgAUUNABpBACABQcz3ARCwBiIBRQ0AGiADQQhqIgRBBHJBAEE0EN4CGiADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASAEIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAu7AgEDfyMAQUBqIgIkACAAKAIAIgNBBGsoAgAhBCADQQhrKAIAIQMgAkIANwMgIAJCADcDKCACQgA3AzAgAkIANwA3IAJCADcDGCACQQA2AhQgAkGc9wE2AhAgAiAANgIMIAIgATYCCCAAIANqIQBBACEDAkAgBCABQQAQrgYEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEMACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEIAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADC10BAX8gACgCECIDRQRAIABBATYCJCAAIAI2AhggACABNgIQDwsCQCABIANGBEAgACgCGEECRw0BIAAgAjYCGA8LIABBAToANiAAQQI2AhggACAAKAIkQQFqNgIkCwsaACAAIAEoAghBABCuBgRAIAEgAiADELEGCwszACAAIAEoAghBABCuBgRAIAEgAiADELEGDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALUgEBfyAAKAIEIQQgACgC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BiABKAJIIAEoAkxGDQIgASABQUBrQeUTEM4GKQIANwMAIAFByABqIAEQ2gYEQCABQThqIAFByABqQQkQqwcgAUIANwIwIAEoAjghAiABIAA2AiAgACgCACEDIAFBAToAKCABIAM2AiQgACACNgIAIAEoAjwhAiABIABBBGo2AhAgACgCBCEDIAFBAToAGCABIAM2AhQgACACNgIEIAFBCGogABDiBiABIAEpAwg3AzAgAS0AGARAIAEoAhAgASgCFDYCAAsgAS0AKARAIAEoAiAgASgCJDYCAAtBACECIAEoAjAgASgCNEYNAyABIAAQ6wYiAjYCICACRQ0CIwBBEGsiAyQAIABBmANqQRQQ9AYhACABKAIgIQQgAyABKQIwIgY3AwAgAyAGNwMIIABBAToAByAAQQE6AAYgAEEBOgAFIABBCjoABCAAQcz9ATYCACAAIgIgBDYCCCACQcS0AjYCACACIAMpAgA3AgwgA0EQaiQADAMLIAFBADYCICAAKAIAIgMgACgCBEcEfyADLAAABUEAC0H/AXFByQBGBEAgASAAQQAQ5wYiAzYCICADRQ0DCyABIAAQ6wYiAjYCECACBH8jAEEQayICJAAgAEGYA2pBGBD0BiEAIAEoAhAhAyACIAEpAkgiBjcDCCABKAIgIQQgAiAGNwMAIABBAToAByAAQQE6AAYgAEEBOgAFIABBAjoABCAAQcz9ATYCACAAIAM2AgggAEGwtQI2AgAgAikCACEGIAAgBDYCFCAAIAY3AgwgAkEQaiQAIAAFQQALIQIMAgsgASAAEPoGIgM2AiAgASAAENQGIgI2AhAgAkUNACADRQ0BIABBmANqQRAQ9AYhACABKAIgIQQgASgCECIDLQAFIQIgAy0ABiEFIAAgAy0ABzoAByAAIAU6AAYgACACOgAFIABBAzoABCAAQcz9ATYCACAAIgIgAzYCDCACIAQ2AgggAkGgtgI2AgAMAQtBACECCyABQdAAaiQAIAILkAIBAX8gACgCACAAQQxqRiECAkAgASgCACABQQxqRgRAIAJFBEAgACgCABCGAyAAIABBHGo2AgggACAAQQxqIgI2AgQgACACNgIACyABKAIAIAEoAgQgACgCABDzBiAAIAAoAgAgASgCBCABKAIAa0ECdUECdGo2AgQMAQsgAgRAIAAgASgCADYCACAAIAEo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ASADKALAAiEEIABBAToAByAAQQE6AAYgAEEBOgAFIABBMToABCAAQcz9ATYCACAAIgIgBDYCDCACIAE2AgggAkHsmgI2AgAMEQsgACABQQJqNgIAIABBCGoiASgCBCABKAIAa0ECdSEEA0AgAEHFABDRBkUEQCADIAAQlwciBTYC4AQgBUUNEiABIANB4ARqEN4GDAELCyADQeAEaiAAIAQQ3wYjAEEQayIBJAAgAEGYA2pBFBD0BiEAIAEgAykC4AQiBzcDACABIAc3AwggAEEAIAEQ2AchAiABQRBqJAAMEAsCQAJAAkACQCABLAABIgRB8wBrDgIBAwALIARB0wBGDQEgBEHlAEcNEiAAIAFBAmo2AgAgAyADQYgEakHjIhDOBikCADcDeCAAIANB+ABqEJIHIQIMEgsgACABQQJqNgIAIAMgA0GABGpB0yMQzgYpAgA3A4ABIAAgA0GAAWoQkgchAgwRCyAAIAFBAmo2AgAgAyADQfgDakHiIhDOBikCADcDiAEgACADQYgBahCSByECDBALIAAgAUECajYCACADIANB8ANqQdojEM4GKQIANwOQASAAIANBkAFqEJIHIQIMDwsCQAJAAkACQAJAAkAgASwAASIEQekAaw4FARQUAwUACwJAIARByQBrDgQCFBQEAAsgBEHjAEcNEyAAIAFBAmo2AgAjAEEQayIBJAAgASAAENQGIgI2AgwCfwJAIAJFDQAgASAAEPAGIgI2AgggAkUNACABIABBARDSBkEAIABBxQAQ0QZFDQEaIwBBEGsiAiQAIABBmANqQRgQ9AYhACABKAIIIQQgASgCDCEFIAIgASkCACIHNwMAIAIgBzcDCCAAQQE6AAcgAEEBOgAGIABBAToABSAAQT86AAQgAEHM/QE2AgAgACAENgIMIAAgBTYCCCAAQZyeAjYCACAAIAIpAgA3AhAgAkEQaiQAIAAMAQtBAAshAiABQRBqJAAMEwsgACABQQJqNgIAIAMgA0HoA2pB7SQQzgYpAgA3A5gBIAAgA0GYAWoQkgchAgwSCyAAIAFBAmo2AgAgAyADQeADakH5IhDOBikCADcDoAEgACADQaABahCSByECDBELIAAgAUECajYCACADIANB2ANqQaklEM4GKQIANwOoASAAIANBqAFqEJIHIQIMEAsgACABQQJqNgIAIAMgA0HQA2pBjyMQzgYpAgA3A7ABIAAgA0GwAWoQkgchAgwPCyAAIAFBAmo2AgAgAEHfABDRBgRAIAMgA0HIA2pB7CQQzgYpAgA3A7gBIAAgA0G4AWoQkwchAgwPCyADIAAQ8AYiAjYC4AQgAkUNDSAAIANB4ARqQewkEJgHIQIMDgsCQAJAAkACQAJAAkAgASwAASIEQeEAaw4HARMTEwITAwALIARB9ABrDgUDEhIABBILIwBB8ABrIgEkACABIAFB4ABqQdMSEM4GKQIANwMgIAEgACABQSBqEM8GOgBvIAEgACgCBCAAKAIAIgRrQQFLBH8gBCwAAQVBAAtB/wFxQeEARjoAXyABIAFB0ABqQaEQEM4GKQIANwMYAkAgACABQRhqEM8GRQRAIAEgAUHIAGpB6R0QzgYpAgA3AxAgACABQRBqEM8GRQ0BCyAAQQhqIgQiAigCBCACKAIAa0ECdSECAkADQCAAQd8AENEGRQRAIAEgABDwBiIFNgJAIAVFDQIgBCABQUBrEN4GDAELCyABQUBrIAAgAhDfBiABIAAQ1AYiBTYCPEEAIQIgBUUNASABIAFBMGpBshgQzgYpAgA3AwggACABQQhqEM8GBEAgBCgCBCAEKAIAa0ECdSEFA0AgAEHFABDRBkUEQCABIAAQ8AYiBjYCKCAGRQ0EIAQgAUEoahDeBgwBCwsgAUEoaiICIAAgBRDfBiAAIAFBQGsgAUE8aiACIAFB7wBqIAFB3wBqEKYHIQIMAgsgAEHFABDRBkUNASAAIAFBQGsgAUE8agJ/IAFBKGoiAEIANwIAIAALIAFB7wBqIAFB3wBqEKYHIQIMAQtBACECCyABQfAAaiQADBELIAAgAUECajYCACADIANBwANqQbAjEM4GKQIANwPAASAAIANBwAFqEJIHIQIMEAsgACABQQJqNgIAIAMgA0G4A2pB7SQQzgYpAgA3A8gBIAAgA0HIAWoQkwchAgwPCyAAIAFBAmo2AgAgAyADQbADakG4JxDOBikCADcD0AEgACADQdABahCTByECDA4LIAAgAUECajYCACADIAAQ8AYiAjYC4AQgAkUNDCMAQSBrIgEkACAAQZgDakEcEPQGIQAgAUEYakGOJhDOBiECIAMoAuAEIQQgAUEQakHgJRDOBiEFIAEgAikCADcDCCABIAUpAgA3AwAgACABQQhqIAQgARDdByECIAFBIGokAAwNCyABLAABIgRB7gBrDgUAAQwMAgMLIAAQmQchAgwLCyAAIAFBAmo2AgAgAyADQagDakHcDhDOBikCADcD2AEgACADQdgBahCSByECDAoLIAAgAUECajYCACADIANBoANqQecOEM4GKQIANwPgASAAIANB4AFqEJIHIQIMCQsgBEHSAEcNCCAAIAFBAmo2AgAgAyADQZgDakGVIhDOBikCADcD6AEgACADQegBahCSByECDAgLAkACQAJAAkACQAJAIAEsAAEiBEHsAGsOCQEADQ0DDQ0EBQILIAAgAUECajYCACADIANBkANqQaAlEM4GKQIANwPwASAAIANB8AFqEJIHIQIMDAsgACABQQJqNgIAIAMgA0GIA2pBjCUQzgYpAgA3A/gBIAAgA0H4AWoQkgchAgwLCyAEQcwARw0KIAAgAUECajYCACADIANBgANqQYQjEM4GKQIANwOAAiAAIANBgAJqEJIHIQIMCgsgACABQQJqNgIAIABB3wAQ0QYEQCADIANB+AJqQYslEM4GKQIANwOIAiAAIANBiAJqEJMHIQIMCgsgAyAAEPAGIgI2AuAEIAJFDQggACADQeAEakGLJRCYByECDAkLIAAgAUECajYCACADIANB8AJqQYwlEM4GKQIANwOQAiAAIANBkAJqEJMHIQIMCAsgACABQQJqNgIAIAMgABDwBiICNgLgBCACRQ0GIAMgABDwBiICNgLAAiACRQ0GIAAgA0HgBGpBrCAgA0HAAmoQlgchAgwHCyABLQABQfUARw0GIAAgAUECajYCACADIAAQ8AYiAjYC4AQgAkUNBSADIAAQ8AYiAjYCwAIgAkUNBSADIAAQ8AYiAjYC7AIgAkUNBSAAQZgDakEUEPQGIQAgAygC4AQhASADKALAAiEEIAMoAuwCIQUgAEEBOgAHIABBAToABiAAQQE6AAUgAEEzOgAEIABBzP0BNgIAIAAiAiAFNgIQIAIgBDYCDCACIAE2AgggAkHQoQI2AgAMBgsCQAJAIAEsAAEiBEHNAEcEQCAEQdMARg0CIARB8wBGDQEgBEHtAEcEQCAEQeMARw0JIAAgAUECajYCACADIAAQ1AYiAjYC4AQgAkUNCCADIAAQ8AYiAjYCwAIgAkUNCCMAQRBrIgEkACAAQZgDakEYEPQGIQAgAUEIakGH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ACgCACgCFBEAAAsgAkEQaiQACxYAIAAgASgCDCIAIAAoAgAoAhgRAAALjgEBA38jAEEQayIEJAAgAC0AEEUEQCAEQQhqIgIgAEEQajYCACAALQAQIQMgAkEBOgAFIAIgAzoABCAAQQE6ABAgAiEDAn8gACgCDCICLQAFIgBBAkcEQCAARQwBCyACIAEgAigCACgCABEDAAshAiADLQAFBEAgAygCACADLQAEOgAACwsgBEEQaiQAIAILjgEBA38jAEEQayIEJAAgAC0AEEUEQCAEQQhqIgIgAEEQajYCACAALQAQIQMgAkEBOgAFIAIgAzoABCAAQQE6ABAgAiEDAn8gACgCDCICLQAGIgBBAkcEQCAARQwBCyACIAEgAigCACgCBBEDAAshAiADLQAFBEAgAygCACADLQAEOgAACwsgBEEQaiQAIAILjgEBA38jAEEQayIEJAAgAC0AEEUEQCAEQQhqIgIgAEEQajYCACAALQAQIQMgAkEBOgAFIAIgAzoABCAAQQE6ABAgAiEDAn8gACgCDCICLQAHIgBBAkcEQCAARQwBCyACIAEgAigCACgCCBEDAAshAiADLQAFBEAgAygCACADLQAEOgAACwsgBEEQaiQAIAILeQEDfyMAQRBrIgQkACAALQAQRQRAIARBCGoiAyAAQRBqNgIAIAAtABAhAiADQQE6AAUgAyACOgAEIABBAToAECADIQIgACgCDCIAIAEgACgCACgCDBEDACEAIAItAAUEQCACKAIAIAItAAQ6AAALCyAEQRBqJAAgAAt1AQN/IwBBEGsiBCQAIAAtABBFBEAgBEEIaiIDIABBEGo2AgAgAC0AECECIANBAToABSADIAI6AAQgAEEBOgAQIAMhAiAAKAIMIgAgASAAKAIAKAIQEQAAIAItAAUEQCACKAIAIAItAAQ6AAALCyAEQRBqJAALdQEDfyMAQRBrIgQkACAALQAQRQRAIARBCGoiAyAAQRBqNgIAIAAtABAhAiADQQE6AAUgAyACOgAEIABBAToAECADIQIgACgCDCIAIAEgACgCACgCFBEAACACLQAFBEAgAigCACACLQAEOgAACwsgBEEQaiQAC/8BAQN/IwBBQGoiASQAIAEgAUE4akHlHhDOBikCADcDGAJAIAAgAUEYahDPBgRAIABBzhIQ4QYhAgwBCyABIAFBMGpByhMQzgYpAgA3AxAgACABQRBqEM8GBEAgABD6BhogAUEoaiAAQQAQ0gYgAEHfABDRBkUNASAAIAFBKGoQngchAgwBCyABIAFBIGpBsx8QzgYpAgA3AwggACABQQhqEM8GRQ0AIAFBKGoiAyAAQQAQ0gYgAygCACADKAIERg0AIABB8AAQ0QZFDQAgABD6BhogAUEoaiAAQQAQ0gYgAEHfABDRBkUNACAAIAFBKGoQngchAgsgAUFAayQAIAIL0AECA38BfiMAQRBrIgMkACADIAAQ8AYiAjYCDAJ/AkAgAkUNACADIAAQ8AYiAjYCCCACRQ0AIwBBEGsiAiQAIABBmANqQRgQ9AYhACADKAIMIQQgAiABKQIAIgU3AwggAygCCCEBIAIgBTcDACAAQQE6AAcgAEEBOgAGIABBAToABSAAQTA6AAQgAEHM/QE2AgAgACAENgIIIABB+JACNgIAIAIpAgAhBSAAIAE2AhQgACAFNwIMIAJBEGokACAADAELQQALIQAgA0EQaiQAIAALqgECAn8BfiMAQRBrIgMkACADIAAQ8AYiAjYCDCACBH8jAEEQayICJAAgAEGYA2pBFBD0BiEAIAIgASkCACIENwMIIAMoAgwhASACIAQ3AwAgAEEBOgAHIABBAToABiAAQQE6AAUgAEE8OgAEIABBzP0BNgIAIABB4JECNgIAIAIpAgAhBCAAIAE2AhAgACAENwIIIAJBEGokACAABUEACyEAIANBEGokACAAC34CAX8BfiMAQRBrIgMkACAAQZgDakEUEPQGIQAgASgCACEBIAMgAikCACIENwMAIAMgBDcDCCAAQQE6AAcgAEEBOgAGIABBAToABSAAQTk6AAQgAEHM/QE2AgAgACABNgIIIABBrJMCNgIAIAAgAykCADcCDCADQRBqJAAgAAtpACAAQZgDakEQEPQGIQAgASgCACEBIAItAAAhAiADLQAAIQMgAEEBOgAHIABBAToABiAAQQE6AAUgAEE7OgAEIABBzP0BNgIAIAAgAzoADSAAIAI6AAwgACABNgIIIABB/JQCNgIAIAALVAEBfyMAQRBrIgQkACAAQZgDakEYEPQGIQAgASgCACEBIARBCGogAhDOBiECIAMoAgAhAyAEIAIpAgA3AwAgACABIAQgAxDTByEAIARBEGokACAAC8kDAQR/IwBBEGsi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AgggAEGUmQI2AgAgAAtqACAAQZgDakEUEPQGIQAgASgCACEBIAIoAgAhAiADLQAAIQMgAEEBOgAHIABBAToABiAAQQE6AAUgAEHLADoABCAAQcz9ATYCACAAIAM6ABAgACACNgIMIAAgATYCCCAAQdybAjYCACAAC78BAgF/An4jAEEgayIGJAAgAEGYA2pBIBD0BiEAIAYgASkCACIHNwMYIAIoAgAhASAGIAMpAgAiCDcDECAFLQAAIQIgBC0AACEDIAYgBzcDCCAGIAg3AwAgAEEBOgAHIABBAToABiAAQQE6AAUgAEE6OgAEIABBzP0BNgIAIABBgKACNgIAIAYpAgghByAAIAE2AhAgACAHNwIIIAYpAgAhByAAIAI6AB0gACADOgAcIAAgBzcCFCAGQSBqJAAgAAtYAQJ/IwBBEGsiAiQAIAAgATYCACAAIAEoAtACIAEoAswCa0ECdTYCBCAAQQhqENgGIQEgACgCACEDIAIgATYCDCADQcwCaiACQQxqEN4GIAJBEGokACAAC4YGAgV/AX4jAEGgAWsiASQAIAEgADYCmAEgASABQZABakHQDxDOBikCADcDKAJAIAAgAUEoahDPBgRAIAEgAUGYAWpBABCxByIDNgJIIANFDQEgAEGYA2pBDBD0BiEAIAEoAkghAyAAQQE6AAcgAEEBOgAGIABBADoABSAAQR06AAQgAEHM/QE2AgAgACICIAM2AgggAkGgiAI2AgAMAQsgASABQYgBakHVFhDOBikCADcDIAJAIAAgAUEgahDPBgRAIAEgAUGYAWpBARCxByICNgJIIAJFDQEgASAAENQGIgI2AjggAkUNASAAQZgDakEQEPQGIQAgASgCSCEDIAEoAjghBCAAQQE6AAcgAEEBOgAGIABBADoABSAAQR46AAQgAEHM/QE2AgAgACICIAQ2AgwgAiADNgIIIAJBlIkCNgIADAILIAEgAUGAAWpBwhIQzgYpAgA3AxggACABQRhqEM8GBEAgASABQZgBakECELEHIgI2AnwgAkUNASAAQQhqIgIoAgQgAigCAGtBAnUhAyABQcgAaiAAEKcHIQQCfwJAA0ACQCABIAFBQGtB9B8QzgYpAgA3AwggACABQQhqEM8GDQAgASAAEKgHIgU2AjggBUUNAiACIAFBOGoQ3gYMAQsLIAFBOGogACADEN8GIwBBEGsiAiQAIABBmANqQRQQ9AYhACABKAJ8IQMgAiABKQI4IgY3AwAgAiAGNwMIIABBAToAByAAQQE6AAYgAEEAOgAFIABBHzoABCAAQcz9ATYCACAAIAM2AgggAEGMigI2AgAgACACKQIANwIMIAJBEGokACAADAELQQALIQIgBBCpBwwCCyABIAFBMGpB0RMQzgYpAgA3AxAgACABQRBqEM8GRQ0BIAEgABCoByICNgJIIAJFDQAgAEGYA2pBDBD0BiEAIAEoAkghAyAAQQE6AAcgAEEBOgAGIABBADoABSAAQSA6AAQgAEHM/QE2AgAgACICIAM2AgggAkGEiwI2AgAMAQtBACECCyABQaABaiQAIAILJgEBfyAAKAIAIgEgASgCzAIgACgCBEECdGo2AtACIABBCGoQ1gYLogICA38BfiMAQfAAayICJAAgACgCDCAAKAIIa0EETwRAIAIgAkHoAGpByyYQzgYpAgA3AzAgASACQTBqEPcGIQMgAiAAKQIIIgU3AyggAiAFNwNgIAMgAkEoahD3BiEDIAIgAkHYAGpB4CUQzgYpAgA3AyAgAyACQSBqEPcGGgsgAgJ/IABBEGoiAygCAC0AAEHuAEYEQCACIAJB0ABqQe0kEM4GKQIANwMYIAEgAkEYahD3BhogAkHIAGoiBCADQQEQqwcgBAwBCyACIAMpAgA3A0AgAkFAawspAgA3AxAgASACQRBqEPcGIQEgACgCDCAAKAIIa0EDTQRAIAIgACkCCCIFNwMIIAIgBTcDOCABIAJBCGoQ9wYaCyACQfAAaiQACzABAX8gASgCACIDIAEoAgQiASADayIDIAIgAiADSxtqIQIgACABNgIEIAAgAjYCAAs4AQF/IwBBEGsiAiQAIAIgAkEIakGxHEHKHCAALQAIGxDOBikCADcDACABIAIQ9wYaIAJBEGokAAv7AQEEfyMAQUBqIgIkACAAQQhqIgAoAgAhBCAAKAIEIARrQQFqQQlPBEAgAkE4aiEDQQAhAANAIABBCEcEQCADQVBBqX8gBCAAQQFyaiwAACIFQTBrQQpJGyAFakEAQQkgACAEaiwAACIFQTBrQQpJGyAFakEEdGo6AAAgA0EBaiEDIABBAmohAAwBCwsgAkE4aiADEOoEIAJCADcDMCACQgA3AyggAkIANwMgIAIgAioCOLs5AxAgAkEYaiIDIAJBIGoiAEEYQaMcIAJBEGoQiwQgAGo2AgQgAyAANgIAIAIgAykCADcDCCABIAJBCGoQ9wYaCyACQUBrJAALhQIBBH8jAEHQAGsiAiQAIABBCGoiACgCACEEIAAoAgQgBGtBAWpBEU8EQCACQcgAaiEDQQAhAANAIABBEEcEQCADQVBBqX8gBCAAQQFyaiwAACIFQTBrQQpJGyAFakEAQQkgACAEaiwAACIFQTBrQQpJGyAFakEEdGo6AAAgA0EBaiEDIABBAmohAAwBCwsgAkHIAGogAxDqBCACQgA3AzggAkIANwMwIAJCADcDKCACQgA3AyAgAiACKwNIOQMQIAJBGGoiAyACQSBqIgBBIEH3HSACQRBqEIsEIABqNgIEIAMgADYCACACIAMpAgA3AwggASACQQhqEPcGGgsgAkHQAGokAAv9AQEEfyMAQfAAayICJAAgAEEIaiIAKAIAIQQgACgCBCAEa0EBakEhTwRAIAJB4ABqIQNBACEAA0AgAEEgRwRAIANBUEGpfyAEIABBAXJqLAAAIgVBMGtBCkkbIAVqQQBBCSAAIARqLAAAIgVBMGtBCkkbIAVqQQR0ajoAACADQQFqIQMgAEECaiEADAELCyACQeAAaiADEOoEIAJBMGoiAEEAQSoQ3gIaIAIgAikDYDcDECACIAIpA2g3AxggAkEoaiIDIABBKkG2HyACQRBqEIsEIABqNgIEIAMgADYCACACIAMpAgA3AwggASACQQhqEPcGGgsgAkHwAGokAAt8AQF/IwBBIGsiAiQAIAIgAkEYakHZIxDOBikCADcDCCABIAJBCGoQ9wYhASAAKAIIIgAgASAAKAIAKAIQEQAAIAAtAAVBAUcEQCAAIAEgACgCACgCFBEAAAsgAiACQRBqQYMnEM4GKQIANwMAIAEgAhD3BhogAkEgaiQAC7QBAQN/IwBBEGsiAiQAIAIgATYCDCAAKAIAIgMgAUECdGoiACAAKAKMAyIAQQFqNgKMAyACIAA2AgggA0GYA2pBEBD0BiEAIAIoAgwhASACKAIIIQQgAEEBOgAHIABBAToABiAAQQE6AAUgAEEcOgAEIABBzP0BNgIAIAAgBDYCDCAAIAE2AgggAEGohwI2AgAgAiAANgIEIAMoAtACQQRrKAIAIAJBBGoQ3gYgAkEQaiQAIAALbwIBfwF+IwBBMGsiAiQAIAIgAkEoakGwHRDOBikCADcDECABIAJBEGoQ9wYhASACIAApAggiAzcDCCACIAM3AyAgASACQQhqEPcGIQAgAiACQRhqQdsmEM4GKQIANwMAIAAgAhD3BhogAkEwaiQAC/ABAgN/AX4jAEEgayICJAACQCACAn8CQAJAAkAgACgCCA4DAAECBAsgAkEYakHtHhDOBgwCCyACQRBqQaEfEM4GDAELIAJBCGpB6R4QzgYLKQIANwMAIAEgAhD3BhoLIAAoAgwiAwRAIwBBMGsiACQAAkAgA0EBa60iBVAEQCABQTAQzQYMAQsgAEEtaiEDA0AgBVBFBEAgA0EBayIDIAUgBUIKgCIFQgp+fadBMHI6AAAMAQsLIABBEGoiBCAAQS1qNgIEIAQgAzYCACAAIAQpAgA3AwggASAAQQhqELQHGgsgAEEwaiQACyACQSBqJAALNAIBfwF+IwBBEGsiAiQAIAIgASkCACIDNwMAIAIgAzcDCCAAIAIQ9wYhACACQRBqJAAgAAstACMAQRBrIgAkACAAIABBCGpBiCoQzgYpAgA3AwAgASAAEPcGGiAAQRBqJAALMAAgACgCCCIAIAEgACgCACgCEBEAACAALQAFQQFHBEAgACABIAAoAgAoAhQRAAALC3ABAn8jAEEQayICJAAgACgCDCIDIAEgAygCACgCEBEAAAJ/IAAoAgwiAC0ABSIDQQJHBEAgA0UMAQsgACABIAAoAgAoAgARAwALRQRAIAIgAkEIakGOKxDOBikCADcDACABIAIQ9wYaCyACQRBqJAALRgEBfyAAKAIIIgIgASACKAIAKAIQEQAAIAItAAVBAUcEQCACIAEgAigCACgCFBEAAAsgACgCDCIAIAEgACgCACgCFBEAAAtWAQF/IwBBIGsiAiQAIAIgAkEYakG9IxDOBikCADcDCCAAQQxqIAEgAkEIahD3BiIAELoHIAIgAkEQakGGKhDOBikCADcDACAAIAIQ9wYaIAJBIGokAAuxAQEGfyMAQRBrIgIkAEEBIQQDQCAAKAIEIAVHBEAgASgCBCEGIARBAXFFBEAgAiACQQhqQf4qEM4GKQIANwMAIAEgAhD3BhoLIAEoAgQhByAAKAIAIAVBAnRqKAIAIgMgASADKAIAKAIQEQAAIAMtAAVBAUcEQCADIAEgAygCACgCFBEAAAsgBUEBaiEFIAcgASgCBEYEfyABIAY2AgQgBAVBAAshBAwBCwsgAkEQaiQAC0MBAX8jAEEQayICJAAgACgCCCIAIAEgACgCACgCEBEAACACIAJBCGpB0SQQzgYpAgA3AwAgASACEPcGGiACQRBqJAALFgAgACgCCCIAIAEgACgCACgCFBEAAAtzAgF/AX4jAEEwayICJAAgAiACQShqQewdEM4GKQIANwMQIAEgAkEQahD3BiEBIAIgACkCGCIDNwMIIAIgAzcDICABIAJBCGoQ9wYhASACIAJBGGpB2yYQzgYpAgA3AwAgACABIAIQ9wYQvgcgAkEwaiQAC6UBAQJ/IwBBQGoiAiQAIABBCGoiAygCBARAIAIgAkE4akHaIxDOBikCADcDGCADIAEgAkEYahD3BiIDELoHIAIgAkEwakGLIhDOBikCADcDECADIAJBEGoQ9wYaCyACIAJBKGpByyYQzgYpAgA3AwggAEEQaiABIAJBCGoQ9wYiABC6ByACIAJBIGpB4CUQzgYpAgA3AwAgACACEPcGGiACQUBrJAALZQEBfyMAQSBrIgIkACACIAJBGGpBrR4QzgYpAgA3AwggASACQQhqEPcGIQEgACgCCCIALQAEQS5GBEAgACABEL4HCyACIAJBEGpBzg4QzgYpAgA3AwAgASACEPcGGiACQSBqJAAL7AEBAn8jAEHQAGsiAiQAIAIgAkHIAGpByyYQzgYpAgA3AyAgASACQSBqELQHIQMgACgCCCIBIAMgASgCACgCEBEAACABLQAFQQFHBEAgASADIAEoAgAoAhQRAAALIAIgAkFAa0HgJRDOBikCADcDGCADIAJBGGoQtAchASACAn8gAEEMaiIAKAIALQAAQe4ARgRAIAIgAkE4akHtJBDOBikCADcDECABIAJBEGoQtAcaIAJBMGoiAyAAQQEQqwcgAwwBCyACIAApAgA3AyggAkEoagspAgA3AwggASACQQhqELQHGiACQdAAaiQAC1ACAX8BfiMAQSBrIgIkACACIAJBGGpByhMQzgYpAgA3AwggASACQQhqEPcGIQEgAiAAKQIIIgM3AwAgAiADNwMQIAEgAhD3BhogAkEgaiQAC5cDAgJ/AX4jAEHwAGsiAiQAIAIgADYCbCACIAE2AmggAUEoEM0GAkAgAC0AGARAIAAoAgwiAwRAIAMgASADKAIAKAIQEQAAIAMtAAVBAUcEQCADIAEgAygCACgCFBEAAAsgAUEgEM0GIAIgACkCECIENwMwIAIgBDcDYCABIAJBMGoQ9wZBIBDNBgsgAiACQdgAakH5KhDOBikCADcDKCABIAJBKGoQ9wYhAyACIAApAhAiBDcDICACIAQ3A1AgAyACQSBqEPcGQSAQzQYgAkHoAGoQwwcMAQsgAkHoAGoQwwcgAUEgEM0GIAIgACkCECIENwMYIAIgBDcDSCABIAJBGGoQ9wYhAyACIAJBQGtB0CQQzgYpAgA3AxAgAyACQRBqEPcGIQMgACgCDEUNACADQSAQzQYgAiAAKQIQIgQ3AwggAiAENwM4IAMgAkEIahD3BiIDQSAQzQYgACgCDCIAIAMgACgCACgCEBEAACAALQAFQQFHBEAgACADIAAoAgAoAhQRAAALCyABQSkQzQYgAkHwAGokAAtnAQN/IwBBEGsiAiQAIAAoAgQhASAAKAIAQSgQzQYgAiABKAIIEMQHIgEgACgCACIDIAEoAgAoAhARAAAgAS0ABUEBRwRAIAEgAyABKAIAKAIUEQAACyAAKAIAQSkQzQYgAkEQaiQACzkAIABBAToAByAAQQE6AAYgAEEBOgAFIABBIzoABCAAQcz9ATYCACAAIAE2AgggAEGEkAI2AgAgAAv6AgEHfyMAQUBqIgQkACAEQTBqIgIgAUEMajYCACABKAIMIQMgAkEBOgAIIAIgAzYCBCABQX82AgwgAiEIIARBIGoiAiABQRBqNgIAIAEoAhAhAyACQQE6AAggAiADNgIEIAFBfzYCECABKAIEIQUgACgCCCIGIAEiAyAGKAIAKAIQEQAAIAYtAAVBAUcEQCAGIAMgBigCACgCFBEAAAtBASEHAkACQAJAAkAgAygCECIGQQFqDgICAAELIAMgBTYCBAwCCwNAIAYgB0YNAiAEIARBEGpB/ioQzgYpAgA3AwAgAyAEEPcGIQEgAyAHNgIMIAAoAggiBSABIAUoAgAoAhARAAAgBS0ABUEBRwRAIAUgASAFKAIAKAIUEQAACyAHQQFqIQcMAAsACyAEIARBGGpB0SQQzgYpAgA3AwggAyAEQQhqEPcGGgsgAi0ACARAIAIoAgAgAigCBDYCAAsgCC0ACARAIAgoAgAgCCgCBDYCAAsgBEFAayQAC/0CAgN/AX4jAEGAAWsiAiQAIABBDGoiBCACQfgAakGLIhDOBhCbBwRAIAIgAkHwAGpByyYQzgYpAgA3AzggASACQThqEPcGGgsgAiACQegAakHLJhDOBikCADcDMCABIAJBMGoQ9wYhASAAKAIIIgMgASADKAIAKAIQEQAAIAMtAAVBAUcEQCADIAEgAygCACgCFBEAAAsgAiACQeAAakGBKxDOBikCADcDKCABIAJBKGoQ9wYhASACIAApAgwiBTcDICACIAU3A1ggASACQSBqEPcGIQEgAiACQdAAakHKJhDOBikCADcDGCABIAJBGGoQ9wYhASAAKAIUIgAgASAAKAIAKAIQEQAAIAAtAAVBAUcEQCAAIAEgACgCACgCFBEAAAsgAiACQcgAakHgJRDOBikCADcDECABIAJBEGoQ9wYhACAEIAJB+ABqQYsiEM4GEJsHBEAgAiACQUBrQeAlEM4GKQIANwMIIAAgAkEIahD3BhoLIAJBgAFqJAALnQECAX8BfiMAQTBrIgIkACACIAApAggiAzcDECACIAM3AyggASACQRBqEPcGIQEgAiACQSBqQcsmEM4GKQIANwMIIAEgAkEIahD3BiEBIAAoAhAiACABIAAoAgAoAhARAAAgAC0ABUEBRwRAIAAgASAAKAIAKAIUEQAACyACIAJBGGpB4CUQzgYpAgA3AwAgASACEPcGGiACQTBqJAALUAEBfiAAQQE6AAcgAEEBOgAGIABBAToABSAAQTc6AAQgAEHM/QE2AgAgAEHIkgI2AgAgASkCACEEIAAgAzYCFCAAIAI2AhAgACAENwIIIAALtgECAn8BfiMAQUBqIgIkACACIAApAggiBDcDGCACIAQ3AzggASACQRhqEPcGIQEgAiACQTBqQdojEM4GKQIANwMQIAEgAkEQahD3BiEBIAAoAhAiAyABIAMoAgAoAhARAAAgAiACQShqQf0lEM4GKQIANwMIIAEgAkEIahD3BiEBIAAoAhQiACABIAAoAgAoAhARAAAgAiACQSBqQeAlEM4GKQIANwMAIAEgAhD3BhogAkFAayQAC4QBAQJ/IwBBIGsiAiQAIAAoAggiAyABIAMoAgAoAhARAAAgAy0ABUEBRwRAIAMgASADKAIAKAIUEQAACyACIAJBGGpByyYQzgYpAgA3AwggAEEMaiABIAJBCGoQ9wYiABC6ByACIAJBEGpB4CUQzgYpAgA3AwAgACACEPcGGiACQSBqJAALowEBAn8jAEEwayICJAAgAiACQShqQcsmEM4GKQIANwMQIAEgAkEQahD3BiEBIAAoAggiAyABIAMoAgAoAhARAAAgAy0ABUEBRwRAIAMgASADKAIAKAIUEQAACyACIAJBIGpBiyYQzgYpAgA3AwggAEEMaiABIAJBCGoQ9wYiABC6ByACIAJBGGpB4CUQzgYpAgA3AwAgACACEPcGGiACQTBqJAALqgEBAX8jAEEwayICJAAgAC0ADARAIAIgAkEoakHyIxDOBikCADcDECABIAJBEGoQ9wYaCyACIAJBIGpBwxwQzgYpAgA3AwggASACQQhqEPcGIQEgAC0ADQRAIAIgAkEYakGSKhDOBikCADcDACABIAIQ9wYaCyAAKAIIIgAgASAAKAIAKAIQEQAAIAAtAAVBAUcEQCAAIAEgACgCACgCFBEAAAsgAkEwaiQAC00AIABBmANqQQwQ9AYhACABKAIAIQEgAEEBOgAHIABBAToABiAAQQE6AAUgAEEEOgAEIABBzP0BNgIAIAAgATYCCCAAQbSXAjYCACAAC0QBAX8jAEEQayICJAAgAiACQQhqQcwOEM4GKQIANwMAIAEgAhD3BiEBIAAoAggiACABIAAoAgAoAhARAAAgAkEQaiQAC14BAX8jAEEQayICJAAgAiACQQhqQc8nEM4GKQIANwMAIAEgAhD3BiEBIAAoAggiACABIAAoAgAoAhARAAAgAC0ABUEBRwRAIAAgASAAKAIAKAIUEQAACyACQRBqJAALXgEBfyMAQRBrIgIkACACIAJBCGpBhCsQzgYpAgA3AwAgASACEPcGIQEgACgCCCIAIAEgACgCACgCEBEAACAALQAFQQFHBEAgACABIAAoAgAoAhQRAAALIAJBEGokAAteAQF/IwBBEGsiAiQAIAIgAkEIakHyIxDOBikCADcDACABIAIQ9wYhASAAKAIIIgAgASAAKAIAKAIQEQAAIAAtAAVBAUcEQCAAIAEgACgCACgCFBEAAAsgAkEQaiQACxYAIAAgASgCCCIAIAAoAgAoAhgRAAALUAEBfiAAQQE6AAcgAEEBOgAGIABBAToABSAAQTQ6AAQgAEHM/QE2AgAgACABNgIIIABBhJoCNgIAIAIpAgAhBCAAIAM2AhQgACAENwIMIAALjgECAn8BfiMAQRBrIgIkACAAKAIIIgMgASADKAIAKAIQEQAAIAMtAAVBAUcEQCADIAEgAygCACgCFBEAAAsgAiAAKQIMIgQ3AwAgAiAENwMIIAEgAhD3BiEBIAAoAhQiACABIAAoAgAoAhARAAAgAC0ABUEBRwRAIAAgASAAKAIAKAIUEQAACyACQRBqJAALyQEBAn8jAEEwayICJAAgAiACQShqQcsmEM4GKQIANwMQIAEgAkEQahD3BiEBIAAoAggiAyABIAMoAgAoAhARAAAgAy0ABUEBRwRAIAMgASADKAIAKAIUEQAACyACIAJBIGpBvh4QzgYpAgA3AwggASACQQhqEPcGIQEgACgCDCIAIAEgACgCACgCEBEAACAALQAFQQFHBEAgACABIAAoAgAoAhQRAAALIAIgAkEYakGuHhDOBikCADcDACABIAIQ9wYaIAJBMGokAAv3AQECfyMAQRBrIgMkAAJAIAAtABAEQCABQdsAEM0GIAAoAggiAiABIAIoAgAoAhARAAAgAi0ABUEBRwRAIAIgASACKAIAKAIUEQAACyABQd0AEM0GDAELIAFBLhDNBiAAKAIIIgIgASACKAIAKAIQEQAAIAItAAVBAUcEQCACIAEgAigCACgCFBEAAAsLIAAoAgwiAi0ABEHLAGtB/wFxQQJPBEAgAyADQQhqQZYqEM4GKQIANwMAIAEgAxD3BhogACgCDCECCyACIAEgAigCACgCEBEAACACLQAFQQFHBEAgAiABIAIoAgAoAhQRAAALIANBEGokAAuCAgECfyMAQSBrIgMkACABQdsAEM0GIAAoAggiAiABIAIoAgAoAhARAAAgAi0ABUEBRwRAIAIgASACKAIAKAIUEQAACyADIANBGGpB+CoQzgYpAgA3AwggASADQQhqEPcGIQEgACgCDCICIAEgAigCACgCEBEAACACLQAFQQFHBEAgAiABIAIoAgAoAhQRAAALIAFB3QAQzQYgACgCECICLQAEQcsAa0H/AXFBAk8EQCADIANBEGpBlioQzgYpAgA3AwAgASADEPcGGiAAKAIQIQILIAIgASACKAIAKAIQEQAAIAItAAVBAUcEQCACIAEgAigCACgCFBEAAAsgA0EgaiQAC0QAIABBAToAByAAQQE6AAYgAEEBOgAFIABBwAA6AAQgAEHM/QE2AgAgACABNgIIIABBsJ0CNgIAIAAgAikCADcCDCAAC1EBAX8gACgCCCICBEAgAiABIAIoAgAoAhARAAAgAi0ABUEBRwRAIAIgASACKAIAKAIUEQAACwsgAUH7ABDNBiAAQQxqIAEQugcgAUH9ABDNBgvJAQECfyMAQTBrIgIkACACIAJBKGpByyYQzgYpAgA3AxAgASACQRBqEPcGIQEgACgCCCIDIAEgAygCACgCEBEAACADLQAFQQFHBEAgAyABIAMoAgAoAhQRAAALIAIgAkEgakGLJhDOBikCADcDCCABIAJBCGoQ9wYhASAAKAIMIgAgASAAKAIAKAIQEQAAIAAtAAVBAUcEQCAAIAEgACgCACgCFBEAAAsgAiACQRhqQeAlEM4GKQIANwMAIAEgAhD3BhogAkEwaiQAC50BAgJ/AX4jAEEwayICJAAgAiACQShqQcsmEM4GKQIANwMQIAEgAkEQahD3BiEBIAAoAggiAyABIAMoAgAoAhARAAAgAy0ABUEBRwRAIAMgASADKAIAKAIUEQAACyACIAJBIGpB4CUQzgYpAgA3AwggASACQQhqEPcGIQEgAiAAKQIMIgQ3AwAgAiAENwMYIAEgAhD3BhogAkEwaiQAC9YCAQJ/IwBB8ABrIgIkACAALQAcBEAgAiACQegAakHNJxDOBikCADcDMCABIAJBMGoQ9wYaCyACIAJB4ABqQa0QEM4GKQIANwMoIAEgAkEoahD3BiEBIAAtAB0EQCACIAJB2ABqQa0eEM4GKQIANwMgIAEgAkEgahD3BhoLIAFBIBDNBiAAQQhqIgMoAgQEQCACIAJB0ABqQcsmEM4GKQIANwMYIAMgASACQRhqEPcGIgMQugcgAiACQcgAakHgJRDOBikCADcDECADIAJBEGoQ9wYaCyAAKAIQIgMgASADKAIAKAIQEQAAIAMtAAVBAUcEQCADIAEgAygCACgCFBEAAAsgAEEUaiIAKAIEBEAgAiACQUBrQcsmEM4GKQIANwMIIAAgASACQQhqEPcGIgAQugcgAiACQThqQeAlEM4GKQIANwMAIAAgAhD3BhoLIAJB8ABqJAALUwEBfiAAQQE6AAcgAEEBOgAGIABBAToABSAAQTY6AAQgAEHM/QE2AgAgAEHkoAI2AgAgASkCACEEIAAgAjYCECAAIAQ3AgggACADKQIANwIUIAALfgICfwF+IwBBIGsiAiQAIAIgACkCCCIENwMIIAIgBDcDGCABIAJBCGoQ9wYhASAAKAIQIgMgASADKAIAKAIQEQAAIAMtAAVBAUcEQCADIAEgAygCACgCFBEAAAsgAiAAKQIUIgQ3AwAgAiAENwMQIAEgAhD3BhogAkEgaiQAC5YCAQJ/IwBBQGoiAiQAIAIgAkE4akHLJhDOBikCADcDGCABIAJBGGoQ9wYhASAAKAIIIgMgASADKAIAKAIQEQAAIAMtAAVBAUcEQCADIAEgAygCACgCFBEAAAsgAiACQTBqQbUmEM4GKQIANwMQIAEgAkEQahD3BiEBIAAoAgwiAyABIAMoAgAoAhARAAAgAy0ABUEBRwRAIAMgASADKAIAKAIUEQAACyACIAJBKGpBuyYQzgYpAgA3AwggASACQQhqEPcGIQEgACgCECIAIAEgACgCACgCEBEAACAALQAFQQFHBEAgACABIAAoAgAoAhQRAAALIAIgAkEgakHgJRDOBikCADcDACABIAIQ9wYaIAJBQGskAAvTAgECfyMAQeAAayICJAAgACgCDCIDIAEgAygCACgCEBEAACADLQAFQQFHBEAgAyABIAMoAgAoAhQRAAALIAIgAkHYAGpB1iMQzgYpAgA3AyAgASACQSBqEPcGIQMgACgCCCIBIAMgASgCACgCEBEAACABLQAFQQFHBEAgASADIAEoAgAoAhQRAAALIAIgAkHQAGpBwScQzgYpAgA3AxggAyACQRhqEPcGIQEgAgJ/IABBEGoiACgCACAAKAIERgRAIAJByABqQcQkEM4GDAELIAAoAgAtAABB7gBGBEAgAiACQUBrQe0kEM4GKQIANwMQIAEgAkEQahD3BhogAkE4aiIDIABBARCrByADDAELIAIgACkCADcDMCACQTBqCykCADcDCCABIAJBCGoQ9wYhACACIAJBKGpBiyIQzgYpAgA3AwAgACACEPcGGiACQeAAaiQAC2ABAX8jAEEwayICJAAgAiACQShqQYAmEM4GKQIANwMIIAEgAkEIahD3BiEBIAJBGGogACgCCBDEByABEMUHIAIgAkEQakHgJRDOBikCADcDACABIAIQ9wYaIAJBMGokAAsMACAAQQhqIAEQugcLXgEBfyMAQRBrIgIkACACIAJBCGpBuicQzgYpAgA3AwAgASACEPcG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QQJHBEAgBEUMAQsgAyABIAMoAgAoAggRAwALRQ0BCyACQShqQcsmEM4GDAELIAJBIGpBjisQzgYLKQIANwMQIAEgAkEQahD3BiEBIAAoAggiACABIAAoAgAoAhARAAAgAC0ABUEBRwRAIAAgASAAKAIAKAIUEQAACyACIAJBGGpBpCUQzgYpAgA3AwggASACQQhqEPcGGiACQTBqJAALnwEBA38jAEEQayIDJAACQAJ/IAAoAgwiAi0ABiIEQQJHBEAgBEUMAQsgAiABIAIoAgAoAgQRAwALRQRAAn8gACgCDCICLQAHIgRBAkcEQCAERQwBCyACIAEgAigCACgCCBEDAAtFDQELIAMgA0EIakHgJRDOBikCADcDACABIAMQ9wYaCyAAKAIMIgAgASAAKAIAKAIUEQAAIANBEGokAAtlAgF/AX4jAEEQayICJAAgAiAAKQIIIgM3AwAgAiADNwMIIAEgAhD3BiIBQSAQzQYgACgCECIAIAEgACgCACgCEBEAACAALQAFQQFHBEAgACABIAAoAgAoAhQRAAALIAJBEGokAAstAQF/An8gACgCCCIALQAFIgJBAkcEQCACRQwBCyAAIAEgACgCACgCABEDAAsL/gICA38BfiMAQeAAayICJAAgAgJ/AkAgACgCCCIDLQAEQQpGBEAgAxCQCCEEIAAoAgghAyAEDQELIAMgASADKAIAKAIQEQAAAn8gACgCCCIDLQAGIgRBAkcEQCAERQwBCyADIAEgAygCACgCBBEDAAsEQCACIAJB2ABqQY4rEM4GKQIANwMoIAEgAkEoahD3BhoLAkACfyAAKAIIIgMtAAYiBEECRwRAIARFDAELIAMgASADKAIAKAIEEQMAC0UEQAJ/IAAoAggiAC0AByIDQQJHBEAgA0UMAQsgACABIAAoAgAoAggRAwALRQ0BCyACIAJB0ABqQcsmEM4GKQIANwMgIAEgAkEgahD3BhoLIAJByABqQaklEM4GDAELIAIgAkFAa0HHIxDOBikCADcDGCABIAJBGGoQ9wYhACACIAMpAgwiBTcDECACIAU3AzggACACQRBqEPcGGiACQTBqQYsiEM4GCykCADcDCCABIAJBCGoQ9wYaIAJB4ABqJAALRAECfyMAQRBrIgIkACAAKAIIIgAtAARBB0YEQCACQQhqIgEgACkCCDcCACABIAJB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cwBncwBkcwBUcwBudWxscHRyAHNyAEFwcgB2ZWN0b3IAc3RkOjphbGxvY2F0b3IAT2N0b2JlcgBOb3ZlbWJlcgBTZXB0ZW1iZXIARGVjZW1iZXIAdW5zaWduZWQgY2hhcgBpb3NfYmFzZTo6Y2xlYXIATWFyAGVxAGZwAFNlcABUcAAlSTolTTolUyAlcABhdXRvAG9iamNwcm90bwBvbwBlbwBEbwBTdW4ASnVuAHlwdG4AYXNzZXJ0aW9uAHNjYW5iZWFtIHRyZWUgaW5zZXJ0aW9uAFNUIGluc2VydGlvbgBMTVQgaW5zZXJ0aW9uAElUIGluc2VydGlvbgBzdGQ6OmV4Y2VwdGlvbgBjb250b3VyIGFkZGl0aW9uAGNvbnRvdXIgaG9sZSBhZGRpdGlvbgBhc3NlcnRpb24gdmlvbGF0aW9uAEJvdW5kaW5nIGJveCBjcmVhdGlvbgB0cmlzdHJpcCB2ZXJ0ZXggY3JlYXRpb24AdHJpc3RyaXAgbGlzdCBjcmVhdGlvbgBzYnQgY3JlYXRpb24AdHJpc3RyaXAgY3JlYXRpb24Ab3ZlcmxhcCB0YWJsZSBjcmVhdGlvbgBlZGdlIHRhYmxlIGNyZWF0aW9uAHRyaXN0cmlwIG5vZGUgY3JlYXRpb24AdW5pb24ATW9uAGRuAG5hbgBKYW4AVG4AZW51bQBybQBjbQBiYXNpY19pb3N0cmVhbQBzdGQ6Omlvc3RyZWFtAGJhc2ljX29zdHJlYW0Ac3RkOjpvc3RyZWFtAGJhc2ljX2lzdHJlYW0Ac3RkOjppc3RyZWFtAEp1bABwbABib29sAFJlZmVyIHRvIHRoZSBidWctcmVwb3J0aW5nIGluc3RydWN0aW9ucyBhdCBodHRwczovL3d3dy5jZ2FsLm9yZy9idWdfcmVwb3J0Lmh0bWwAdWxsAEFwcmlsAHN0cmluZyBsaXRlcmFsAFVsAEZyaQBwaQBtaQBiYWRfYXJyYXlfbmV3X2xlbmd0aABNYXJjaAAvaG9tZS9ydW5uZXIvd29yay9hcnJhbmdlbWVudC0yZC1qcy9hcnJhbmdlbWVudC0yZC1qcy9saWJyYXJpZXMvQ0dBTC01LjQvaW5jbHVkZS9DR0FML1N1cmZhY2Vfc3dlZXBfMi9FdmVudF9jb21wYXJlci5oAC9ob21lL3J1bm5lci93b3JrL2FycmFuZ2VtZW50LTJkLWpzL2FycmFuZ2VtZW50LTJkLWpzL2xpYnJhcmllcy9DR0FMLTUuNC9pbmNsdWRlL0NHQUwvQXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18yLmgAL2hvbWUvcnVubmVyL3dvcmsvYXJyYW5nZW1lbnQtMmQtanMvYXJyYW5nZW1lbnQtMmQtanMvbGlicmFyaWVzL0NHQUwtNS40L2luY2x1ZGUvQ0dBTC9BcnJhbmdlbWVudF8yL0Fycl90cmFpdHNfYWRhcHRvcl8yLmgAQXVnAHVuc2lnbmVkIGxvbmcgbG9uZwB1bnNpZ25lZCBsb25nAHRlcm1pbmF0aW5nAHN0ZDo6YmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAF9fdXVpZG9mAGluZgBoYWxmACVhZgAlLjBMZgAlTGYAdHJ1ZQBUdWUAb3BlcmF0b3IgZGVsZXRlAGZhbHNlAEp1bmUAIHZvbGF0aWxlAGxvbmcgZG91YmxlAF9ibG9ja19pbnZva2UAZ2UAVGUAc3RkAHZvaWQAdGVybWluYXRlX2hhbmRsZXIgdW5leHBlY3RlZGx5IHJldHVybmVkACd1bm5hbWVkAG11dGV4IGxvY2sgZmFpbGVkAFdlZABzdGQ6OmJhZF9hbGxvYwBEZWMARmViAFViAG5hACdsYW1iZGEAYWEAJWEAb3BlcmF0b3JeAG9wZXJhdG9yIG5ld1tdAG9wZXJhdG9yW10Ab3BlcmF0b3IgZGVsZXRlW10AcGl4ZWwgdmVjdG9yWwApWwBfX19fWgAlYSAlYiAlZCAlSDolTTolUyAlWQBQT1NJWABkVgBmcFQAJFRUACRUAHJTAGxTAGFTACVIOiVNOiVTAG9SAGVPAERPAHNyTgBhTgBfR0xPQkFMX19OAE5BTgAkTgByTQBQTQBBTQBwTABtTABmTAAlTGFMAExDX0FMTABDR0FMAG1JAFVhOWVuYWJsZV9pZkkATEFORwBJTkYAdkUARG5FAFJFAE9FAGIxRQBiMEUAREMAb3BlcmF0b3I/AG9wZXJhdG9yPgBvcGVyYXRvcj4+AG9wZXJhdG9yPD0+AG9wZXJhdG9yLT4Ac3RkOjpiYXNpY19pb3N0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4Ac3RkOjpiYXNpY19vc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBzdGQ6OmJhc2ljX2lzdHJlYW08Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiA+AHN0ZDo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6YWxsb2NhdG9yPGNoYXI+ID4Ab3BlcmF0b3J8PQBvcGVyYXRvcj0Ab3BlcmF0b3JePQBvcGVyYXRvcj49AG9wZXJhdG9yPj49AG9wZXJhdG9yPT0Ab3BlcmF0b3I8PQBvcGVyYXRvcjw8PQBvcGVyYXRvci89AG9wZXJhdG9yLT0Ab3BlcmF0b3IrPQBvcGVyYXRvcio9AG9wZXJhdG9yJj0Ab3BlcmF0b3IlPQBvcGVyYXRvciE9AG9wZXJhdG9yPAB0ZW1wbGF0ZTwAaWQ8AG9wZXJhdG9yPDwALjwAIjwAW2FiaToAIFtlbmFibGVfaWY6AHN0ZDo6ADAxMjM0NTY3ODkAdW5zaWduZWQgX19pbnQxMjgAX19mbG9hdDEyOABkZWNpbWFsMTI4AEMuVVRGLTgAZGVjaW1hbDY0AGRlY2ltYWwzMgAwAG9wZXJhdG9yLwAgLi4uAG9wZXJhdG9yLQAtaW4tAG9wZXJhdG9yLS0Ab3BlcmF0b3IsAG9wZXJhdG9yKwBvcGVyYXRvcisrAG9wZXJhdG9yKgBvcGVyYXRvci0+KgA6OioALioAZGVjbHR5cGUoYXV0bykAKG51bGwpAChhbm9ueW1vdXMgbmFtZXNwYWNlKQBvcGVyYXRvcigpAHRocm93KABub2V4Y2VwdCgAZGVjbHR5cGUoAD4oAHNpemVvZi4uLigAKSgAbm9leGNlcHQgKABhbGlnbm9mICgAc2l6ZW9mICgAdHlwZWlkICgAKSA/ICgAKSA6ICgAc2l6ZW9mLi4uICgAJ2Jsb2NrLWxpdGVyYWwnAG9wZXJhdG9yJgBvcGVyYXRvciYmACAmJgAgJgBvcGVyYXRvciUAPiIAb3BlcmF0b3IhACB2aW9sYXRpb24hAFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhAHRocm93IAAgYXQgb2Zmc2V0IAA6Om9wZXJhdG9yIAByZWZlcmVuY2UgdGVtcG9yYXJ5IGZvciAAdGVtcGxhdGUgcGFyYW1ldGVyIG9iamVjdCBmb3IgAHR5cGVpbmZvIGZvciAAdGhyZWFkLWxvY2FsIHdyYXBwZXIgcm91dGluZSBmb3IgAHRocmVhZC1sb2NhbCBpbml0aWFsaXphdGlvbiByb3V0aW5lIGZvciAAdHlwZWluZm8gbmFtZSBmb3IgAGNvbnN0cnVjdGlvbiB2dGFibGUgZm9yIABndWFyZCB2YXJpYWJsZSBmb3IgAFZUVCBmb3IgAGNvdmFyaWFudCByZXR1cm4gdGh1bmsgdG8gAG5vbi12aXJ0dWFsIHRodW5rIHRvIABpbnZvY2F0aW9uIGZ1bmN0aW9uIGZvciBibG9jayBpbiAAPiB0eXBlbmFtZSAAW10gACA9IAAKRXhwcjogAENHQUwgZXJyb3I6IAAKRXhwbGFuYXRpb246IAAKTGluZTogAApGaWxlOiAARXhwcmVzc2lvbiA6IABMaW5lICAgICAgIDogAEZpbGUgICAgICAgOiAAIC4uLiAALCAAKSAAb3BlcmF0b3IiIiAAZ3BjIG1hbGxvYyBmYWlsdXJlOiAlcwoAAAAAAHQWAABMAAAATQAAAE4AAABONENHQUwyNEFycmFuZ2VtZW50X29uX3N1cmZhY2VfMklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18zNkFycl9ib3VuZGVkX3BsYW5hcl90b3BvbG9neV90cmFpdHNfMklTN19OU18xNkFycl9kZWZhdWx0X2RjZWxJUzdfRUVFRUVFAAAAQHwAALwVAAAAAAAALBcAAE8AAABQAAAAUQAAAFEAAABRAAAAUQAAAE40Q0dBTDMzQXJyX3BsYW5hcl90b3BvbG9neV90cmFpdHNfYmFzZV8ySU5TXzIwQXJyX3NlZ21lbnRfdHJhaXRzXzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRU5TXzE2QXJyX2RlZmF1bHRfZGNlbElTN19FRUVFAEB8AACcFgAATjVib29zdDEwd3JhcGV4Y2VwdElTdDliYWRfYWxsb2NFRQBONWJvb3N0MTZleGNlcHRpb25fZGV0YWlsMTBjbG9uZV9iYXNlRQAAAEB8AABXFwAATjVib29zdDlleGNlcHRpb25FAABAfAAAiBcAAMR8AAA0FwAAAAAAAAMAAACAFwAAAgAAAHx9AAACBAAAnBcAAAIIAAAAAAAApBcAAFIAAABTAAAAAwAAAFQAAAD8////pBcAAFUAAABWAAAAVwAAAPj///+kFwAAWAAAAFkAAAAAAAAAgBcAAFEAAABRAAAAWgAAAFsAAAAAAAAAnBcAAFEAAABRAAAAAAAAANgZAABcAAAAXQAAAF4AAABONENHQUw4QXJyX2ZhY2VJTlNfMTVBcnJfdmVydGV4X2Jhc2VJTlNfN1BvaW50XzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRUVFTlNfMTdBcnJfaGFsZmVkZ2VfYmFzZUlOU18xM0Fycl9zZWdtZW50XzJJUzdfRUVFRU5TXzEzQXJyX2ZhY2VfYmFzZUVFRQBONENHQUwxM0Fycl9mYWNlX2Jhc2VFAABAfAAA7BgAAE40Q0dBTDE4SW5fcGxhY2VfbGlzdF9iYXNlSU5TXzhBcnJfZmFjZUlOU18xNUFycl92ZXJ0ZXhfYmFzZUlOU183UG9pbnRfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFRUVOU18xN0Fycl9oYWxmZWRnZV9iYXNlSU5TXzEzQXJyX3NlZ21lbnRfMklTOF9FRUVFTlNfMTNBcnJfZmFjZV9iYXNlRUVFRUUAAABAfAAADBkAAMR8AABEGAAAAAAAAAIAAAAEGQAAAgAAANAZAAACLAAAAAAAAAQZAABcAAAAXwAAAF4AAAAAAAAAnBoAAEwAAABgAAAATgAAAE40Q0dBTDEzQXJyYW5nZW1lbnRfMklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18xNkFycl9kZWZhdWx0X2RjZWxJUzdfRUVFRQBofAAAIBoAAHQWAAAAAAAAXBsAAE8AAABhAAAAYgAAAGMAAABkAAAAZQAAAE40Q0dBTDM2QXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18ySU5TXzIwQXJyX3NlZ21lbnRfdHJhaXRzXzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRU5TXzE2QXJyX2RlZmF1bHRfZGNlbElTN19FRUVFAABofAAAyBoAACwXAAAAAAAA9BwAAGYAAABnAAAATjRDR0FMMTZBcnJfZGVmYXVsdF9kY2VsSU5TXzIwQXJyX3NlZ21lbnRfdHJhaXRzXzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRUVFAE40Q0dBTDEzQXJyX2RjZWxfYmFzZUlOU18xNUFycl92ZXJ0ZXhfYmFzZUlOU183UG9pbnRfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFRUVOU18xN0Fycl9oYWxmZWRnZV9iYXNlSU5TXzEzQXJyX3NlZ21lbnRfMklTN19FRUVFTlNfMTNBcnJfZmFjZV9iYXNlRU41Ym9vc3QxOWZhc3RfcG9vbF9hbGxvY2F0b3JJaU5TRl8zM2RlZmF1bHRfdXNlcl9hbGxvY2F0b3JfbmV3X2RlbGV0ZUVOU3QzX18yNW11dGV4RUxqMzJFTGowRUVFRUUAAAAAQHwAANwbAADEfAAAeBsAAAAAAAABAAAA7BwAAAIEAAAAAAAA+B4AAGgAAABpAAAAagAAAE40Q0dBTDEwQXJyX3ZlcnRleElOU18xNUFycl92ZXJ0ZXhfYmFzZUlOU183UG9pbnRfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFRUVOU18xN0Fycl9oYWxmZWRnZV9iYXNlSU5TXzEzQXJyX3NlZ21lbnRfMklTN19FRUVFTlNfMTNBcnJfZmFjZV9iYXNlRUVFAE40Q0dBTDE1QXJyX3ZlcnRleF9iYXNlSU5TXzdQb2ludF8ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVFRQBAfAAAyx0AAE40Q0dBTDE4SW5fcGxhY2VfbGlzdF9iYXNlSU5TXzEwQXJyX3ZlcnRleElOU18xNUFycl92ZXJ0ZXhfYmFzZUlOU183UG9pbnRfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFRUVOU18xN0Fycl9oYWxmZWRnZV9iYXNlSU5TXzEzQXJyX3NlZ21lbnRfMklTOF9FRUVFTlNfMTNBcnJfZmFjZV9iYXNlRUVFRUUAAAAAQHwAACgeAADEfAAAIB0AAAAAAAACAAAAIB4AAAIAAADwHgAAAhAAAAAAAAAQIQAAawAAAGwAAABtAAAATjRDR0FMMTJBcnJfaGFsZmVkZ2VJTlNfMTVBcnJfdmVydGV4X2Jhc2VJTlNfN1BvaW50XzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRUVFTlNfMTdBcnJfaGFsZmVkZ2VfYmFzZUlOU18xM0Fycl9zZWdtZW50XzJJUzdfRUVFRU5TXzEzQXJyX2ZhY2VfYmFzZUVFRQBONENHQUwxN0Fycl9oYWxmZWRnZV9iYXNlSU5TXzEzQXJyX3NlZ21lbnRfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFRUUAAEB8AADZHwAATjRDR0FMMThJbl9wbGFjZV9saXN0X2Jhc2VJTlNfMTJBcnJfaGFsZmVkZ2VJTlNfMTVBcnJfdmVydGV4X2Jhc2VJTlNfN1BvaW50XzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRUVFTlNfMTdBcnJfaGFsZmVkZ2VfYmFzZUlOU18xM0Fycl9zZWdtZW50XzJJUzhfRUVFRU5TXzEzQXJyX2ZhY2VfYmFzZUVFRUVFAABAfAAAQCAAAMR8AAAsHwAAAAAAAAIAAAA4IAAAAgAAAAghAAACHAAAAAAAAJglAABuAAAAbwAAAHAAAABxAAAAcgAAAHMAAAB0AAAATjRDR0FMMjdBcnJfY29uc3RydWN0aW9uX3NzX3Zpc2l0b3JJTlNfMzhBcnJfYm91bmRlZF9wbGFuYXJfY29uc3RydWN0aW9uX2hlbHBlcklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18yNEFycmFuZ2VtZW50X29uX3N1cmZhY2VfMklTOF9OU18zNkFycl9ib3VuZGVkX3BsYW5hcl90b3BvbG9neV90cmFpdHNfMklTOF9OU18xNkFycl9kZWZhdWx0X2RjZWxJUzhfRUVFRUVFTlNfMjJBcnJfY29uc3RydWN0aW9uX2V2ZW50SVM4X1NFX041Ym9vc3QxOWZhc3RfcG9vbF9hbGxvY2F0b3JJaU5TR18zM2RlZmF1bHRfdXNlcl9hbGxvY2F0b3JfbmV3X2RlbGV0ZUVOU3QzX18yNW11dGV4RUxqMzJFTGowRUVFTlNfMTVTdXJmYWNlX3N3ZWVwXzIxOERlZmF1bHRfZXZlbnRfYmFzZUVOU01fMTZEZWZhdWx0X3N1YmN1cnZlRUVFTlNfMjVBcnJfY29uc3RydWN0aW9uX3N1YmN1cnZlSVM4X1NQX1NMX1NPX05TXzdEZWZhdWx0RUVFRUVTUl9FRQBONENHQUwxNVN1cmZhY2Vfc3dlZXBfMjIwRGVmYXVsdF92aXNpdG9yX2Jhc2VJTlNfMjBBcnJfc2VnbWVudF90cmFpdHNfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFTlNfMjJBcnJfY29uc3RydWN0aW9uX2V2ZW50SVM4X05TXzI0QXJyYW5nZW1lbnRfb25fc3VyZmFjZV8ySVM4X05TXzM2QXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18ySVM4X05TXzE2QXJyX2RlZmF1bHRfZGNlbElTOF9FRUVFRUVONWJvb3N0MTlmYXN0X3Bvb2xfYWxsb2NhdG9ySWlOU0dfMzNkZWZhdWx0X3VzZXJfYWxsb2NhdG9yX25ld19kZWxldGVFTlN0M19fMjVtdXRleEVMajMyRUxqMEVFRU5TMF8xOERlZmF1bHRfZXZlbnRfYmFzZUVOUzBfMTZEZWZhdWx0X3N1YmN1cnZlRUVFTlNfMjVBcnJfY29uc3RydWN0aW9uX3N1YmN1cnZlSVM4X1NPX1NMX1NOX05TXzdEZWZhdWx0RUVFU0xfTlNfMjdBcnJfY29uc3RydWN0aW9uX3NzX3Zpc2l0b3JJTlNfMzhBcnJfYm91bmRlZF9wbGFuYXJfY29uc3RydWN0aW9uX2hlbHBlcklTOF9TRl9TT19TUl9FRVNRX0VFRUUAAEB8AABdIwAAaHwAAFQhAACQJQAAAAAAAKQnAAB1AAAAdgAAAHcAAAB4AAAAeQAAAE40Q0dBTDM4QXJyX2JvdW5kZWRfcGxhbmFyX2NvbnN0cnVjdGlvbl9oZWxwZXJJTlNfMjBBcnJfc2VnbWVudF90cmFpdHNfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFTlNfMjRBcnJhbmdlbWVudF9vbl9zdXJmYWNlXzJJUzdfTlNfMzZBcnJfYm91bmRlZF9wbGFuYXJfdG9wb2xvZ3lfdHJhaXRzXzJJUzdfTlNfMTZBcnJfZGVmYXVsdF9kY2VsSVM3X0VFRUVFRU5TXzIyQXJyX2NvbnN0cnVjdGlvbl9ldmVudElTN19TRF9ONWJvb3N0MTlmYXN0X3Bvb2xfYWxsb2NhdG9ySWlOU0ZfMzNkZWZhdWx0X3VzZXJfYWxsb2NhdG9yX25ld19kZWxldGVFTlN0M19fMjVtdXRleEVMajMyRUxqMEVFRU5TXzE1U3VyZmFjZV9zd2VlcF8yMThEZWZhdWx0X2V2ZW50X2Jhc2VFTlNMXzE2RGVmYXVsdF9zdWJjdXJ2ZUVFRU5TXzI1QXJyX2NvbnN0cnVjdGlvbl9zdWJjdXJ2ZUlTN19TT19TS19TTl9OU183RGVmYXVsdEVFRUVFAABAfAAAwCUAQbTPAAvJQQQoAABONENHQUwyN0Fycl9hbGxfc2lkZXNfb2JsaXZpb3VzX3RhZ0UATjRDR0FMMjFBcnJfYm91bmRhcnlfY29uZF90YWdFAEB8AADdJwAAxHwAALgnAAAAAAAAAQAAAPwnAAAD9P//AAAAAKAsAAB6AAAAewAAAHwAAAB9AAAAfgAAAH8AAACAAAAAgQAAAE40Q0dBTDE1U3VyZmFjZV9zd2VlcF8yMTVTdXJmYWNlX3N3ZWVwXzJJTlNfMjdBcnJfY29uc3RydWN0aW9uX3NzX3Zpc2l0b3JJTlNfMzhBcnJfYm91bmRlZF9wbGFuYXJfY29uc3RydWN0aW9uX2hlbHBlcklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18yNEFycmFuZ2VtZW50X29uX3N1cmZhY2VfMklTQV9OU18zNkFycl9ib3VuZGVkX3BsYW5hcl90b3BvbG9neV90cmFpdHNfMklTQV9OU18xNkFycl9kZWZhdWx0X2RjZWxJU0FfRUVFRUVFTlNfMjJBcnJfY29uc3RydWN0aW9uX2V2ZW50SVNBX1NHX041Ym9vc3QxOWZhc3RfcG9vbF9hbGxvY2F0b3JJaU5TSV8zM2RlZmF1bHRfdXNlcl9hbGxvY2F0b3JfbmV3X2RlbGV0ZUVOU3QzX18yNW11dGV4RUxqMzJFTGowRUVFTlMwXzE4RGVmYXVsdF9ldmVudF9iYXNlRU5TMF8xNkRlZmF1bHRfc3ViY3VydmVFRUVOU18yNUFycl9jb25zdHJ1Y3Rpb25fc3ViY3VydmVJU0FfU1FfU05fU1BfTlNfN0RlZmF1bHRFRUVFRVNTX0VFRUUATjRDR0FMMTVTdXJmYWNlX3N3ZWVwXzIzMU5vX2ludGVyc2VjdGlvbl9zdXJmYWNlX3N3ZWVwXzJJTlNfMjdBcnJfY29uc3RydWN0aW9uX3NzX3Zpc2l0b3JJTlNfMzhBcnJfYm91bmRlZF9wbGFuYXJfY29uc3RydWN0aW9uX2hlbHBlcklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18yNEFycmFuZ2VtZW50X29uX3N1cmZhY2VfMklTQV9OU18zNkFycl9ib3VuZGVkX3BsYW5hcl90b3BvbG9neV90cmFpdHNfMklTQV9OU18xNkFycl9kZWZhdWx0X2RjZWxJU0FfRUVFRUVFTlNfMjJBcnJfY29uc3RydWN0aW9uX2V2ZW50SVNBX1NHX041Ym9vc3QxOWZhc3RfcG9vbF9hbGxvY2F0b3JJaU5TSV8zM2RlZmF1bHRfdXNlcl9hbGxvY2F0b3JfbmV3X2RlbGV0ZUVOU3QzX18yNW11dGV4RUxqMzJFTGowRUVFTlMwXzE4RGVmYXVsdF9ldmVudF9iYXNlRU5TMF8xNkRlZmF1bHRfc3ViY3VydmVFRUVOU18yNUFycl9jb25zdHJ1Y3Rpb25fc3ViY3VydmVJU0FfU1FfU05fU1BfTlNfN0RlZmF1bHRFRUVFRVNTX0VFRUUAAABAfAAAZSoAAGh8AABEKAAAmCwAAAAAAACYLAAAggAAAIMAAACEAAAAhQAAAIYAAACHAAAAiAAAAIkAAAAAAAAAxC4AAIoAAACLAAAATjRDR0FMOE11bHRpc2V0SVBOU18yMkFycl9jb25zdHJ1Y3Rpb25fZXZlbnRJTlNfMjBBcnJfc2VnbWVudF90cmFpdHNfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFTlNfMjRBcnJhbmdlbWVudF9vbl9zdXJmYWNlXzJJUzhfTlNfMzZBcnJfYm91bmRlZF9wbGFuYXJfdG9wb2xvZ3lfdHJhaXRzXzJJUzhfTlNfMTZBcnJfZGVmYXVsdF9kY2VsSVM4X0VFRUVFRU41Ym9vc3QxOWZhc3RfcG9vbF9hbGxvY2F0b3JJaU5TRl8zM2RlZmF1bHRfdXNlcl9hbGxvY2F0b3JfbmV3X2RlbGV0ZUVOU3QzX18yNW11dGV4RUxqMzJFTGowRUVFTlNfMTVTdXJmYWNlX3N3ZWVwXzIxOERlZmF1bHRfZXZlbnRfYmFzZUVOU0xfMTZEZWZhdWx0X3N1YmN1cnZlRUVFTlNMXzE0RXZlbnRfY29tcGFyZXJJTlNfMjZBcnJfdHJhaXRzX2Jhc2ljX2FkYXB0b3JfMklTOF9FRVNPX0VFU0tfTlNfMTFCb29sZWFuX3RhZ0lMYjFFRUVFRQAAQHwAAOQsAAAAAAAA1DAAAIwAAACNAAAATjRDR0FMOE11bHRpc2V0SVBOU18yNUFycl9jb25zdHJ1Y3Rpb25fc3ViY3VydmVJTlNfMjBBcnJfc2VnbWVudF90cmFpdHNfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFTlNfMjJBcnJfY29uc3RydWN0aW9uX2V2ZW50SVM4X05TXzI0QXJyYW5nZW1lbnRfb25fc3VyZmFjZV8ySVM4X05TXzM2QXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18ySVM4X05TXzE2QXJyX2RlZmF1bHRfZGNlbElTOF9FRUVFRUVONWJvb3N0MTlmYXN0X3Bvb2xfYWxsb2NhdG9ySWlOU0dfMzNkZWZhdWx0X3VzZXJfYWxsb2NhdG9yX25ld19kZWxldGVFTlN0M19fMjVtdXRleEVMajMyRUxqMEVFRU5TXzE1U3VyZmFjZV9zd2VlcF8yMThEZWZhdWx0X2V2ZW50X2Jhc2VFTlNNXzE2RGVmYXVsdF9zdWJjdXJ2ZUVFRVNMX1NPX05TXzdEZWZhdWx0RUVFTlNNXzE0Q3VydmVfY29tcGFyZXJJUzhfU1BfU1JfRUVTTF9OU18xMUJvb2xlYW5fdGFnSUxiMEVFRUVFAAAAQHwAANwuAABONENHQUwxOUFzc2VydGlvbl9leGNlcHRpb25FAE40Q0dBTDE3RmFpbHVyZV9leGNlcHRpb25FAGh8AAD5MAAA1H0AAGh8AADcMAAAFDEAAAAAAAAgMQAABAAAAI8AAACQAAAAAAAAABQxAAAEAAAAkQAAAJAAAAAAAAAAuDoAAJIAAACTAAAAlAAAAJUAAACWAAAAlwAAAJgAAACZAAAAmgAAAJsAAABONENHQUwyNEFycl9pbnNlcnRpb25fc3NfdmlzaXRvcklOU18zNUFycl9ib3VuZGVkX3BsYW5hcl9pbnNlcnRpb25faGVscGVySU5TXzIyQXJyX2luc2VydGlvbl90cmFpdHNfMklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18yNEFycmFuZ2VtZW50X29uX3N1cmZhY2VfMklTOV9OU18zNkFycl9ib3VuZGVkX3BsYW5hcl90b3BvbG9neV90cmFpdHNfMklTOV9OU18xNkFycl9kZWZhdWx0X2RjZWxJUzlfRUVFRUVFRUVTRl9OU18yMkFycl9jb25zdHJ1Y3Rpb25fZXZlbnRJU0dfU0ZfTjVib29zdDE5ZmFzdF9wb29sX2FsbG9jYXRvcklpTlNJXzMzZGVmYXVsdF91c2VyX2FsbG9jYXRvcl9uZXdfZGVsZXRlRU5TdDNfXzI1bXV0ZXhFTGozMkVMajBFRUVOU18xNVN1cmZhY2Vfc3dlZXBfMjE4RGVmYXVsdF9ldmVudF9iYXNlRU5TT18xNkRlZmF1bHRfc3ViY3VydmVFRUVOU18yNUFycl9jb25zdHJ1Y3Rpb25fc3ViY3VydmVJU0dfU1JfU05fU1FfTlNfN0RlZmF1bHRFRUVFRVNUX0VFAE40Q0dBTDQwQXJyX25vX2ludGVyc2VjdGlvbl9pbnNlcnRpb25fc3NfdmlzaXRvcklOU18zNUFycl9ib3VuZGVkX3BsYW5hcl9pbnNlcnRpb25faGVscGVySU5TXzIyQXJyX2luc2VydGlvbl90cmFpdHNfMklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18yNEFycmFuZ2VtZW50X29uX3N1cmZhY2VfMklTOV9OU18zNkFycl9ib3VuZGVkX3BsYW5hcl90b3BvbG9neV90cmFpdHNfMklTOV9OU18xNkFycl9kZWZhdWx0X2RjZWxJUzlfRUVFRUVFRUVTRl9OU18yMkFycl9jb25zdHJ1Y3Rpb25fZXZlbnRJU0dfU0ZfTjVib29zdDE5ZmFzdF9wb29sX2FsbG9jYXRvcklpTlNJXzMzZGVmYXVsdF91c2VyX2FsbG9jYXRvcl9uZXdfZGVsZXRlRU5TdDNfXzI1bXV0ZXhFTGozMkVMajBFRUVOU18xNVN1cmZhY2Vfc3dlZXBfMjE4RGVmYXVsdF9ldmVudF9iYXNlRU5TT18xNkRlZmF1bHRfc3ViY3VydmVFRUVOU18yNUFycl9jb25zdHJ1Y3Rpb25fc3ViY3VydmVJU0dfU1JfU05fU1FfTlNfN0RlZmF1bHRFRUVFRU5TXzI0QXJyX2luc2VydGlvbl9zc192aXNpdG9ySVNWX1NUX0VFRUUATjRDR0FMMjdBcnJfY29uc3RydWN0aW9uX3NzX3Zpc2l0b3JJTlNfMzVBcnJfYm91bmRlZF9wbGFuYXJfaW5zZXJ0aW9uX2hlbHBlcklOU18yMkFycl9pbnNlcnRpb25fdHJhaXRzXzJJTlNfMjBBcnJfc2VnbWVudF90cmFpdHNfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFTlNfMjRBcnJhbmdlbWVudF9vbl9zdXJmYWNlXzJJUzlfTlNfMzZBcnJfYm91bmRlZF9wbGFuYXJfdG9wb2xvZ3lfdHJhaXRzXzJJUzlfTlNfMTZBcnJfZGVmYXVsdF9kY2VsSVM5X0VFRUVFRUVFU0ZfTlNfMjJBcnJfY29uc3RydWN0aW9uX2V2ZW50SVNHX1NGX041Ym9vc3QxOWZhc3RfcG9vbF9hbGxvY2F0b3JJaU5TSV8zM2RlZmF1bHRfdXNlcl9hbGxvY2F0b3JfbmV3X2RlbGV0ZUVOU3QzX18yNW11dGV4RUxqMzJFTGowRUVFTlNfMTVTdXJmYWNlX3N3ZWVwXzIxOERlZmF1bHRfZXZlbnRfYmFzZUVOU09fMTZEZWZhdWx0X3N1YmN1cnZlRUVFTlNfMjVBcnJfY29uc3RydWN0aW9uX3N1YmN1cnZlSVNHX1NSX1NOX1NRX05TXzdEZWZhdWx0RUVFRUVOU18yNEFycl9pbnNlcnRpb25fc3NfdmlzaXRvcklTVl9TVF9FRUVFAE40Q0dBTDE1U3VyZmFjZV9zd2VlcF8yMjBEZWZhdWx0X3Zpc2l0b3JfYmFzZUlOU18yMkFycl9pbnNlcnRpb25fdHJhaXRzXzJJTlNfMjBBcnJfc2VnbWVudF90cmFpdHNfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFTlNfMjRBcnJhbmdlbWVudF9vbl9zdXJmYWNlXzJJUzlfTlNfMzZBcnJfYm91bmRlZF9wbGFuYXJfdG9wb2xvZ3lfdHJhaXRzXzJJUzlfTlNfMTZBcnJfZGVmYXVsdF9kY2VsSVM5X0VFRUVFRUVFTlNfMjJBcnJfY29uc3RydWN0aW9uX2V2ZW50SVNHX1NGX041Ym9vc3QxOWZhc3RfcG9vbF9hbGxvY2F0b3JJaU5TSV8zM2RlZmF1bHRfdXNlcl9hbGxvY2F0b3JfbmV3X2RlbGV0ZUVOU3QzX18yNW11dGV4RUxqMzJFTGowRUVFTlMwXzE4RGVmYXVsdF9ldmVudF9iYXNlRU5TMF8xNkRlZmF1bHRfc3ViY3VydmVFRUVOU18yNUFycl9jb25zdHJ1Y3Rpb25fc3ViY3VydmVJU0dfU1FfU05fU1BfTlNfN0RlZmF1bHRFRUVTTl9OU18yNEFycl9pbnNlcnRpb25fc3NfdmlzaXRvcklOU18zNUFycl9ib3VuZGVkX3BsYW5hcl9pbnNlcnRpb25faGVscGVySVNHX1NGX1NRX1NUX0VFU1NfRUVFRQAAAEB8AABJOAAAaHwAAP81AACYOgAAaHwAAKgzAACgOgAAaHwAAIQxAACsOgAAAAAAAKA6AACcAAAAnQAAAJ4AAACfAAAAoAAAAKEAAACiAAAAAAAAABQ/AACjAAAApAAAAKUAAACmAAAApwAAAE40Q0dBTDM1QXJyX2JvdW5kZWRfcGxhbmFyX2luc2VydGlvbl9oZWxwZXJJTlNfMjJBcnJfaW5zZXJ0aW9uX3RyYWl0c18ySU5TXzIwQXJyX3NlZ21lbnRfdHJhaXRzXzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRU5TXzI0QXJyYW5nZW1lbnRfb25fc3VyZmFjZV8ySVM4X05TXzM2QXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18ySVM4X05TXzE2QXJyX2RlZmF1bHRfZGNlbElTOF9FRUVFRUVFRVNFX05TXzIyQXJyX2NvbnN0cnVjdGlvbl9ldmVudElTRl9TRV9ONWJvb3N0MTlmYXN0X3Bvb2xfYWxsb2NhdG9ySWlOU0hfMzNkZWZhdWx0X3VzZXJfYWxsb2NhdG9yX25ld19kZWxldGVFTlN0M19fMjVtdXRleEVMajMyRUxqMEVFRU5TXzE1U3VyZmFjZV9zd2VlcF8yMThEZWZhdWx0X2V2ZW50X2Jhc2VFTlNOXzE2RGVmYXVsdF9zdWJjdXJ2ZUVFRU5TXzI1QXJyX2NvbnN0cnVjdGlvbl9zdWJjdXJ2ZUlTRl9TUV9TTV9TUF9OU183RGVmYXVsdEVFRUVFAE40Q0dBTDM4QXJyX2JvdW5kZWRfcGxhbmFyX2NvbnN0cnVjdGlvbl9oZWxwZXJJTlNfMjJBcnJfaW5zZXJ0aW9uX3RyYWl0c18ySU5TXzIwQXJyX3NlZ21lbnRfdHJhaXRzXzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRU5TXzI0QXJyYW5nZW1lbnRfb25fc3VyZmFjZV8ySVM4X05TXzM2QXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18ySVM4X05TXzE2QXJyX2RlZmF1bHRfZGNlbElTOF9FRUVFRUVFRVNFX05TXzIyQXJyX2NvbnN0cnVjdGlvbl9ldmVudElTRl9TRV9ONWJvb3N0MTlmYXN0X3Bvb2xfYWxsb2NhdG9ySWlOU0hfMzNkZWZhdWx0X3VzZXJfYWxsb2NhdG9yX25ld19kZWxldGVFTlN0M19fMjVtdXRleEVMajMyRUxqMEVFRU5TXzE1U3VyZmFjZV9zd2VlcF8yMThEZWZhdWx0X2V2ZW50X2Jhc2VFTlNOXzE2RGVmYXVsdF9zdWJjdXJ2ZUVFRU5TXzI1QXJyX2NvbnN0cnVjdGlvbl9zdWJjdXJ2ZUlTRl9TUV9TTV9TUF9OU183RGVmYXVsdEVFRUVFAAAAAEB8AAAFPQAAaHwAAAQ7AAAMPwAAAAAAAAw/AACjAAAAqAAAAKUAAACmAAAApwAAAAAAAAD0QwAAqQAAAKoAAACrAAAArAAAAK0AAACuAAAArwAAALAAAABONENHQUwxNVN1cmZhY2Vfc3dlZXBfMjE1U3VyZmFjZV9zd2VlcF8ySU5TXzI0QXJyX2luc2VydGlvbl9zc192aXNpdG9ySU5TXzM1QXJyX2JvdW5kZWRfcGxhbmFyX2luc2VydGlvbl9oZWxwZXJJTlNfMjJBcnJfaW5zZXJ0aW9uX3RyYWl0c18ySU5TXzIwQXJyX3NlZ21lbnRfdHJhaXRzXzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRU5TXzI0QXJyYW5nZW1lbnRfb25fc3VyZmFjZV8ySVNCX05TXzM2QXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18ySVNCX05TXzE2QXJyX2RlZmF1bHRfZGNlbElTQl9FRUVFRUVFRVNIX05TXzIyQXJyX2NvbnN0cnVjdGlvbl9ldmVudElTSV9TSF9ONWJvb3N0MTlmYXN0X3Bvb2xfYWxsb2NhdG9ySWlOU0tfMzNkZWZhdWx0X3VzZXJfYWxsb2NhdG9yX25ld19kZWxldGVFTlN0M19fMjVtdXRleEVMajMyRUxqMEVFRU5TMF8xOERlZmF1bHRfZXZlbnRfYmFzZUVOUzBfMTZEZWZhdWx0X3N1YmN1cnZlRUVFTlNfMjVBcnJfY29uc3RydWN0aW9uX3N1YmN1cnZlSVNJX1NTX1NQX1NSX05TXzdEZWZhdWx0RUVFRUVTVV9FRUVFAE40Q0dBTDE1U3VyZmFjZV9zd2VlcF8yMzFOb19pbnRlcnNlY3Rpb25fc3VyZmFjZV9zd2VlcF8ySU5TXzI0QXJyX2luc2VydGlvbl9zc192aXNpdG9ySU5TXzM1QXJyX2JvdW5kZWRfcGxhbmFyX2luc2VydGlvbl9oZWxwZXJJTlNfMjJBcnJfaW5zZXJ0aW9uX3RyYWl0c18ySU5TXzIwQXJyX3NlZ21lbnRfdHJhaXRzXzJJTlNfOUNhcnRlc2lhbklOU184UXVvdGllbnRJTlNfOE1QX0Zsb2F0RUVFRUVFRU5TXzI0QXJyYW5nZW1lbnRfb25fc3VyZmFjZV8ySVNCX05TXzM2QXJyX2JvdW5kZWRfcGxhbmFyX3RvcG9sb2d5X3RyYWl0c18ySVNCX05TXzE2QXJyX2RlZmF1bHRfZGNlbElTQl9FRUVFRUVFRVNIX05TXzIyQXJyX2NvbnN0cnVjdGlvbl9ldmVudElTSV9TSF9ONWJvb3N0MTlmYXN0X3Bvb2xfYWxsb2NhdG9ySWlOU0tfMzNkZWZhdWx0X3VzZXJfYWxsb2NhdG9yX25ld19kZWxldGVFTlN0M19fMjVtdXRleEVMajMyRUxqMEVFRU5TMF8xOERlZmF1bHRfZXZlbnRfYmFzZUVOUzBfMTZEZWZhdWx0X3N1YmN1cnZlRUVFTlNfMjVBcnJfY29uc3RydWN0aW9uX3N1YmN1cnZlSVNJX1NTX1NQX1NSX05TXzdEZWZhdWx0RUVFRUVTVV9FRUVFAEB8AACgQQAAaHwAAGQ/AADsQwAAAAAAAOxDAACxAAAAsgAAALMAAAC0AAAAtQAAALYAAAC3AAAAuAAAAAAAAAA4RgAAuQAAALoAAABONENHQUw4TXVsdGlzZXRJUE5TXzIyQXJyX2NvbnN0cnVjdGlvbl9ldmVudElOU18yMkFycl9pbnNlcnRpb25fdHJhaXRzXzJJTlNfMjBBcnJfc2VnbWVudF90cmFpdHNfMklOU185Q2FydGVzaWFuSU5TXzhRdW90aWVudElOU184TVBfRmxvYXRFRUVFRUVFTlNfMjRBcnJhbmdlbWVudF9vbl9zdXJmYWNlXzJJUzlfTlNfMzZBcnJfYm91bmRlZF9wbGFuYXJfdG9wb2xvZ3lfdHJhaXRzXzJJUzlfTlNfMTZBcnJfZGVmYXVsdF9kY2VsSVM5X0VFRUVFRUVFU0ZfTjVib29zdDE5ZmFzdF9wb29sX2FsbG9jYXRvcklpTlNIXzMzZGVmYXVsdF91c2VyX2FsbG9jYXRvcl9uZXdfZGVsZXRlRU5TdDNfXzI1bXV0ZXhFTGozMkVMajBFRUVOU18xNVN1cmZhY2Vfc3dlZXBfMjE4RGVmYXVsdF9ldmVudF9iYXNlRU5TTl8xNkRlZmF1bHRfc3ViY3VydmVFRUVOU05fMTRFdmVudF9jb21wYXJlcklOU18yNkFycl90cmFpdHNfYmFzaWNfYWRhcHRvcl8ySVNHX0VFU1FfRUVTTV9OU18xMUJvb2xlYW5fdGFnSUxiMUVFRUVFAEB8AAA4RAAAAAAAAGhIAAC7AAAAvAAAAE40Q0dBTDhNdWx0aXNldElQTlNfMjVBcnJfY29uc3RydWN0aW9uX3N1YmN1cnZlSU5TXzIyQXJyX2luc2VydGlvbl90cmFpdHNfMklOU18yMEFycl9zZWdtZW50X3RyYWl0c18ySU5TXzlDYXJ0ZXNpYW5JTlNfOFF1b3RpZW50SU5TXzhNUF9GbG9hdEVFRUVFRUVOU18yNEFycmFuZ2VtZW50X29uX3N1cmZhY2VfMklTOV9OU18zNkFycl9ib3VuZGVkX3BsYW5hcl90b3BvbG9neV90cmFpdHNfMklTOV9OU18xNkFycl9kZWZhdWx0X2RjZWxJUzlfRUVFRUVFRUVOU18yMkFycl9jb25zdHJ1Y3Rpb25fZXZlbnRJU0dfU0ZfTjVib29zdDE5ZmFzdF9wb29sX2FsbG9jYXRvcklpTlNJXzMzZGVmYXVsdF91c2VyX2FsbG9jYXRvcl9uZXdfZGVsZXRlRU5TdDNfXzI1bXV0ZXhFTGozMkVMajBFRUVOU18xNVN1cmZhY2Vfc3dlZXBfMjE4RGVmYXVsdF9ldmVudF9iYXNlRU5TT18xNkRlZmF1bHRfc3ViY3VydmVFRUVTTl9TUV9OU183RGVmYXVsdEVFRU5TT18xNEN1cnZlX2NvbXBhcmVySVNHX1NSX1NUX0VFU05fTlNfMTFCb29sZWFuX3RhZ0lMYjBFRUVFRQAAQHwAAFBGAAABAAAAAgAAAAIAAAABAEGYkQELBQIAAAACAEGwkQELUQEAAAABAAAAkJ8AAAAAAAAZAAoAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkAEQoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBBkZIBCyEOAAAAAAAAAAAZAAoNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQcuSAQsBDABB15IBCxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQYWTAQsBEABBkZMBCxUPAAAABA8AAAAACRAAAAAAABAAABAAQb+TAQsBEgBBy5MBCx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQYKUAQsOGgAAABoaGgAAAAAAAAkAQbOUAQsBFABBv5QBCxUXAAAAABcAAAAACRQAAAAAABQAABQAQe2UAQsBFgBB+ZQBC4kSFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVG0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wABAgQHAwYFAAAAAAAAAAIAAMADAADABAAAwAUAAMAGAADABwAAwAgAAMAJAADACgAAwAsAAMAMAADADQAAwA4AAMAPAADAEAAAwBEAAMASAADAEwAAwBQAAMAVAADAFgAAwBcAAMAYAADAGQAAwBoAAMAbAADAHAAAwB0AAMAeAADAHwAAwAAAALMBAADDAgAAwwMAAMMEAADDBQAAwwYAAMMHAADDCAAAwwkAAMMKAADDCwAAwwwAAMMNAADTDgAAww8AAMMAAAy7AQAMwwIADMMDAAzDBAAM2wAAAAAA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";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}var binary=tryParseAsDataURI(file);if(binary){return binary}if(readBinary){return readBinary(file)}else {throw "both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else {if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response));},reject);})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"env":asmLibraryArg,"wasi_snapshot_preview1":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["memory"];assert(wasmMemory,"memory not found in wasm exports");updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["__indirect_function_table"];assert(wasmTable,"table not found in wasm exports");addOnInit(Module["asm"]["__wasm_call_ctors"]);removeRunDependency("wasm-instantiate");}addRunDependency("wasm-instantiate");var trueModule=Module;function receiveInstantiationResult(result){assert(Module===trueModule,"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");trueModule=null;receiveInstance(result["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);if(isFileURI(wasmBinaryFile)){err("warning: Loading from a file URI ("+wasmBinaryFile+") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");}abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else {return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return {}}function array_bounds_check_error(idx,size){throw "Array index "+idx+" out of bounds: [0,"+size+")"}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func=="number"){if(callback.arg===undefined){getWasmTableEntry(func)();}else {getWasmTableEntry(func)(callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}var wasmTableMirror=[];function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr);}assert(wasmTable.get(funcPtr)==func,"JavaScript-side Wasm function table mirror is out of date!");return func}function ___cxa_allocate_exception(size){return _malloc(size+24)+24}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type;};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor;};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount;};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught;};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown;};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false);};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1;};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;assert(prev>0);return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr;};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr};}function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch."}function _abort(){abort("native code called abort()");}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num);}function getHeapMax(){return 2147483648}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){err("emscripten_realloc_buffer: Attempted to grow heap from "+buffer.byteLength+" bytes to "+size+" bytes, but got error: "+e);}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;assert(requestedSize>oldSize);var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){err("Cannot enlarge memory, asked to go up to "+requestedSize+" bytes, but the limit is "+maxHeapSize+" bytes!");return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}err("Failed to grow the heap from "+oldSize+" bytes to "+newSize+" bytes, not enough memory!");return false}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x];}var strings=[];for(var x in env){strings.push(x+"="+env[x]);}getEnvStrings.strings=strings;}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1;});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1;});HEAPU32[penviron_buf_size>>2]=bufSize;return 0}function _exit(status){exit(status);}function _fd_close(fd){abort("fd_close called without SYSCALLS_REQUIRE_FILESYSTEM");}function _fd_read(fd,iov,iovcnt,pnum){abort("fd_read called without SYSCALLS_REQUIRE_FILESYSTEM");}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){return 70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];assert(buffer);if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0;}else {buffer.push(curr);}}function flush_NO_FILESYSTEM(){_fflush(0);if(printCharBuffers[1].length)printChar(1,10);if(printCharBuffers[2].length)printChar(2,10);}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j]);}num+=len;}HEAPU32[pnum>>2]=num;return 0}function _setTempRet0(val){}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1);}else {newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1);}}else {newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule]);}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value=="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str;}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate());}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else {return thisDate.getFullYear()}}else {return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return "\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return "AM"}else {return "PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return "\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},"%V":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++;}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++;}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1;}return leadingNulls(val,2)},"%w":function(date){return date.tm_wday},"%W":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},"%y":function(date){return (date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return (ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return "%"}};pattern=pattern.replace(/%%/g,"\0\0");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date));}}pattern=pattern.replace(/\0\0/g,"%");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){{assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.");}chr&=255;}ret.push(String.fromCharCode(chr));}return ret.join("")}var decodeBase64=typeof atob=="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output};function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE=="boolean"&&ENVIRONMENT_IS_NODE){var buf=Buffer.from(s,"base64");return new Uint8Array(buf["buffer"],buf["byteOffset"],buf["byteLength"])}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function checkIncomingModuleAPI(){ignoredModuleProp("fetchSettings");}var asmLibraryArg={"__cxa_allocate_exception":___cxa_allocate_exception,"__cxa_throw":___cxa_throw,"abort":_abort,"array_bounds_check_error":array_bounds_check_error,"emscripten_memcpy_big":_emscripten_memcpy_big,"emscripten_resize_heap":_emscripten_resize_heap,"environ_get":_environ_get,"environ_sizes_get":_environ_sizes_get,"exit":_exit,"fd_close":_fd_close,"fd_read":_fd_read,"fd_seek":_fd_seek,"fd_write":_fd_write,"setTempRet0":_setTempRet0,"strftime_l":_strftime_l};createWasm();Module["___wasm_call_ctors"]=createExportWrapper("__wasm_call_ctors");var _malloc=Module["_malloc"]=createExportWrapper("malloc");Module["_free"]=createExportWrapper("free");var _emscripten_bind_VoidPtr___destroy___0=Module["_emscripten_bind_VoidPtr___destroy___0"]=createExportWrapper("emscripten_bind_VoidPtr___destroy___0");var _emscripten_bind_ArrangementBuilder_ArrangementBuilder_0=Module["_emscripten_bind_ArrangementBuilder_ArrangementBuilder_0"]=createExportWrapper("emscripten_bind_ArrangementBuilder_ArrangementBuilder_0");var _emscripten_bind_ArrangementBuilder_getPolygons_1=Module["_emscripten_bind_ArrangementBuilder_getPolygons_1"]=createExportWrapper("emscripten_bind_ArrangementBuilder_getPolygons_1");var _emscripten_bind_ArrangementBuilder___destroy___0=Module["_emscripten_bind_ArrangementBuilder___destroy___0"]=createExportWrapper("emscripten_bind_ArrangementBuilder___destroy___0");var _emscripten_bind_Point_Point_0=Module["_emscripten_bind_Point_Point_0"]=createExportWrapper("emscripten_bind_Point_Point_0");var _emscripten_bind_Point_Point_2=Module["_emscripten_bind_Point_Point_2"]=createExportWrapper("emscripten_bind_Point_Point_2");var _emscripten_bind_Point_get_x_0=Module["_emscripten_bind_Point_get_x_0"]=createExportWrapper("emscripten_bind_Point_get_x_0");var _emscripten_bind_Point_set_x_1=Module["_emscripten_bind_Point_set_x_1"]=createExportWrapper("emscripten_bind_Point_set_x_1");var _emscripten_bind_Point_get_y_0=Module["_emscripten_bind_Point_get_y_0"]=createExportWrapper("emscripten_bind_Point_get_y_0");var _emscripten_bind_Point_set_y_1=Module["_emscripten_bind_Point_set_y_1"]=createExportWrapper("emscripten_bind_Point_set_y_1");var _emscripten_bind_Point___destroy___0=Module["_emscripten_bind_Point___destroy___0"]=createExportWrapper("emscripten_bind_Point___destroy___0");var _emscripten_bind_Polygon_Polygon_2=Module["_emscripten_bind_Polygon_Polygon_2"]=createExportWrapper("emscripten_bind_Polygon_Polygon_2");var _emscripten_bind_Polygon_getInsidePoint_1=Module["_emscripten_bind_Polygon_getInsidePoint_1"]=createExportWrapper("emscripten_bind_Polygon_getInsidePoint_1");var _emscripten_bind_Polygon_getPolyTristripArea_0=Module["_emscripten_bind_Polygon_getPolyTristripArea_0"]=createExportWrapper("emscripten_bind_Polygon_getPolyTristripArea_0");var _emscripten_bind_Polygon_get_contour_0=Module["_emscripten_bind_Polygon_get_contour_0"]=createExportWrapper("emscripten_bind_Polygon_get_contour_0");var _emscripten_bind_Polygon_set_contour_1=Module["_emscripten_bind_Polygon_set_contour_1"]=createExportWrapper("emscripten_bind_Polygon_set_contour_1");var _emscripten_bind_Polygon_get_holes_0=Module["_emscripten_bind_Polygon_get_holes_0"]=createExportWrapper("emscripten_bind_Polygon_get_holes_0");var _emscripten_bind_Polygon_set_holes_1=Module["_emscripten_bind_Polygon_set_holes_1"]=createExportWrapper("emscripten_bind_Polygon_set_holes_1");var _emscripten_bind_Polygon___destroy___0=Module["_emscripten_bind_Polygon___destroy___0"]=createExportWrapper("emscripten_bind_Polygon___destroy___0");var _emscripten_bind_PointList_PointList_0=Module["_emscripten_bind_PointList_PointList_0"]=createExportWrapper("emscripten_bind_PointList_PointList_0");var _emscripten_bind_PointList_push_back_1=Module["_emscripten_bind_PointList_push_back_1"]=createExportWrapper("emscripten_bind_PointList_push_back_1");var _emscripten_bind_PointList_size_0=Module["_emscripten_bind_PointList_size_0"]=createExportWrapper("emscripten_bind_PointList_size_0");var _emscripten_bind_PointList_at_1=Module["_emscripten_bind_PointList_at_1"]=createExportWrapper("emscripten_bind_PointList_at_1");var _emscripten_bind_PointList_clear_0=Module["_emscripten_bind_PointList_clear_0"]=createExportWrapper("emscripten_bind_PointList_clear_0");var _emscripten_bind_PointList___destroy___0=Module["_emscripten_bind_PointList___destroy___0"]=createExportWrapper("emscripten_bind_PointList___destroy___0");var _emscripten_bind_PolygonList_PolygonList_0=Module["_emscripten_bind_PolygonList_PolygonList_0"]=createExportWrapper("emscripten_bind_PolygonList_PolygonList_0");var _emscripten_bind_PolygonList_push_back_1=Module["_emscripten_bind_PolygonList_push_back_1"]=createExportWrapper("emscripten_bind_PolygonList_push_back_1");var _emscripten_bind_PolygonList_size_0=Module["_emscripten_bind_PolygonList_size_0"]=createExportWrapper("emscripten_bind_PolygonList_size_0");var _emscripten_bind_PolygonList_at_1=Module["_emscripten_bind_PolygonList_at_1"]=createExportWrapper("emscripten_bind_PolygonList_at_1");var _emscripten_bind_PolygonList_clear_0=Module["_emscripten_bind_PolygonList_clear_0"]=createExportWrapper("emscripten_bind_PolygonList_clear_0");var _emscripten_bind_PolygonList___destroy___0=Module["_emscripten_bind_PolygonList___destroy___0"]=createExportWrapper("emscripten_bind_PolygonList___destroy___0");var _emscripten_bind_Contour_Contour_0=Module["_emscripten_bind_Contour_Contour_0"]=createExportWrapper("emscripten_bind_Contour_Contour_0");var _emscripten_bind_Contour_push_back_1=Module["_emscripten_bind_Contour_push_back_1"]=createExportWrapper("emscripten_bind_Contour_push_back_1");var _emscripten_bind_Contour_size_0=Module["_emscripten_bind_Contour_size_0"]=createExportWrapper("emscripten_bind_Contour_size_0");var _emscripten_bind_Contour_at_1=Module["_emscripten_bind_Contour_at_1"]=createExportWrapper("emscripten_bind_Contour_at_1");var _emscripten_bind_Contour_clear_0=Module["_emscripten_bind_Contour_clear_0"]=createExportWrapper("emscripten_bind_Contour_clear_0");var _emscripten_bind_Contour___destroy___0=Module["_emscripten_bind_Contour___destroy___0"]=createExportWrapper("emscripten_bind_Contour___destroy___0");var _emscripten_bind_ContourList_ContourList_0=Module["_emscripten_bind_ContourList_ContourList_0"]=createExportWrapper("emscripten_bind_ContourList_ContourList_0");var _emscripten_bind_ContourList_push_back_1=Module["_emscripten_bind_ContourList_push_back_1"]=createExportWrapper("emscripten_bind_ContourList_push_back_1");var _emscripten_bind_ContourList_size_0=Module["_emscripten_bind_ContourList_size_0"]=createExportWrapper("emscripten_bind_ContourList_size_0");var _emscripten_bind_ContourList_at_1=Module["_emscripten_bind_ContourList_at_1"]=createExportWrapper("emscripten_bind_ContourList_at_1");var _emscripten_bind_ContourList_clear_0=Module["_emscripten_bind_ContourList_clear_0"]=createExportWrapper("emscripten_bind_ContourList_clear_0");var _emscripten_bind_ContourList___destroy___0=Module["_emscripten_bind_ContourList___destroy___0"]=createExportWrapper("emscripten_bind_ContourList___destroy___0");Module["___errno_location"]=createExportWrapper("__errno_location");var _fflush=Module["_fflush"]=createExportWrapper("fflush");var _emscripten_stack_init=Module["_emscripten_stack_init"]=function(){return (_emscripten_stack_init=Module["_emscripten_stack_init"]=Module["asm"]["emscripten_stack_init"]).apply(null,arguments)};Module["_emscripten_stack_get_free"]=function(){return (Module["_emscripten_stack_get_free"]=Module["asm"]["emscripten_stack_get_free"]).apply(null,arguments)};Module["_emscripten_stack_get_base"]=function(){return (Module["_emscripten_stack_get_base"]=Module["asm"]["emscripten_stack_get_base"]).apply(null,arguments)};var _emscripten_stack_get_end=Module["_emscripten_stack_get_end"]=function(){return (_emscripten_stack_get_end=Module["_emscripten_stack_get_end"]=Module["asm"]["emscripten_stack_get_end"]).apply(null,arguments)};Module["stackSave"]=createExportWrapper("stackSave");Module["stackRestore"]=createExportWrapper("stackRestore");Module["stackAlloc"]=createExportWrapper("stackAlloc");Module["___cxa_demangle"]=createExportWrapper("__cxa_demangle");var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=createExportWrapper("__cxa_is_pointer_type");Module["dynCall_jiji"]=createExportWrapper("dynCall_jiji");Module["dynCall_viijii"]=createExportWrapper("dynCall_viijii");Module["dynCall_iiiiij"]=createExportWrapper("dynCall_iiiiij");Module["dynCall_iiiiijj"]=createExportWrapper("dynCall_iiiiijj");Module["dynCall_iiiiiijj"]=createExportWrapper("dynCall_iiiiiijj");unexportedRuntimeFunction("ccall",false);unexportedRuntimeFunction("cwrap",false);unexportedRuntimeFunction("allocate",false);unexportedRuntimeFunction("UTF8ArrayToString",false);unexportedRuntimeFunction("UTF8ToString",false);unexportedRuntimeFunction("stringToUTF8Array",false);unexportedRuntimeFunction("stringToUTF8",false);unexportedRuntimeFunction("lengthBytesUTF8",false);unexportedRuntimeFunction("addOnPreRun",false);unexportedRuntimeFunction("addOnInit",false);unexportedRuntimeFunction("addOnPreMain",false);unexportedRuntimeFunction("addOnExit",false);unexportedRuntimeFunction("addOnPostRun",false);unexportedRuntimeFunction("addRunDependency",true);unexportedRuntimeFunction("removeRunDependency",true);unexportedRuntimeFunction("FS_createFolder",false);unexportedRuntimeFunction("FS_createPath",true);unexportedRuntimeFunction("FS_createDataFile",true);unexportedRuntimeFunction("FS_createPreloadedFile",true);unexportedRuntimeFunction("FS_createLazyFile",true);unexportedRuntimeFunction("FS_createLink",false);unexportedRuntimeFunction("FS_createDevice",true);unexportedRuntimeFunction("FS_unlink",true);unexportedRuntimeFunction("getLEB",false);unexportedRuntimeFunction("getFunctionTables",false);unexportedRuntimeFunction("alignFunctionTables",false);unexportedRuntimeFunction("registerFunctions",false);unexportedRuntimeFunction("addFunction",false);unexportedRuntimeFunction("removeFunction",false);unexportedRuntimeFunction("prettyPrint",false);unexportedRuntimeFunction("getCompilerSetting",false);unexportedRuntimeFunction("print",false);unexportedRuntimeFunction("printErr",false);unexportedRuntimeFunction("getTempRet0",false);unexportedRuntimeFunction("setTempRet0",false);unexportedRuntimeFunction("callMain",false);unexportedRuntimeFunction("abort",false);unexportedRuntimeFunction("keepRuntimeAlive",false);unexportedRuntimeFunction("wasmMemory",false);unexportedRuntimeFunction("warnOnce",false);unexportedRuntimeFunction("stackSave",false);unexportedRuntimeFunction("stackRestore",false);unexportedRuntimeFunction("stackAlloc",false);unexportedRuntimeFunction("AsciiToString",false);unexportedRuntimeFunction("stringToAscii",false);unexportedRuntimeFunction("UTF16ToString",false);unexportedRuntimeFunction("stringToUTF16",false);unexportedRuntimeFunction("lengthBytesUTF16",false);unexportedRuntimeFunction("UTF32ToString",false);unexportedRuntimeFunction("stringToUTF32",false);unexportedRuntimeFunction("lengthBytesUTF32",false);unexportedRuntimeFunction("allocateUTF8",false);unexportedRuntimeFunction("allocateUTF8OnStack",false);unexportedRuntimeFunction("ExitStatus",false);unexportedRuntimeFunction("intArrayFromString",false);unexportedRuntimeFunction("intArrayToString",false);unexportedRuntimeFunction("writeStringToMemory",false);unexportedRuntimeFunction("writeArrayToMemory",false);unexportedRuntimeFunction("writeAsciiToMemory",false);Module["writeStackCookie"]=writeStackCookie;Module["checkStackCookie"]=checkStackCookie;unexportedRuntimeFunction("intArrayFromBase64",false);unexportedRuntimeFunction("tryParseAsDataURI",false);unexportedRuntimeFunction("ptrToString",false);unexportedRuntimeFunction("zeroMemory",false);unexportedRuntimeFunction("stringToNewUTF8",false);unexportedRuntimeFunction("getHeapMax",false);unexportedRuntimeFunction("emscripten_realloc_buffer",false);unexportedRuntimeFunction("ENV",false);unexportedRuntimeFunction("ERRNO_CODES",false);unexportedRuntimeFunction("ERRNO_MESSAGES",false);unexportedRuntimeFunction("setErrNo",false);unexportedRuntimeFunction("inetPton4",false);unexportedRuntimeFunction("inetNtop4",false);unexportedRuntimeFunction("inetPton6",false);unexportedRuntimeFunction("inetNtop6",false);unexportedRuntimeFunction("readSockaddr",false);unexportedRuntimeFunction("writeSockaddr",false);unexportedRuntimeFunction("DNS",false);unexportedRuntimeFunction("getHostByName",false);unexportedRuntimeFunction("Protocols",false);unexportedRuntimeFunction("Sockets",false);unexportedRuntimeFunction("getRandomDevice",false);unexportedRuntimeFunction("traverseStack",false);unexportedRuntimeFunction("UNWIND_CACHE",false);unexportedRuntimeFunction("convertPCtoSourceLocation",false);unexportedRuntimeFunction("readAsmConstArgsArray",false);unexportedRuntimeFunction("readAsmConstArgs",false);unexportedRuntimeFunction("mainThreadEM_ASM",false);unexportedRuntimeFunction("jstoi_q",false);unexportedRuntimeFunction("jstoi_s",false);unexportedRuntimeFunction("getExecutableName",false);unexportedRuntimeFunction("listenOnce",false);unexportedRuntimeFunction("autoResumeAudioContext",false);unexportedRuntimeFunction("dynCallLegacy",false);unexportedRuntimeFunction("getDynCaller",false);unexportedRuntimeFunction("dynCall",false);unexportedRuntimeFunction("handleException",false);unexportedRuntimeFunction("runtimeKeepalivePush",false);unexportedRuntimeFunction("runtimeKeepalivePop",false);unexportedRuntimeFunction("callUserCallback",false);unexportedRuntimeFunction("maybeExit",false);unexportedRuntimeFunction("safeSetTimeout",false);unexportedRuntimeFunction("asmjsMangle",false);unexportedRuntimeFunction("asyncLoad",false);unexportedRuntimeFunction("alignMemory",false);unexportedRuntimeFunction("mmapAlloc",false);unexportedRuntimeFunction("writeI53ToI64",false);unexportedRuntimeFunction("writeI53ToI64Clamped",false);unexportedRuntimeFunction("writeI53ToI64Signaling",false);unexportedRuntimeFunction("writeI53ToU64Clamped",false);unexportedRuntimeFunction("writeI53ToU64Signaling",false);unexportedRuntimeFunction("readI53FromI64",false);unexportedRuntimeFunction("readI53FromU64",false);unexportedRuntimeFunction("convertI32PairToI53",false);unexportedRuntimeFunction("convertI32PairToI53Checked",false);unexportedRuntimeFunction("convertU32PairToI53",false);unexportedRuntimeFunction("reallyNegative",false);unexportedRuntimeFunction("unSign",false);unexportedRuntimeFunction("strLen",false);unexportedRuntimeFunction("reSign",false);unexportedRuntimeFunction("formatString",false);unexportedRuntimeFunction("setValue",false);unexportedRuntimeFunction("getValue",false);unexportedRuntimeFunction("PATH",false);unexportedRuntimeFunction("PATH_FS",false);unexportedRuntimeFunction("SYSCALLS",false);unexportedRuntimeFunction("getSocketFromFD",false);unexportedRuntimeFunction("getSocketAddress",false);unexportedRuntimeFunction("JSEvents",false);unexportedRuntimeFunction("registerKeyEventCallback",false);unexportedRuntimeFunction("specialHTMLTargets",false);unexportedRuntimeFunction("maybeCStringToJsString",false);unexportedRuntimeFunction("findEventTarget",false);unexportedRuntimeFunction("findCanvasEventTarget",false);unexportedRuntimeFunction("getBoundingClientRect",false);unexportedRuntimeFunction("fillMouseEventData",false);unexportedRuntimeFunction("registerMouseEventCallback",false);unexportedRuntimeFunction("registerWheelEventCallback",false);unexportedRuntimeFunction("registerUiEventCallback",false);unexportedRuntimeFunction("registerFocusEventCallback",false);unexportedRuntimeFunction("fillDeviceOrientationEventData",false);unexportedRuntimeFunction("registerDeviceOrientationEventCallback",false);unexportedRuntimeFunction("fillDeviceMotionEventData",false);unexportedRuntimeFunction("registerDeviceMotionEventCallback",false);unexportedRuntimeFunction("screenOrientation",false);unexportedRuntimeFunction("fillOrientationChangeEventData",false);unexportedRuntimeFunction("registerOrientationChangeEventCallback",false);unexportedRuntimeFunction("fillFullscreenChangeEventData",false);unexportedRuntimeFunction("registerFullscreenChangeEventCallback",false);unexportedRuntimeFunction("JSEvents_requestFullscreen",false);unexportedRuntimeFunction("JSEvents_resizeCanvasForFullscreen",false);unexportedRuntimeFunction("registerRestoreOldStyle",false);unexportedRuntimeFunction("hideEverythingExceptGivenElement",false);unexportedRuntimeFunction("restoreHiddenElements",false);unexportedRuntimeFunction("setLetterbox",false);unexportedRuntimeFunction("currentFullscreenStrategy",false);unexportedRuntimeFunction("restoreOldWindowedStyle",false);unexportedRuntimeFunction("softFullscreenResizeWebGLRenderTarget",false);unexportedRuntimeFunction("doRequestFullscreen",false);unexportedRuntimeFunction("fillPointerlockChangeEventData",false);unexportedRuntimeFunction("registerPointerlockChangeEventCallback",false);unexportedRuntimeFunction("registerPointerlockErrorEventCallback",false);unexportedRuntimeFunction("requestPointerLock",false);unexportedRuntimeFunction("fillVisibilityChangeEventData",false);unexportedRuntimeFunction("registerVisibilityChangeEventCallback",false);unexportedRuntimeFunction("registerTouchEventCallback",false);unexportedRuntimeFunction("fillGamepadEventData",false);unexportedRuntimeFunction("registerGamepadEventCallback",false);unexportedRuntimeFunction("registerBeforeUnloadEventCallback",false);unexportedRuntimeFunction("fillBatteryEventData",false);unexportedRuntimeFunction("battery",false);unexportedRuntimeFunction("registerBatteryEventCallback",false);unexportedRuntimeFunction("setCanvasElementSize",false);unexportedRuntimeFunction("getCanvasElementSize",false);unexportedRuntimeFunction("demangle",false);unexportedRuntimeFunction("demangleAll",false);unexportedRuntimeFunction("jsStackTrace",false);unexportedRuntimeFunction("stackTrace",false);unexportedRuntimeFunction("getEnvStrings",false);unexportedRuntimeFunction("checkWasiClock",false);unexportedRuntimeFunction("flush_NO_FILESYSTEM",false);unexportedRuntimeFunction("dlopenMissingError",false);unexportedRuntimeFunction("setImmediateWrapped",false);unexportedRuntimeFunction("clearImmediateWrapped",false);unexportedRuntimeFunction("polyfillSetImmediate",false);unexportedRuntimeFunction("uncaughtExceptionCount",false);unexportedRuntimeFunction("exceptionLast",false);unexportedRuntimeFunction("exceptionCaught",false);unexportedRuntimeFunction("ExceptionInfo",false);unexportedRuntimeFunction("exception_addRef",false);unexportedRuntimeFunction("exception_decRef",false);unexportedRuntimeFunction("Browser",false);unexportedRuntimeFunction("setMainLoop",false);unexportedRuntimeFunction("wget",false);unexportedRuntimeFunction("tempFixedLengthArray",false);unexportedRuntimeFunction("miniTempWebGLFloatBuffers",false);unexportedRuntimeFunction("heapObjectForWebGLType",false);unexportedRuntimeFunction("heapAccessShiftForWebGLHeap",false);unexportedRuntimeFunction("GL",false);unexportedRuntimeFunction("emscriptenWebGLGet",false);unexportedRuntimeFunction("computeUnpackAlignedImageSize",false);unexportedRuntimeFunction("emscriptenWebGLGetTexPixelData",false);unexportedRuntimeFunction("emscriptenWebGLGetUniform",false);unexportedRuntimeFunction("webglGetUniformLocation",false);unexportedRuntimeFunction("webglPrepareUniformLocationsBeforeFirstUse",false);unexportedRuntimeFunction("webglGetLeftBracePos",false);unexportedRuntimeFunction("emscriptenWebGLGetVertexAttrib",false);unexportedRuntimeFunction("writeGLArray",false);unexportedRuntimeFunction("AL",false);unexportedRuntimeFunction("SDL_unicode",false);unexportedRuntimeFunction("SDL_ttfContext",false);unexportedRuntimeFunction("SDL_audio",false);unexportedRuntimeFunction("SDL",false);unexportedRuntimeFunction("SDL_gfx",false);unexportedRuntimeFunction("GLUT",false);unexportedRuntimeFunction("EGL",false);unexportedRuntimeFunction("GLFW_Window",false);unexportedRuntimeFunction("GLFW",false);unexportedRuntimeFunction("GLEW",false);unexportedRuntimeFunction("IDBStore",false);unexportedRuntimeFunction("runAndAbortIfError",false);unexportedRuntimeSymbol("ALLOC_NORMAL",false);unexportedRuntimeSymbol("ALLOC_STACK",false);var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status;}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function stackCheckInit(){_emscripten_stack_init();writeStackCookie();}function run(args){if(runDependencies>0){return}stackCheckInit();preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();assert(!Module["_main"],'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}checkStackCookie();}Module["run"]=run;function checkUnflushedContent(){var oldOut=out;var oldErr=err;var has=false;out=err=x=>{has=true;};try{flush_NO_FILESYSTEM();}catch(e){}out=oldOut;err=oldErr;if(has){warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.");warnOnce("(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)");}}function exit(status,implicit){checkUnflushedContent();if(keepRuntimeAlive()&&!implicit){var msg="program exited (with status: "+status+"), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)";readyPromiseReject(msg);err(msg);}procExit(status);}function procExit(code){if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true;}quit_(code,new ExitStatus(code));}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}run();function WrapperObject(){}WrapperObject.prototype=Object.create(WrapperObject.prototype);WrapperObject.prototype.constructor=WrapperObject;WrapperObject.prototype.__class__=WrapperObject;WrapperObject.__cache__={};Module["WrapperObject"]=WrapperObject;function getCache(__class__){return (__class__||WrapperObject).__cache__}Module["getCache"]=getCache;function wrapPointer(ptr,__class__){var cache=getCache(__class__);var ret=cache[ptr];if(ret)return ret;ret=Object.create((__class__||WrapperObject).prototype);ret.ptr=ptr;return cache[ptr]=ret}Module["wrapPointer"]=wrapPointer;function castObject(obj,__class__){return wrapPointer(obj.ptr,__class__)}Module["castObject"]=castObject;Module["NULL"]=wrapPointer(0);function destroy(obj){if(!obj["__destroy__"])throw "Error: Cannot destroy object. (Did you create it yourself?)";obj["__destroy__"]();delete getCache(obj.__class__)[obj.ptr];}Module["destroy"]=destroy;function compare(obj1,obj2){return obj1.ptr===obj2.ptr}Module["compare"]=compare;function getPointer(obj){return obj.ptr}Module["getPointer"]=getPointer;function getClass(obj){return obj.__class__}Module["getClass"]=getClass;function VoidPtr(){throw "cannot construct a VoidPtr, no constructor in IDL"}VoidPtr.prototype=Object.create(WrapperObject.prototype);VoidPtr.prototype.constructor=VoidPtr;VoidPtr.prototype.__class__=VoidPtr;VoidPtr.__cache__={};Module["VoidPtr"]=VoidPtr;VoidPtr.prototype["__destroy__"]=VoidPtr.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_VoidPtr___destroy___0(self);};function ArrangementBuilder(){this.ptr=_emscripten_bind_ArrangementBuilder_ArrangementBuilder_0();getCache(ArrangementBuilder)[this.ptr]=this;}ArrangementBuilder.prototype=Object.create(WrapperObject.prototype);ArrangementBuilder.prototype.constructor=ArrangementBuilder;ArrangementBuilder.prototype.__class__=ArrangementBuilder;ArrangementBuilder.__cache__={};Module["ArrangementBuilder"]=ArrangementBuilder;ArrangementBuilder.prototype["getPolygons"]=ArrangementBuilder.prototype.getPolygons=function(points){var self=this.ptr;if(points&&typeof points==="object")points=points.ptr;return wrapPointer(_emscripten_bind_ArrangementBuilder_getPolygons_1(self,points),PolygonList)};ArrangementBuilder.prototype["__destroy__"]=ArrangementBuilder.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_ArrangementBuilder___destroy___0(self);};function Point(x,y){if(x&&typeof x==="object")x=x.ptr;if(y&&typeof y==="object")y=y.ptr;if(x===undefined){this.ptr=_emscripten_bind_Point_Point_0();getCache(Point)[this.ptr]=this;return}if(y===undefined){this.ptr=_emscripten_bind_Point_Point_1(x);getCache(Point)[this.ptr]=this;return}this.ptr=_emscripten_bind_Point_Point_2(x,y);getCache(Point)[this.ptr]=this;}Point.prototype=Object.create(WrapperObject.prototype);Point.prototype.constructor=Point;Point.prototype.__class__=Point;Point.__cache__={};Module["Point"]=Point;Point.prototype["get_x"]=Point.prototype.get_x=function(){var self=this.ptr;return _emscripten_bind_Point_get_x_0(self)};Point.prototype["set_x"]=Point.prototype.set_x=function(arg0){var self=this.ptr;if(arg0&&typeof arg0==="object")arg0=arg0.ptr;_emscripten_bind_Point_set_x_1(self,arg0);};Object.defineProperty(Point.prototype,"x",{get:Point.prototype.get_x,set:Point.prototype.set_x});Point.prototype["get_y"]=Point.prototype.get_y=function(){var self=this.ptr;return _emscripten_bind_Point_get_y_0(self)};Point.prototype["set_y"]=Point.prototype.set_y=function(arg0){var self=this.ptr;if(arg0&&typeof arg0==="object")arg0=arg0.ptr;_emscripten_bind_Point_set_y_1(self,arg0);};Object.defineProperty(Point.prototype,"y",{get:Point.prototype.get_y,set:Point.prototype.set_y});Point.prototype["__destroy__"]=Point.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_Point___destroy___0(self);};function Polygon(contour,holes){if(contour&&typeof contour==="object")contour=contour.ptr;if(holes&&typeof holes==="object")holes=holes.ptr;this.ptr=_emscripten_bind_Polygon_Polygon_2(contour,holes);getCache(Polygon)[this.ptr]=this;}Polygon.prototype=Object.create(WrapperObject.prototype);Polygon.prototype.constructor=Polygon;Polygon.prototype.__class__=Polygon;Polygon.__cache__={};Module["Polygon"]=Polygon;Polygon.prototype["getInsidePoint"]=Polygon.prototype.getInsidePoint=function(point){var self=this.ptr;if(point&&typeof point==="object")point=point.ptr;return !!_emscripten_bind_Polygon_getInsidePoint_1(self,point)};Polygon.prototype["getPolyTristripArea"]=Polygon.prototype.getPolyTristripArea=function(){var self=this.ptr;return _emscripten_bind_Polygon_getPolyTristripArea_0(self)};Polygon.prototype["get_contour"]=Polygon.prototype.get_contour=function(){var self=this.ptr;return wrapPointer(_emscripten_bind_Polygon_get_contour_0(self),Contour)};Polygon.prototype["set_contour"]=Polygon.prototype.set_contour=function(arg0){var self=this.ptr;if(arg0&&typeof arg0==="object")arg0=arg0.ptr;_emscripten_bind_Polygon_set_contour_1(self,arg0);};Object.defineProperty(Polygon.prototype,"contour",{get:Polygon.prototype.get_contour,set:Polygon.prototype.set_contour});Polygon.prototype["get_holes"]=Polygon.prototype.get_holes=function(){var self=this.ptr;return wrapPointer(_emscripten_bind_Polygon_get_holes_0(self),ContourList)};Polygon.prototype["set_holes"]=Polygon.prototype.set_holes=function(arg0){var self=this.ptr;if(arg0&&typeof arg0==="object")arg0=arg0.ptr;_emscripten_bind_Polygon_set_holes_1(self,arg0);};Object.defineProperty(Polygon.prototype,"holes",{get:Polygon.prototype.get_holes,set:Polygon.prototype.set_holes});Polygon.prototype["__destroy__"]=Polygon.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_Polygon___destroy___0(self);};function PointList(){this.ptr=_emscripten_bind_PointList_PointList_0();getCache(PointList)[this.ptr]=this;}PointList.prototype=Object.create(WrapperObject.prototype);PointList.prototype.constructor=PointList;PointList.prototype.__class__=PointList;PointList.__cache__={};Module["PointList"]=PointList;PointList.prototype["push_back"]=PointList.prototype.push_back=function(s){var self=this.ptr;if(s&&typeof s==="object")s=s.ptr;_emscripten_bind_PointList_push_back_1(self,s);};PointList.prototype["size"]=PointList.prototype.size=function(){var self=this.ptr;return _emscripten_bind_PointList_size_0(self)};PointList.prototype["at"]=PointList.prototype.at=function(i){var self=this.ptr;if(i&&typeof i==="object")i=i.ptr;return wrapPointer(_emscripten_bind_PointList_at_1(self,i),Point)};PointList.prototype["clear"]=PointList.prototype.clear=function(){var self=this.ptr;_emscripten_bind_PointList_clear_0(self);};PointList.prototype["__destroy__"]=PointList.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_PointList___destroy___0(self);};function PolygonList(){this.ptr=_emscripten_bind_PolygonList_PolygonList_0();getCache(PolygonList)[this.ptr]=this;}PolygonList.prototype=Object.create(WrapperObject.prototype);PolygonList.prototype.constructor=PolygonList;PolygonList.prototype.__class__=PolygonList;PolygonList.__cache__={};Module["PolygonList"]=PolygonList;PolygonList.prototype["push_back"]=PolygonList.prototype.push_back=function(s){var self=this.ptr;if(s&&typeof s==="object")s=s.ptr;_emscripten_bind_PolygonList_push_back_1(self,s);};PolygonList.prototype["size"]=PolygonList.prototype.size=function(){var self=this.ptr;return _emscripten_bind_PolygonList_size_0(self)};PolygonList.prototype["at"]=PolygonList.prototype.at=function(i){var self=this.ptr;if(i&&typeof i==="object")i=i.ptr;return wrapPointer(_emscripten_bind_PolygonList_at_1(self,i),Polygon)};PolygonList.prototype["clear"]=PolygonList.prototype.clear=function(){var self=this.ptr;_emscripten_bind_PolygonList_clear_0(self);};PolygonList.prototype["__destroy__"]=PolygonList.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_PolygonList___destroy___0(self);};function Contour(){this.ptr=_emscripten_bind_Contour_Contour_0();getCache(Contour)[this.ptr]=this;}Contour.prototype=Object.create(WrapperObject.prototype);Contour.prototype.constructor=Contour;Contour.prototype.__class__=Contour;Contour.__cache__={};Module["Contour"]=Contour;Contour.prototype["push_back"]=Contour.prototype.push_back=function(s){var self=this.ptr;if(s&&typeof s==="object")s=s.ptr;_emscripten_bind_Contour_push_back_1(self,s);};Contour.prototype["size"]=Contour.prototype.size=function(){var self=this.ptr;return _emscripten_bind_Contour_size_0(self)};Contour.prototype["at"]=Contour.prototype.at=function(i){var self=this.ptr;if(i&&typeof i==="object")i=i.ptr;return wrapPointer(_emscripten_bind_Contour_at_1(self,i),Point)};Contour.prototype["clear"]=Contour.prototype.clear=function(){var self=this.ptr;_emscripten_bind_Contour_clear_0(self);};Contour.prototype["__destroy__"]=Contour.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_Contour___destroy___0(self);};function ContourList(){this.ptr=_emscripten_bind_ContourList_ContourList_0();getCache(ContourList)[this.ptr]=this;}ContourList.prototype=Object.create(WrapperObject.prototype);ContourList.prototype.constructor=ContourList;ContourList.prototype.__class__=ContourList;ContourList.__cache__={};Module["ContourList"]=ContourList;ContourList.prototype["push_back"]=ContourList.prototype.push_back=function(s){var self=this.ptr;if(s&&typeof s==="object")s=s.ptr;_emscripten_bind_ContourList_push_back_1(self,s);};ContourList.prototype["size"]=ContourList.prototype.size=function(){var self=this.ptr;return _emscripten_bind_ContourList_size_0(self)};ContourList.prototype["at"]=ContourList.prototype.at=function(i){var self=this.ptr;if(i&&typeof i==="object")i=i.ptr;return wrapPointer(_emscripten_bind_ContourList_at_1(self,i),Contour)};ContourList.prototype["clear"]=ContourList.prototype.clear=function(){var self=this.ptr;_emscripten_bind_ContourList_clear_0(self);};ContourList.prototype["__destroy__"]=ContourList.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_ContourList___destroy___0(self);};


  return Arrangement2D.ready
}
);
})();

// Author: Axel Antoine
class Polygon$1 {
    id;
    mesh;
    color = new Color$1();
    insidePoint;
    contour;
    holes;
    constructor(id, contour, holes, insidePoint) {
        this.id = id;
        this.contour = contour;
        this.holes = holes;
        this.insidePoint = insidePoint;
    }
}

// Author: Axel Antoine
// Make the wrapper a global promise so it is load once
const Arr2DPromise = Arrangement2D();
async function computePolygons(contours) {
    const Arr2D = await Arr2DPromise;
    const points = new Arr2D.PointList();
    let a, b;
    for (const contour of contours) {
        a = new Arr2D.Point(contour.points[0].x, contour.points[0].y);
        for (let i = 1; i < contour.points.length; i++) {
            b = new Arr2D.Point(contour.points[i].x, contour.points[i].y);
            points.push_back(a);
            points.push_back(b);
            a = b;
        }
    }
    const builder = new Arr2D.ArrangementBuilder();
    const arr2DPolygonlist = builder.getPolygons(points);
    const p = new Arr2D.Point();
    const polygons = new Array();
    let nbIgnored = 0;
    let nbErrors = 0;
    for (let i = 0; i < arr2DPolygonlist.size(); i++) {
        const arr2DPolygon = arr2DPolygonlist.at(i);
        const area = arr2DPolygon.getPolyTristripArea();
        if (area > 1e-10) {
            // Transform contour and holes from the Arrangement2D to more friendly three types
            const contour = convertContour(arr2DPolygon.contour);
            const holes = convertContourList(arr2DPolygon.holes);
            const insidePoint = new Vector2();
            if (arr2DPolygon.getInsidePoint(p)) {
                insidePoint.set(p.x, p.y);
                const polygon = new Polygon$1(i, contour, holes, insidePoint);
                polygons.push(polygon);
            }
            else {
                console.error("Could not obtain a point inside a CGAL region.");
                nbErrors += 1;
            }
        }
        else {
            nbIgnored += 1;
        }
        Arr2D.destroy(arr2DPolygon);
    }
    Arr2D.destroy(arr2DPolygonlist);
    Arr2D.destroy(p);
    return {
        polygons: polygons,
        nbErrors: nbErrors,
        nbIgnored: nbIgnored
    };
}
function convertContourList(vector) {
    const array = new Array();
    for (let i = 0; i < vector.size(); i++) {
        array.push(convertContour(vector.at(i)));
    }
    return array;
}
function convertContour(contour) {
    const array = new Array();
    for (let i = 0; i < contour.size(); i++) {
        const p = contour.at(i);
        array.push(new Vector2(p.x, p.y));
    }
    return array;
}

const EPSILON$1 = 1e-10;
const _tmp1 = new Vector3();
const _tmp2 = new Vector3();
const _matrix4 = new Matrix4();
const _matrix3 = new Matrix3();
function isTriDegenerated(tri) {
    _tmp1.subVectors(tri.a, tri.b);
    _tmp2.subVectors(tri.a, tri.c);
    _tmp1.cross(_tmp2);
    return _tmp1.x > -EPSILON$1 && _tmp1.x < EPSILON$1 &&
        _tmp1.y > -EPSILON$1 && _tmp1.y < EPSILON$1 &&
        _tmp1.z > -EPSILON$1 && _tmp1.z < EPSILON$1;
}
function orient3D(a, b, c, d) {
    _matrix4.set(a.x, a.y, a.z, 1, b.x, b.y, b.z, 1, c.x, c.y, c.z, 1, d.x, d.y, d.z, 1);
    const det = _matrix4.determinant();
    if (det < -EPSILON$1)
        return -1;
    else if (det > EPSILON$1)
        return 1;
    else
        return 0;
}
function orient2D(a, b, c) {
    _matrix3.set(a.x, a.y, 1, b.x, b.y, 1, c.x, c.y, 1);
    const det = _matrix3.determinant();
    if (det < -EPSILON$1)
        return -1;
    else if (det > EPSILON$1)
        return 1;
    else
        return 0;
}
function permuteTriLeft(tri) {
    const tmp = tri.a;
    tri.a = tri.b;
    tri.b = tri.c;
    tri.c = tmp;
}
function permuteTriRight(tri) {
    const tmp = tri.c;
    tri.c = tri.b;
    tri.b = tri.a;
    tri.a = tmp;
}
function makeTriCounterClockwise(tri) {
    if (orient2D(tri.a, tri.b, tri.c) <= 0) {
        const tmp = tri.c;
        tri.c = tri.b;
        tri.b = tmp;
    }
}
function linesIntersect2d(a1, b1, a2, b2, target) {
    const dx1 = (a1.x - b1.x);
    const dx2 = (a2.x - b2.x);
    const dy1 = (a1.y - b1.y);
    const dy2 = (a2.y - b2.y);
    const D = dx1 * dy2 - dx2 * dy1;
    const n1 = a1.x * b1.y - a1.y * b1.x;
    const n2 = a2.x * b2.y - a2.y * b2.x;
    target.set((n1 * dx2 - n2 * dx1) / D, (n1 * dy2 - n2 * dy1) / D, 0);
}

const EPSILON = 1e-10;
const _u$1 = new Vector3();
const _v$1 = new Vector3();
const _n1 = new Vector3();
const _n2 = new Vector3();
const _i1 = new Vector3();
const _i2 = new Vector3();
function crossIntersect(t1, t2, o1a, o1b, o1c, target) {
    const o2a = orient3D(t1.a, t1.b, t1.c, t2.a);
    const o2b = orient3D(t1.a, t1.b, t1.c, t2.b);
    const o2c = orient3D(t1.a, t1.b, t1.c, t2.c);
    if (o2a === o2b && o2a === o2c) {
        return false;
    }
    makeTriAVertexAlone(t1, o1a, o1b, o1c);
    makeTriAVertexAlone(t2, o2a, o2b, o2c);
    makeTriAVertexPositive(t2, t1);
    makeTriAVertexPositive(t1, t2);
    const o1 = orient3D(t1.a, t1.b, t2.a, t2.b);
    const o2 = orient3D(t1.a, t1.c, t2.c, t2.a);
    if (o1 <= 0 && o2 <= 0) {
        if (target) {
            computeLineIntersection(t1, t2, target);
        }
        return true;
    }
    return false;
}
function makeTriAVertexAlone(tri, oa, ob, oc) {
    if (oa === ob) {
        permuteTriRight(tri);
    }
    else if (oa === oc) {
        permuteTriLeft(tri);
    }
    else if (ob !== oc) {
        if (ob > 0) {
            permuteTriLeft(tri);
        }
        else if (oc > 0) {
            permuteTriRight(tri);
        }
    }
}
function makeTriAVertexPositive(tri, other) {
    const o = orient3D(other.a, other.b, other.c, tri.a);
    if (o < 0) {
        const tmp = other.c;
        other.c = other.b;
        other.b = tmp;
    }
}
function intersectPlane(a, b, p, n, target) {
    _u$1.subVectors(b, a);
    _v$1.subVectors(a, p);
    const dot1 = n.dot(_u$1);
    const dot2 = n.dot(_v$1);
    _u$1.multiplyScalar(-dot2 / dot1);
    target.addVectors(a, _u$1);
}
function computeLineIntersection(t1, t2, target) {
    t1.getNormal(_n1);
    t2.getNormal(_n2);
    const o1 = orient3D(t1.a, t1.c, t2.b, t2.a);
    const o2 = orient3D(t1.a, t1.b, t2.c, t2.a);
    if (o1 > 0) {
        if (o2 > 0) {
            intersectPlane(t1.a, t1.c, t2.a, _n2, _i1);
            intersectPlane(t2.a, t2.c, t1.a, _n1, _i2);
        }
        else {
            intersectPlane(t1.a, t1.c, t2.a, _n2, _i1);
            intersectPlane(t1.a, t1.b, t2.a, _n2, _i2);
        }
    }
    else {
        if (o2 > 0) {
            intersectPlane(t2.a, t2.b, t1.a, _n1, _i1);
            intersectPlane(t2.a, t2.c, t1.a, _n1, _i2);
        }
        else {
            intersectPlane(t2.a, t2.b, t1.a, _n1, _i1);
            intersectPlane(t1.a, t1.b, t2.a, _n2, _i2);
        }
    }
    target.push(_i1.clone());
    if (_i1.distanceTo(_i2) >= EPSILON) {
        target.push(_i2.clone());
    }
}

const _matrix = new Matrix4();
const _n = new Vector3();
const _u = new Vector3();
const _v = new Vector3();
const _affineMatrix = new Matrix4().set(0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1);
function coplanarIntersect(t1, t2, target) {
    t1.getNormal(_n);
    _u.subVectors(t1.a, t1.b).normalize();
    _v.crossVectors(_n, _u);
    _u.add(t1.a);
    _v.add(t1.a);
    _n.add(t1.a);
    _matrix.set(t1.a.x, _u.x, _v.x, _n.x, t1.a.y, _u.y, _v.y, _n.y, t1.a.z, _u.z, _v.z, _n.z, 1, 1, 1, 1);
    _matrix.invert();
    _matrix.premultiply(_affineMatrix);
    t1.a.applyMatrix4(_matrix);
    t1.b.applyMatrix4(_matrix);
    t1.c.applyMatrix4(_matrix);
    t2.a.applyMatrix4(_matrix);
    t2.b.applyMatrix4(_matrix);
    t2.c.applyMatrix4(_matrix);
    makeTriCounterClockwise(t1);
    makeTriCounterClockwise(t2);
    const o_ab = orient2D(t2.a, t2.b, t1.a);
    const o_bc = orient2D(t2.b, t2.c, t1.a);
    const o_ca = orient2D(t2.c, t2.a, t1.a);
    if (o_ab === 0 && o_bc === 0 && o_ca === 0) {
        console.error("Triangles should not be flat.", t1, t2, _v);
        return false;
    }
    let intersecting = false;
    if (o_ab >= 0) {
        if (o_bc >= 0) {
            if (o_ca >= 0) {
                intersecting = true;
            }
            else {
                intersecting = intersectionTypeR1(t1, t2);
            }
        }
        else {
            if (o_ca >= 0) {
                permuteTriRight(t2);
                intersecting = intersectionTypeR1(t1, t2);
            }
            else {
                intersecting = intersectionTypeR2(t1, t2);
            }
        }
    }
    else {
        if (o_bc >= 0) {
            if (o_ca >= 0) {
                permuteTriLeft(t2);
                intersecting = intersectionTypeR1(t1, t2);
            }
            else {
                permuteTriLeft(t2);
                intersecting = intersectionTypeR2(t1, t2);
            }
        }
        else {
            permuteTriRight(t2);
            intersecting = intersectionTypeR2(t1, t2);
        }
    }
    if (intersecting && target) {
        clipTriangle(t1, t2, target);
        _matrix.invert();
        for (const p of target) {
            p.applyMatrix4(_matrix);
        }
    }
    return intersecting;
}
function intersectionTypeR1(t1, t2) {
    const p1 = t1.a;
    const q1 = t1.b;
    const r1 = t1.c;
    const p2 = t2.a;
    const r2 = t2.c;
    if (orient2D(r2, p2, q1) >= 0) {
        if (orient2D(r2, p1, q1) >= 0) {
            if (orient2D(p1, p2, q1) >= 0) {
                return true;
            }
            else {
                if (orient2D(p1, p2, r1) >= 0) {
                    if (orient2D(q1, r1, p2) >= 0) {
                        return true;
                    }
                }
            }
        }
    }
    else {
        if (orient2D(r2, p2, r1) >= 0) {
            if (orient2D(q1, r1, r2) >= 0) {
                if (orient2D(p1, p2, r1) <= 0) {
                    return true;
                }
            }
        }
    }
    return false;
}
function intersectionTypeR2(t1, t2) {
    const p1 = t1.a;
    const q1 = t1.b;
    const r1 = t1.c;
    const p2 = t2.a;
    const q2 = t2.b;
    const r2 = t2.c;
    if (orient2D(r1, p2, q1) >= 0) {
        if (orient2D(q2, r2, q1) >= 0) {
            if (orient2D(p1, p2, q1) >= 0) {
                if (orient2D(p1, q2, q1) <= 0) {
                    return true;
                }
            }
            else {
                if (orient2D(p1, p2, r1) >= 0) {
                    if (orient2D(r2, p2, r1) >= 0) {
                        return true;
                    }
                }
            }
        }
        else {
            if (orient2D(p1, q2, q1) <= 0) {
                if (orient2D(q2, r2, r1) >= 0) {
                    if (orient2D(q1, r1, q2) >= 0) {
                        return true;
                    }
                }
            }
        }
    }
    else {
        if (orient2D(r2, p2, r1) >= 0) {
            if (orient2D(q1, r1, r2) >= 0) {
                if (orient2D(r1, p1, p2) >= 0) {
                    return true;
                }
            }
            else {
                if (orient2D(q1, r1, q2) >= 0) {
                    if (orient2D(q2, r2, r1) >= 0) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
const _tmp = new Vector3();
const _clip = new Array(3).fill(_tmp);
const _output = new Array();
const _inter = new Vector3();
const _orients = new Array(9).fill(0);
function clipTriangle(t1, t2, target) {
    _clip[0] = t1.a;
    _clip[1] = t1.b;
    _clip[2] = t1.c;
    _output.splice(0, _output.length);
    _output.push(t2.a);
    _output.push(t2.b);
    _output.push(t2.c);
    for (let i = 0; i < 3; i++) {
        const input = [..._output];
        _output.splice(0, _output.length);
        const i_prev = (i + 2) % 3;
        for (let j = 0; j < input.length; j++) {
            _orients[j] = orient2D(_clip[i_prev], _clip[i], input[j]);
        }
        for (let j = 0; j < input.length; j++) {
            const j_prev = (j - 1 + input.length) % input.length;
            if (_orients[j] >= 0) {
                if (_orients[j_prev] < 0) {
                    linesIntersect2d(_clip[i_prev], _clip[i], input[j_prev], input[j], _inter);
                    _output.push(_inter.clone());
                }
                _output.push(input[j].clone());
            }
            else if (_orients[j_prev] >= 0) {
                linesIntersect2d(_clip[i_prev], _clip[i], input[j_prev], input[j], _inter);
                _output.push(_inter.clone());
            }
        }
    }
    for (const point of _output) {
        let j = 0;
        let sameFound = false;
        while (!sameFound && j < target.length) {
            sameFound = point.distanceTo(target[j]) <= 1e-10;
            j++;
        }
        if (!sameFound) {
            target.push(point);
        }
    }
}

const _t1 = new Triangle();
const _t2 = new Triangle();
var Intersection;
(function (Intersection) {
    Intersection["Cross"] = "Cross";
    Intersection["Coplanar"] = "Coplanar";
})(Intersection || (Intersection = {}));
function trianglesIntersect(t1, t2, target) {
    if (target) {
        target.splice(0, target.length);
    }
    if (isTriDegenerated(t1) || isTriDegenerated(t2)) {
        console.warn("Degenerated triangles provided, skipping.");
        return null;
    }
    _t1.copy(t1);
    _t2.copy(t2);
    t1 = _t1;
    t2 = _t2;
    const o1a = orient3D(t2.a, t2.b, t2.c, t1.a);
    const o1b = orient3D(t2.a, t2.b, t2.c, t1.b);
    const o1c = orient3D(t2.a, t2.b, t2.c, t1.c);
    if (o1a === o1b && o1a === o1c) {
        if (o1a === 0 && coplanarIntersect(t1, t2, target)) {
            return Intersection.Coplanar;
        }
        return null;
    }
    if (crossIntersect(t1, t2, o1a, o1b, o1c, target)) {
        return Intersection.Cross;
    }
    return null;
}

// Author: Axel Antoine
class ViewmapBuildInfo {
    totalTime = Infinity;
    times = {
        updateMeshes: Infinity,
        createFaceEdges: Infinity,
        filterEdges: Infinity,
        singularities3D: Infinity,
        singularities2D: Infinity,
        chaining: Infinity,
        visibility: Infinity,
        polygonsRetrieval: Infinity,
        NDCConversion: Infinity,
        assignPolygons: Infinity,
        RENAME_ME: Infinity
    };
    extra = {
        intersections: new Array(),
        visibility: {
            numberOfRaycast: Infinity,
        },
        polygons: {
            numberOfIgnoredPolygons: Infinity,
            numberOfErrorPolygons: Infinity,
            numberOfAssignedPolygons: Infinity,
            numberOfNonAssignedPolygons: Infinity,
        }
    };
}
const _raycaster = new Raycaster();
const _proj = new Vector3();
class Viewmap {
    meshes = new Set();
    edges = new Set();
    points = new Set();
    singularityPoints = new Array();
    contours = new Array();
    polygonsRaycastPoints = new Array();
    polygons = new Array();
    clear() {
        this.edges = new Set();
        this.points = new Set();
        this.singularityPoints = new Array();
        this.contours = new Array();
        this.polygonsRaycastPoints = new Array();
        this.polygons = new Array();
    }
    async build(meshes, camera, renderSize, buildOptions = {}, info = new ViewmapBuildInfo()) {
        this.clear();
        const buildStartTime = Date.now();
        let stepStartTime;
        const options = {
            meshesNeedUpdate: true,
            ignoreContoursVisibility: false,
            ...buildOptions
        };
        this.meshes = new Set(meshes);
        // Step:
        // Prepare camera
        camera = camera.clone();
        camera.getWorldPosition(camera.position);
        // Step:
        // Update render meshes
        if (options.meshesNeedUpdate) {
            stepStartTime = Date.now();
            for (const mesh of this.meshes) {
                mesh.updateMorphGeometry();
                mesh.updateBVH(false);
                mesh.updateHES(false);
            }
            info.times.updateMeshes = Date.now() - stepStartTime;
        }
        // Step:
        // Update world position
        stepStartTime = Date.now();
        const normalMatrix = new Matrix3();
        for (const mesh of this.meshes) {
            normalMatrix.getNormalMatrix(mesh.matrixWorld);
            if (mesh.hes) {
                // Update vertices
                for (const vertex of mesh.hes.vertices) {
                    vertex.position.applyMatrix4(mesh.matrixWorld);
                    vertex.normal.applyMatrix3(normalMatrix).normalize();
                }
                // Update Faces
                for (const face of mesh.hes.faces) {
                    face.midpoint.applyMatrix4(mesh.matrixWorld);
                    face.normal.applyMatrix3(normalMatrix).normalize();
                }
            }
        }
        info.times.RENAME_ME = Date.now() - stepStartTime;
        const bvhRaycastUseMap = new Map();
        for (const mesh of meshes) {
            bvhRaycastUseMap.set(mesh, mesh.isUsingBVHForRaycasting);
            mesh.useBVHRaycast(true);
        }
        // Step:
        // Create view edges
        stepStartTime = Date.now();
        for (const mesh of this.meshes) {
            createFaceEdges(mesh, camera);
        }
        info.times.createFaceEdges = Date.now() - stepStartTime;
        // Step:
        // compute meshes surface intersections
        stepStartTime = Date.now();
        for (let i = 0; i < meshes.length; i++) {
            for (let j = i + 1; j < meshes.length; j++) {
                const interInfo = computeSurfaceIntersections(meshes[i], meshes[j]);
                info.extra.intersections.push(interInfo);
            }
        }
        info.times.RENAME_ME = Date.now() - stepStartTime;
        // Step:
        // Extract the unique set of edges
        stepStartTime = Date.now();
        this.edges = gatherEdges(meshes);
        info.times.RENAME_ME = Date.now() - stepStartTime;
        // Step:
        // Setup points for each vertex
        stepStartTime = Date.now();
        this.points = initPoints(this.edges, camera);
        info.times.RENAME_ME = Date.now() - stepStartTime;
        // Step:
        // Find singularity points in the 3D space (curtain folds, mesh intersections
        // or bifurcations)
        stepStartTime = Date.now();
        this.singularityPoints = findSingularityPointsIn3D(this.points, camera);
        info.times.singularities3D = Date.now() - stepStartTime;
        // Step:
        // Find singularity points in the 3D space (image place intersections)
        // This step creates new points and segments on-the-fly
        stepStartTime = Date.now();
        const interPoints = computeImageIntersections(this.edges);
        this.singularityPoints.push(...interPoints);
        interPoints.forEach(p => this.points.add(p));
        // this.points.push(...interPoints);
        info.times.singularities2D = Date.now() - stepStartTime;
        // Step:
        // Compute contours from the set of segments: link segments depending
        // of their connexity and nature
        stepStartTime = Date.now();
        this.contours = createChainedContours(this.edges);
        info.times.chaining = Date.now() - stepStartTime;
        // Step:
        // Compute contours visibility using geometry's topology or
        // raycasting if needed
        // If ignore visibility is set, set all contours to be visible
        if (!options.ignoreContoursVisibility) {
            stepStartTime = Date.now();
            const visInfo = computeContoursVisibility(this.contours, camera, meshes);
            info.extra.visibility.numberOfRaycast = visInfo.numberOfRaycasts;
            info.times.visibility = Date.now() - stepStartTime;
        }
        else {
            this.contours.map(contour => contour.visibility = ContourVisibility.Visible);
        }
        // Step:
        // Compute the polygons formed by the visible subset of contours
        stepStartTime = Date.now();
        const visibleContours = this.contours.filter(contour => contour.visibility === ContourVisibility.Visible);
        const polygonsInfo = await computePolygons(visibleContours);
        this.polygons = polygonsInfo.polygons;
        info.extra.polygons.numberOfErrorPolygons = polygonsInfo.nbErrors;
        info.extra.polygons.numberOfIgnoredPolygons = polygonsInfo.nbIgnored;
        info.times.polygonsRetrieval = Date.now() - stepStartTime;
        // Step:
        //
        stepStartTime = Date.now();
        const assignInfo = assignPolygons(this.polygons, camera, meshes, options.defaultMeshColor);
        info.extra.polygons.numberOfAssignedPolygons = assignInfo.assigned;
        info.extra.polygons.numberOfNonAssignedPolygons = assignInfo.nonAssigned;
        info.times.assignPolygons = Date.now() - stepStartTime;
        // Step:
        // Convert Vector2 in the image space (NDC coordinates) to pixels coordinates
        // using the render resolution
        stepStartTime = Date.now();
        for (const point of this.points) {
            NDCPointToImage(point.position, renderSize);
        }
        // Arr2D polygons have their own points
        for (const polygon of this.polygons) {
            for (const p of polygon.contour) {
                NDCPointToImage(p, renderSize);
            }
            for (const hole of polygon.holes) {
                for (const p of hole) {
                    NDCPointToImage(p, renderSize);
                }
            }
            NDCPointToImage(polygon.insidePoint, renderSize);
        }
        // Contour raycast points
        for (const contour of this.contours) {
            NDCPointToImage(contour.raycastPoint, renderSize);
        }
        info.times.NDCConversion = Date.now() - stepStartTime;
        // Put back the bvh raycast acceleration status
        for (const mesh of meshes) {
            const oldValue = bvhRaycastUseMap.get(mesh);
            if (oldValue !== undefined) {
                mesh.useBVHRaycast(oldValue);
            }
        }
        info.totalTime = Date.now() - buildStartTime;
        return info;
    }
}
function createFaceEdges(mesh, camera) {
    const processedHalfEdges = new Map();
    const processedVertices = new Set();
    for (const face of mesh.hes.faces) {
        face.edges = new Set();
        const startHalfEdge = face.halfEdge;
        let halfEdge = startHalfEdge;
        do {
            const twin = halfEdge.twin;
            let edge = twin && processedHalfEdges.get(twin);
            if (edge) {
                edge.faces.push(face);
            }
            else {
                edge = new Edge([mesh], [face], halfEdge.vertex, halfEdge.next.vertex);
                edge.updateNatureFromHalfEdge(halfEdge, camera);
                // Init edge vertices
                for (const vertex of edge.vertices) {
                    if (!processedVertices.has(vertex)) {
                        vertex.edges = new Set();
                        processedVertices.add(vertex);
                    }
                    vertex.edges.add(edge);
                }
                processedHalfEdges.set(halfEdge, edge);
            }
            face.edges.add(edge);
            halfEdge = halfEdge.next;
        } while (halfEdge != startHalfEdge);
    }
}
class SurfaceIntersectionInfo {
    meshA;
    meshB;
    nbTests = Infinity;
    nbIntersections = Infinity;
    time = Infinity;
    intersectionEdges = new Array();
    constructor(meshA, meshB) {
        this.meshA = meshA.name;
        this.meshB = meshB.name;
    }
}
function computeSurfaceIntersections(meshA, meshB) {
    const startTime = Date.now();
    const info = new SurfaceIntersectionInfo(meshA, meshB);
    info.nbTests = 0;
    info.nbIntersections = 0;
    const matrixBtoA = new Matrix4()
        .copy(meshA.matrixWorld).invert().multiply(meshB.matrixWorld);
    const interPoints = new Array();
    const interLine = new Line3();
    meshA.bvh.bvhcast(meshB.bvh, matrixBtoA, {
        intersectsTriangles: function (triangleA, triangleB, indexA, indexB) {
            info.nbTests += 1;
            // if (triangleA.intersectsTriangle(triangleB, line)) {
            if (trianglesIntersect(triangleA, triangleB, interPoints)) {
                // We're ignoring intersection on single points as there is no triangle
                // cuts to perform
                if (interPoints.length > 1) {
                    info.nbIntersections += 1;
                    const faceA = meshA.hes.faces[indexA];
                    const faceB = meshB.hes.faces[indexB];
                    const size = interPoints.length === 2 ? 1 : interPoints.length;
                    // We cut triangle for each line of the intersection
                    for (let i = 0; i < size; i++) {
                        interLine.start.copy(interPoints[i]);
                        interLine.end.copy(interPoints[(i + 1) % interPoints.length]);
                        interLine.applyMatrix4(meshA.matrixWorld);
                        const edge = cutIntersectingFacesEdgesWithLine(meshA, faceA, meshB, faceB, interLine);
                        if (edge) {
                            info.intersectionEdges.push(edge);
                        }
                    }
                }
            }
            return false;
        }
    });
    info.time = Date.now() - startTime;
    return info;
}
function gatherEdges(objects) {
    const edges = new Set();
    for (const obj of objects) {
        for (const face of obj.hes.faces) {
            for (const edge of face.edges) {
                if (edge.nature !== EdgeNature.None) {
                    edges.add(edge);
                }
            }
        }
    }
    return edges;
}
function initPoints(edges, camera) {
    const points = new Set();
    const processedVertices = new Set();
    for (const e of edges) {
        for (const v of e.vertices) {
            if (!processedVertices.has(v)) {
                _proj.copy(v.position).project(camera);
                const point = new Point$1(new Vector2(_proj.x, _proj.y), [v]);
                v.point = point;
                points.add(point);
                processedVertices.add(v);
            }
        }
    }
    return points;
}
function cutIntersectingFacesEdgesWithLine(meshA, faceA, meshB, faceB, line) {
    const points = [line.start, line.end];
    const faces = [faceA, faceB];
    const interVertices = new Array();
    for (const linePoint of points) {
        const meshVertices = new Array();
        for (const face of faces) {
            const split = cutFaceEdgesAtPosition(face, linePoint);
            if (split) {
                meshVertices.push(split.vertex);
            }
        }
        if (meshVertices.length === 0) {
            console.error("At least one face should be cut");
        }
        else {
            let vertex = meshVertices[0];
            if (meshVertices.length === 2) {
                vertex = mergeVertices(meshVertices[0], meshVertices[1]);
            }
            interVertices.push(vertex);
        }
    }
    if (interVertices.length !== 2) {
        return null;
    }
    // For each point of the intersection line we found the vertices for each mesh
    // and merge them into one
    // In case face triangles both intersect on their side, there is a possibility
    // that edges already exist between the intersection merged vertices.
    // So we remove them as we create a new one
    removeEdgesBetweenVertices(interVertices[0], interVertices[1]);
    const interEdge = new Edge([meshA, meshB], [faceA, faceB], interVertices[0], interVertices[1]);
    interEdge.nature = EdgeNature.SurfaceIntersection;
    interVertices[0].edges.add(interEdge);
    interVertices[1].edges.add(interEdge);
    faceA.edges.add(interEdge);
    faceB.edges.add(interEdge);
    return interEdge;
}
function removeEdgesBetweenVertices(a, b) {
    const commonEdges = new Array();
    for (const edge of a.edges) {
        if (edge.hasVertex(b)) {
            commonEdges.push(edge);
        }
    }
    for (const edge of commonEdges) {
        a.edges.delete(edge);
        b.edges.delete(edge);
        for (const face of edge.faces) {
            face.edges.delete(edge);
        }
    }
}
function mergeVertices(a, b) {
    // Add the edges of b to a
    for (const edge of b.edges) {
        a.edges.add(edge);
        edge.replaceVertex(b, a);
    }
    return a;
}
function cutFaceEdgesAtPosition(face, point) {
    for (const edge of face.edges) {
        const vertex = splitEdge(edge, point);
        if (vertex) {
            return vertex;
        }
    }
    return null;
}
function splitEdge(edge, position, tolerance = 1e-10) {
    // Check first if position matches one edge vertex to avoid unnecessary split
    for (const vertex of edge.vertices) {
        if (vertex.matchesPosition(position, tolerance)) {
            return {
                vertex: vertex,
                cut: false
            };
        }
    }
    // Check if the position cuts the edge in 2
    if (edge.contains3dPosition(position, tolerance)) {
        const lerpNormal = new Vector3();
        edge.normalAtPosition(position, lerpNormal);
        const vertex = new Vertex(-1, position.clone(), lerpNormal);
        for (const v of edge.vertices) {
            v.edges.delete(edge);
        }
        const e1 = edge.clone();
        e1.replaceVertex(edge.vertices[0], vertex);
        edge.vertices[1].edges.add(e1);
        const e2 = edge.clone();
        e2.replaceVertex(edge.vertices[1], vertex);
        edge.vertices[0].edges.add(e2);
        vertex.edges = new Set();
        vertex.edges.add(e1);
        vertex.edges.add(e2);
        for (const face of edge.faces) {
            face.edges.delete(edge);
            face.edges.add(e1);
            face.edges.add(e2);
        }
        return {
            vertex: vertex,
            cut: true
        };
    }
    return null;
}
function splitEdge2d(edge, position, tolerance = 1e-10) {
    const vertexPos = edge.position3dFromPosition2d(position, new Vector3());
    return splitEdge(edge, vertexPos, tolerance);
}
function singularityForPoint(point, camera) {
    const naturesFound = new Set();
    let concaveSilhouetteFound = false;
    let convexSilhouetteFound = false;
    const edges = point.edges.filter(e => e.nature !== EdgeNature.None);
    // Count the number of different natures connected to the vertex
    for (const edge of edges) {
        naturesFound.add(edge.nature);
        concaveSilhouetteFound ||= ((edge.nature === EdgeNature.Silhouette) && (edge.isConcave));
        convexSilhouetteFound ||= ((edge.nature === EdgeNature.Silhouette) && (!edge.isConcave));
    }
    if (naturesFound.size === 0) {
        console.error("No natures found around point", point);
    }
    else if (naturesFound.size === 1) {
        const [nature] = naturesFound;
        // Curtain fold singularities can occur on a Silhouette segment where
        // there are at least one concave and one convex edges connected
        if (nature === EdgeNature.Silhouette &&
            concaveSilhouetteFound && convexSilhouetteFound) {
            return PointSingularity.CurtainFold;
        }
        // Curtain fold singularties can also occur on a Boundary edge where
        // one of the connected face overlaps the boundary edge
        else if (nature === EdgeNature.Boundary &&
            isBoundaryCurtainFoldVertex(point.vertices[0], camera)) {
            return PointSingularity.CurtainFold;
        }
        // If the number of segment natures is 1 and there is more than 2 segments
        // connected to the point, then there is a bifurcation singularity
        else if (edges.length > 2) {
            return PointSingularity.Bifurcation;
        }
    }
    // There are at least 2 edges of different natures connected to the vertex,
    // then there is a mesh intersection singularity
    else {
        return PointSingularity.MeshIntersection;
    }
    return PointSingularity.None;
}
function findSingularityPointsIn3D(points, camera) {
    const array = new Array();
    for (const point of points) {
        point.singularity = singularityForPoint(point, camera);
        if (point.singularity !== PointSingularity.None) {
            array.push(point);
        }
    }
    return array;
}
function isBoundaryCurtainFoldVertex(vertex, camera) {
    const boundaryHalfEdges = vertex.connectedBoundaryHalfEdges();
    if (boundaryHalfEdges.length > 0) {
        // Get the farthest boundary edge
        let farthestBoundaryHalfEdge = boundaryHalfEdges[0];
        let otherVertex = boundaryHalfEdges[0].vertex;
        let distance = -Infinity;
        for (let i = 0; i < boundaryHalfEdges.length; i++) {
            const halfEdge = boundaryHalfEdges[i];
            // Check whether halfEdge is starting from or arriving to sourceVertex
            let tmpVertex;
            if (halfEdge.vertex === vertex) {
                tmpVertex = halfEdge.next.vertex;
            }
            else {
                tmpVertex = halfEdge.vertex;
            }
            const d = tmpVertex.position.distanceTo(camera.position);
            if (d > distance) {
                distance = d;
                farthestBoundaryHalfEdge = halfEdge;
                otherVertex = tmpVertex;
            }
        }
        // Iterate on each connected faces using halfedges starting from the
        // source vertex of point
        const c = camera.position;
        const p = vertex.position;
        const e = otherVertex.position;
        for (const halfEdge of vertex.halfEdges) {
            if (halfEdge.face !== farthestBoundaryHalfEdge.face) {
                const q = halfEdge.next.vertex.position;
                const r = halfEdge.next.vertex.position;
                if (!sameSide(p, q, r, c, e) && sameSide(c, p, q, e, r) && sameSide(c, p, r, e, q)) {
                    return true;
                }
            }
        }
    }
    return false;
}
function getIntersectingsEdges(edges) {
    const array = [];
    const intersectionAlgorithm = bush([...edges], {});
    const intersections = intersectionAlgorithm.run();
    for (const intersection of intersections) {
        const interEdges = intersection.segments;
        const pos = new Vector2(intersection.point.x, intersection.point.y);
        if (!interEdges[0].isConnectedToEdge(interEdges[1])) {
            array.push({
                edges: interEdges,
                pos: pos
            });
        }
    }
    return array;
}
function computeImageIntersections(edges) {
    const newPoints = new Array();
    const splitMap = new Map();
    const intersections = getIntersectingsEdges(edges);
    for (const intersection of intersections) {
        const interPos = intersection.pos;
        const splitVertices = new Array();
        for (const edge of intersection.edges) {
            let subEdges = splitMap.get(edge);
            if (!subEdges) {
                subEdges = [edge];
                splitMap.set(edge, subEdges);
            }
            let i = 0;
            let subEdge;
            let split;
            do {
                subEdge = subEdges[i];
                split = splitEdge2d(subEdge, interPos);
                i += 1;
            } while (!split && i < subEdges.length);
            if (!split) {
                console.error("Could not find a split vertex", subEdges, interPos);
            }
            else {
                const { vertex, cut } = split;
                // if cut is true, then the edge has been splited in 2
                if (cut) {
                    splitVertices.push(vertex);
                    subEdges.remove(subEdge);
                    subEdges.push(...vertex.edges);
                    edges.delete(subEdge);
                    vertex.edges.forEach(e => edges.add(e));
                }
            }
        }
        const newPoint = new Point$1(interPos.clone(), []);
        newPoint.singularity = PointSingularity.ImageIntersection;
        newPoints.push(newPoint);
        for (const splitVertex of splitVertices) {
            if (splitVertex.point) {
                for (const v of splitVertex.point.vertices) {
                    if (!newPoint.vertices.includes(v)) {
                        newPoint.vertices.push(v);
                        v.point = newPoint;
                    }
                }
            }
            else {
                newPoint.vertices.push(splitVertex);
                splitVertex.point = newPoint;
            }
        }
    }
    return newPoints;
}
function nextEdgeFromPoint(currentEdge, point, availableEdges, obj) {
    // if point is a singularity, stop propagation
    if (point.singularity !== PointSingularity.None) {
        return null;
    }
    // TODO: Taking into account the nature of the current segment and geometric
    // properties to build longer chains
    for (const edge of point.edges) {
        // Check segment has not already been assigned
        if (availableEdges.has(edge) && edge.nature === currentEdge.nature &&
            edge.meshes.includes(obj)) {
            return edge;
        }
    }
    return null;
}
function createChainedContours(edges) {
    const contours = new Array();
    // Transform the array of segments into a set so we can remove processed
    // segments while iterating on the set to create chains
    // See chaining section of https://hal.inria.fr/hal-02189483
    const remainingEdges = new Set(edges);
    let contourId = 0;
    while (remainingEdges.size > 0) {
        const [startEdge] = remainingEdges;
        const currentObject = startEdge.meshes[0];
        const contour = new Contour(contourId, currentObject);
        remainingEdges.delete(startEdge);
        contour.addEdge(startEdge);
        // Search for connected segments from one direction
        for (const startPoint of startEdge.points) {
            let point = startPoint;
            let segment = nextEdgeFromPoint(startEdge, point, remainingEdges, currentObject);
            while (segment) {
                remainingEdges.delete(segment);
                contour.addEdge(segment);
                point = segment.otherPoint(point);
                segment = nextEdgeFromPoint(segment, point, remainingEdges, currentObject);
            }
        }
        contours.push(contour);
        contourId += 1;
    }
    return contours;
}
function computeContoursVisibility(contours, camera, meshes) {
    const info = {
        numberOfRaycasts: 0,
        rayOrigins: new Array(),
    };
    const threeObjects = meshes.map(obj => obj.threeMesh);
    // As we cast rays from object to the camera, we want rays to intersect only
    // on the backside face. So we need to change material sideness
    const materialSidenessMap = new Map();
    for (const mesh of meshes) {
        if (Array.isArray(mesh.material)) {
            for (const material of mesh.material) {
                materialSidenessMap.set(material, material.side);
                material.side = DoubleSide;
            }
        }
        else {
            materialSidenessMap.set(mesh.material, mesh.material.side);
            mesh.material.side = DoubleSide;
        }
    }
    for (const contour of contours) {
        // Search for an edge that is not obvisouly hidden by geometry
        // (i.e. not back and not concave, see paper https://hal.inria.fr/hal-02189483)
        // let i = 0;
        // let hiddenByGeometry = false;
        // do {
        //   hiddenByGeometry = contour.edges[i].isConcave || contour.edges[i].isBack;
        //   i += 1;
        // } while(!hiddenByGeometry && i < contour.edges.length);
        // if (hiddenByGeometry) {
        //   contour.visibility = ContourVisibility.Hidden;
        // } else {
        contourVisibilityWithRaycasting(contour, camera, threeObjects);
        info.numberOfRaycasts += 1;
        // }
    }
    // Restaure the sideness of material
    for (const mesh of meshes) {
        if (Array.isArray(mesh.material)) {
            for (const material of mesh.material) {
                material.side = materialSidenessMap.get(material);
            }
        }
        else {
            mesh.material.side = materialSidenessMap.get(mesh.material);
        }
    }
    return info;
}
const _rayDirection = new Vector3();
const _rayOrigin = new Vector3();
const _rayOriginProj = new Vector3();
/**
 * Return contour visibility via raycasting. If contour is empty, returns hidden
 * @param contour
 * @param camera
 * @param objects
 * @param tolerance
 * @returns
 */
function contourVisibilityWithRaycasting(contour, camera, objects, tolerance = 1e-10) {
    // Get the middle segment from the contour
    const edge = contour.middleEdge();
    if (!edge) {
        console.error("Contour has no edges");
        contour.visibility = ContourVisibility.Hidden;
        return;
    }
    // Cast a ray from the middle of the segment to the camera
    _rayOrigin.addVectors(edge.vertices[0].position, edge.vertices[1].position).divideScalar(2);
    _rayDirection.subVectors(camera.position, _rayOrigin).normalize();
    _raycaster.firstHitOnly = false;
    _raycaster.set(_rayOrigin, _rayDirection);
    // Get the projection of the origin of the ray cast
    _rayOriginProj.copy(_rayOrigin).project(camera);
    contour.raycastPoint.set(_rayOriginProj.x, _rayOriginProj.y);
    // Compute total distance in case of mathematical imprecision
    const intersections = _raycaster.intersectObjects(objects, false);
    let totalDistance = 0;
    for (const intersection of intersections) {
        totalDistance += intersection.distance;
    }
    if (totalDistance < tolerance) {
        contour.visibility = ContourVisibility.Visible;
    }
    else {
        contour.visibility = ContourVisibility.Hidden;
    }
}
function assignPolygons(polygons, camera, objects, defaultColor = 0x333333) {
    let assigned = 0;
    const color = new Color$1(defaultColor);
    const svgMeshesMap = new Map();
    const threeMeshes = new Array();
    for (const object of objects) {
        svgMeshesMap.set(object.threeMesh, object);
        threeMeshes.push(object.threeMesh);
    }
    for (const polygon of polygons) {
        _raycaster.setFromCamera(polygon.insidePoint, camera);
        _raycaster.firstHitOnly = true;
        const intersections = _raycaster.intersectObjects(threeMeshes, false);
        if (intersections.length > 0) {
            const intersection = intersections[0];
            const faceIndex = intersection.faceIndex;
            if (faceIndex !== undefined) {
                const intersectionMesh = intersection.object;
                polygon.mesh = svgMeshesMap.get(intersectionMesh);
                if (polygon.mesh) {
                    polygon.color.copy(polygon.mesh.colorForFaceIndex(faceIndex) || color);
                    assigned += 1;
                }
                else {
                    console.error(`Could not associate SVG mesh to polygon ${polygon.id}`);
                }
            }
            else {
                console.error(`Polygon ${polygon.id} intersection has no face index`, intersection);
            }
        }
    }
    return {
        assigned: assigned,
        nonAssigned: polygons.length - assigned
    };
}

const methods$1 = {};
const names = [];

function registerMethods (name, m) {
  if (Array.isArray(name)) {
    for (const _name of name) {
      registerMethods(_name, m);
    }
    return
  }

  if (typeof name === 'object') {
    for (const _name in name) {
      registerMethods(_name, name[_name]);
    }
    return
  }

  addMethodNames(Object.getOwnPropertyNames(m));
  methods$1[name] = Object.assign(methods$1[name] || {}, m);
}

function getMethodsFor (name) {
  return methods$1[name] || {}
}

function getMethodNames () {
  return [ ...new Set(names) ]
}

function addMethodNames (_names) {
  names.push(..._names);
}

// Map function
function map (array, block) {
  let i;
  const il = array.length;
  const result = [];

  for (i = 0; i < il; i++) {
    result.push(block(array[i]));
  }

  return result
}

// Filter function
function filter (array, block) {
  let i;
  const il = array.length;
  const result = [];

  for (i = 0; i < il; i++) {
    if (block(array[i])) {
      result.push(array[i]);
    }
  }

  return result
}

// Degrees to radians
function radians (d) {
  return d % 360 * Math.PI / 180
}

// Convert dash-separated-string to camelCase
function camelCase (s) {
  return s.toLowerCase().replace(/-(.)/g, function (m, g) {
    return g.toUpperCase()
  })
}

// Convert camel cased string to dash separated
function unCamelCase (s) {
  return s.replace(/([A-Z])/g, function (m, g) {
    return '-' + g.toLowerCase()
  })
}

// Capitalize first letter of a string
function capitalize (s) {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

// Calculate proportional width and height values when necessary
function proportionalSize (element, width, height, box) {
  if (width == null || height == null) {
    box = box || element.bbox();

    if (width == null) {
      width = box.width / box.height * height;
    } else if (height == null) {
      height = box.height / box.width * width;
    }
  }

  return {
    width: width,
    height: height
  }
}

/**
 * This function adds support for string origins.
 * It searches for an origin in o.origin o.ox and o.originX.
 * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50
**/
function getOrigin (o, element) {
  const origin = o.origin;
  // First check if origin is in ox or originX
  let ox = o.ox != null
    ? o.ox
    : o.originX != null
      ? o.originX
      : 'center';
  let oy = o.oy != null
    ? o.oy
    : o.originY != null
      ? o.originY
      : 'center';

  // Then check if origin was used and overwrite in that case
  if (origin != null) {
    [ ox, oy ] = Array.isArray(origin)
      ? origin
      : typeof origin === 'object'
        ? [ origin.x, origin.y ]
        : [ origin, origin ];
  }

  // Make sure to only call bbox when actually needed
  const condX = typeof ox === 'string';
  const condY = typeof oy === 'string';
  if (condX || condY) {
    const { height, width, x, y } = element.bbox();

    // And only overwrite if string was passed for this specific axis
    if (condX) {
      ox = ox.includes('left')
        ? x
        : ox.includes('right')
          ? x + width
          : x + width / 2;
    }

    if (condY) {
      oy = oy.includes('top')
        ? y
        : oy.includes('bottom')
          ? y + height
          : y + height / 2;
    }
  }

  // Return the origin as it is if it wasn't a string
  return [ ox, oy ]
}

// Default namespaces
const svg = 'http://www.w3.org/2000/svg';
const html = 'http://www.w3.org/1999/xhtml';
const xmlns = 'http://www.w3.org/2000/xmlns/';
const xlink = 'http://www.w3.org/1999/xlink';
const svgjs = 'http://svgjs.dev/svgjs';

const globals = {
  window: typeof window === 'undefined' ? null : window,
  document: typeof document === 'undefined' ? null : document
};

class Base {
  // constructor (node/*, {extensions = []} */) {
  //   // this.tags = []
  //   //
  //   // for (let extension of extensions) {
  //   //   extension.setup.call(this, node)
  //   //   this.tags.push(extension.name)
  //   // }
  // }
}

const elements = {};
const root = '___SYMBOL___ROOT___';

// Method for element creation
function create (name, ns = svg) {
  // create element
  return globals.document.createElementNS(ns, name)
}

function makeInstance (element, isHTML = false) {
  if (element instanceof Base) return element

  if (typeof element === 'object') {
    return adopter(element)
  }

  if (element == null) {
    return new elements[root]()
  }

  if (typeof element === 'string' && element.charAt(0) !== '<') {
    return adopter(globals.document.querySelector(element))
  }

  // Make sure, that HTML elements are created with the correct namespace
  const wrapper = isHTML ? globals.document.createElement('div') : create('svg');
  wrapper.innerHTML = element;

  // We can use firstChild here because we know,
  // that the first char is < and thus an element
  element = adopter(wrapper.firstChild);

  // make sure, that element doesnt have its wrapper attached
  wrapper.removeChild(wrapper.firstChild);
  return element
}

function nodeOrNew (name, node) {
  return (node && node.ownerDocument && node instanceof node.ownerDocument.defaultView.Node) ? node : create(name)
}

// Adopt existing svg elements
function adopt (node) {
  // check for presence of node
  if (!node) return null

  // make sure a node isn't already adopted
  if (node.instance instanceof Base) return node.instance

  if (node.nodeName === '#document-fragment') {
    return new elements.Fragment(node)
  }

  // initialize variables
  let className = capitalize(node.nodeName || 'Dom');

  // Make sure that gradients are adopted correctly
  if (className === 'LinearGradient' || className === 'RadialGradient') {
    className = 'Gradient';

  // Fallback to Dom if element is not known
  } else if (!elements[className]) {
    className = 'Dom';
  }

  return new elements[className](node)
}

let adopter = adopt;

function register (element, name = element.name, asRoot = false) {
  elements[name] = element;
  if (asRoot) elements[root] = element;

  addMethodNames(Object.getOwnPropertyNames(element.prototype));

  return element
}

function getClass (name) {
  return elements[name]
}

// Element id sequence
let did = 1000;

// Get next named element id
function eid (name) {
  return 'Svgjs' + capitalize(name) + (did++)
}

// Deep new id assignment
function assignNewId (node) {
  // do the same for SVG child nodes as well
  for (let i = node.children.length - 1; i >= 0; i--) {
    assignNewId(node.children[i]);
  }

  if (node.id) {
    node.id = eid(node.nodeName);
    return node
  }

  return node
}

// Method for extending objects
function extend (modules, methods) {
  let key, i;

  modules = Array.isArray(modules) ? modules : [ modules ];

  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods) {
      modules[i].prototype[key] = methods[key];
    }
  }
}

function wrapWithAttrCheck (fn) {
  return function (...args) {
    const o = args[args.length - 1];

    if (o && o.constructor === Object && !(o instanceof Array)) {
      return fn.apply(this, args.slice(0, -1)).attr(o)
    } else {
      return fn.apply(this, args)
    }
  }
}

// Get all siblings, including myself
function siblings () {
  return this.parent().children()
}

// Get the current position siblings
function position () {
  return this.parent().index(this)
}

// Get the next element (will return null if there is none)
function next () {
  return this.siblings()[this.position() + 1]
}

// Get the next element (will return null if there is none)
function prev () {
  return this.siblings()[this.position() - 1]
}

// Send given element one step forward
function forward () {
  const i = this.position();
  const p = this.parent();

  // move node one step forward
  p.add(this.remove(), i + 1);

  return this
}

// Send given element one step backward
function backward () {
  const i = this.position();
  const p = this.parent();

  p.add(this.remove(), i ? i - 1 : 0);

  return this
}

// Send given element all the way to the front
function front () {
  const p = this.parent();

  // Move node forward
  p.add(this.remove());

  return this
}

// Send given element all the way to the back
function back () {
  const p = this.parent();

  // Move node back
  p.add(this.remove(), 0);

  return this
}

// Inserts a given element before the targeted element
function before (element) {
  element = makeInstance(element);
  element.remove();

  const i = this.position();

  this.parent().add(element, i);

  return this
}

// Inserts a given element after the targeted element
function after (element) {
  element = makeInstance(element);
  element.remove();

  const i = this.position();

  this.parent().add(element, i + 1);

  return this
}

function insertBefore (element) {
  element = makeInstance(element);
  element.before(this);
  return this
}

function insertAfter (element) {
  element = makeInstance(element);
  element.after(this);
  return this
}

registerMethods('Dom', {
  siblings,
  position,
  next,
  prev,
  forward,
  backward,
  front,
  back,
  before,
  after,
  insertBefore,
  insertAfter
});

// Parse unit value
const numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;

// Parse hex value
const hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

// Parse rgb value
const rgb = /rgb\((\d+),(\d+),(\d+)\)/;

// Parse reference id
const reference = /(#[a-z_][a-z0-9\-_]*)/i;

// splits a transformation chain
const transforms = /\)\s*,?\s*/;

// Whitespace
const whitespace = /\s/g;

// Test hex value
const isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;

// Test rgb value
const isRgb = /^rgb\(/;

// Test for blank string
const isBlank = /^(\s+)?$/;

// Test for numeric string
const isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

// Test for image url
const isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;

// split at whitespace and comma
const delimiter = /[\s,]+/;

// Test for path letter
const isPathLetter = /[MLHVCSQTAZ]/i;

// Return array of classes on the node
function classes () {
  const attr = this.attr('class');
  return attr == null ? [] : attr.trim().split(delimiter)
}

// Return true if class exists on the node, false otherwise
function hasClass (name) {
  return this.classes().indexOf(name) !== -1
}

// Add class to the node
function addClass (name) {
  if (!this.hasClass(name)) {
    const array = this.classes();
    array.push(name);
    this.attr('class', array.join(' '));
  }

  return this
}

// Remove class from the node
function removeClass (name) {
  if (this.hasClass(name)) {
    this.attr('class', this.classes().filter(function (c) {
      return c !== name
    }).join(' '));
  }

  return this
}

// Toggle the presence of a class on the node
function toggleClass (name) {
  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)
}

registerMethods('Dom', {
  classes, hasClass, addClass, removeClass, toggleClass
});

// Dynamic style generator
function css (style, val) {
  const ret = {};
  if (arguments.length === 0) {
    // get full style as object
    this.node.style.cssText.split(/\s*;\s*/)
      .filter(function (el) {
        return !!el.length
      })
      .forEach(function (el) {
        const t = el.split(/\s*:\s*/);
        ret[t[0]] = t[1];
      });
    return ret
  }

  if (arguments.length < 2) {
    // get style properties as array
    if (Array.isArray(style)) {
      for (const name of style) {
        const cased = camelCase(name);
        ret[name] = this.node.style[cased];
      }
      return ret
    }

    // get style for property
    if (typeof style === 'string') {
      return this.node.style[camelCase(style)]
    }

    // set styles in object
    if (typeof style === 'object') {
      for (const name in style) {
        // set empty string if null/undefined/'' was given
        this.node.style[camelCase(name)]
          = (style[name] == null || isBlank.test(style[name])) ? '' : style[name];
      }
    }
  }

  // set style for property
  if (arguments.length === 2) {
    this.node.style[camelCase(style)]
      = (val == null || isBlank.test(val)) ? '' : val;
  }

  return this
}

// Show element
function show () {
  return this.css('display', '')
}

// Hide element
function hide () {
  return this.css('display', 'none')
}

// Is element visible?
function visible () {
  return this.css('display') !== 'none'
}

registerMethods('Dom', {
  css, show, hide, visible
});

// Store data values on svg nodes
function data (a, v, r) {
  if (a == null) {
    // get an object of attributes
    return this.data(map(filter(this.node.attributes, (el) => el.nodeName.indexOf('data-') === 0), (el) => el.nodeName.slice(5)))
  } else if (a instanceof Array) {
    const data = {};
    for (const key of a) {
      data[key] = this.data(key);
    }
    return data
  } else if (typeof a === 'object') {
    for (v in a) {
      this.data(v, a[v]);
    }
  } else if (arguments.length < 2) {
    try {
      return JSON.parse(this.attr('data-' + a))
    } catch (e) {
      return this.attr('data-' + a)
    }
  } else {
    this.attr('data-' + a,
      v === null
        ? null
        : r === true || typeof v === 'string' || typeof v === 'number'
          ? v
          : JSON.stringify(v)
    );
  }

  return this
}

registerMethods('Dom', { data });

// Remember arbitrary data
function remember (k, v) {
  // remember every item in an object individually
  if (typeof arguments[0] === 'object') {
    for (const key in k) {
      this.remember(key, k[key]);
    }
  } else if (arguments.length === 1) {
    // retrieve memory
    return this.memory()[k]
  } else {
    // store memory
    this.memory()[k] = v;
  }

  return this
}

// Erase a given memory
function forget () {
  if (arguments.length === 0) {
    this._memory = {};
  } else {
    for (let i = arguments.length - 1; i >= 0; i--) {
      delete this.memory()[arguments[i]];
    }
  }
  return this
}

// This triggers creation of a new hidden class which is not performant
// However, this function is not rarely used so it will not happen frequently
// Return local memory object
function memory () {
  return (this._memory = this._memory || {})
}

registerMethods('Dom', { remember, forget, memory });

function sixDigitHex (hex) {
  return hex.length === 4
    ? [ '#',
      hex.substring(1, 2), hex.substring(1, 2),
      hex.substring(2, 3), hex.substring(2, 3),
      hex.substring(3, 4), hex.substring(3, 4)
    ].join('')
    : hex
}

function componentHex (component) {
  const integer = Math.round(component);
  const bounded = Math.max(0, Math.min(255, integer));
  const hex = bounded.toString(16);
  return hex.length === 1 ? '0' + hex : hex
}

function is (object, space) {
  for (let i = space.length; i--;) {
    if (object[space[i]] == null) {
      return false
    }
  }
  return true
}

function getParameters (a, b) {
  const params = is(a, 'rgb')
    ? { _a: a.r, _b: a.g, _c: a.b, _d: 0, space: 'rgb' }
    : is(a, 'xyz')
      ? { _a: a.x, _b: a.y, _c: a.z, _d: 0, space: 'xyz' }
      : is(a, 'hsl')
        ? { _a: a.h, _b: a.s, _c: a.l, _d: 0, space: 'hsl' }
        : is(a, 'lab')
          ? { _a: a.l, _b: a.a, _c: a.b, _d: 0, space: 'lab' }
          : is(a, 'lch')
            ? { _a: a.l, _b: a.c, _c: a.h, _d: 0, space: 'lch' }
            : is(a, 'cmyk')
              ? { _a: a.c, _b: a.m, _c: a.y, _d: a.k, space: 'cmyk' }
              : { _a: 0, _b: 0, _c: 0, space: 'rgb' };

  params.space = b || params.space;
  return params
}

function cieSpace (space) {
  if (space === 'lab' || space === 'xyz' || space === 'lch') {
    return true
  } else {
    return false
  }
}

function hueToRgb (p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t
  if (t < 1 / 2) return q
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6
  return p
}

class Color {
  constructor (...inputs) {
    this.init(...inputs);
  }

  // Test if given value is a color
  static isColor (color) {
    return color && (
      color instanceof Color
      || this.isRgb(color)
      || this.test(color)
    )
  }

  // Test if given value is an rgb object
  static isRgb (color) {
    return color && typeof color.r === 'number'
      && typeof color.g === 'number'
      && typeof color.b === 'number'
  }

  /*
  Generating random colors
  */
  static random (mode = 'vibrant', t, u) {

    // Get the math modules
    const { random, round, sin, PI: pi } = Math;

    // Run the correct generator
    if (mode === 'vibrant') {

      const l = (81 - 57) * random() + 57;
      const c = (83 - 45) * random() + 45;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color

    } else if (mode === 'sine') {

      t = t == null ? random() : t;
      const r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);
      const g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);
      const b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);
      const color = new Color(r, g, b);
      return color

    } else if (mode === 'pastel') {

      const l = (94 - 86) * random() + 86;
      const c = (26 - 9) * random() + 9;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color

    } else if (mode === 'dark') {

      const l = 10 + 10 * random();
      const c = (125 - 75) * random() + 86;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color

    } else if (mode === 'rgb') {

      const r = 255 * random();
      const g = 255 * random();
      const b = 255 * random();
      const color = new Color(r, g, b);
      return color

    } else if (mode === 'lab') {

      const l = 100 * random();
      const a = 256 * random() - 128;
      const b = 256 * random() - 128;
      const color = new Color(l, a, b, 'lab');
      return color

    } else if (mode === 'grey') {

      const grey = 255 * random();
      const color = new Color(grey, grey, grey);
      return color

    } else {

      throw new Error('Unsupported random color mode')

    }
  }

  // Test if given value is a color string
  static test (color) {
    return (typeof color === 'string')
      && (isHex.test(color) || isRgb.test(color))
  }

  cmyk () {

    // Get the rgb values for the current color
    const { _a, _b, _c } = this.rgb();
    const [ r, g, b ] = [ _a, _b, _c ].map(v => v / 255);

    // Get the cmyk values in an unbounded format
    const k = Math.min(1 - r, 1 - g, 1 - b);

    if (k === 1) {
      // Catch the black case
      return new Color(0, 0, 0, 1, 'cmyk')
    }

    const c = (1 - r - k) / (1 - k);
    const m = (1 - g - k) / (1 - k);
    const y = (1 - b - k) / (1 - k);

    // Construct the new color
    const color = new Color(c, m, y, k, 'cmyk');
    return color
  }

  hsl () {

    // Get the rgb values
    const { _a, _b, _c } = this.rgb();
    const [ r, g, b ] = [ _a, _b, _c ].map(v => v / 255);

    // Find the maximum and minimum values to get the lightness
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;

    // If the r, g, v values are identical then we are grey
    const isGrey = max === min;

    // Calculate the hue and saturation
    const delta = max - min;
    const s = isGrey
      ? 0
      : l > 0.5
        ? delta / (2 - max - min)
        : delta / (max + min);
    const h = isGrey
      ? 0
      : max === r
        ? ((g - b) / delta + (g < b ? 6 : 0)) / 6
        : max === g
          ? ((b - r) / delta + 2) / 6
          : max === b
            ? ((r - g) / delta + 4) / 6
            : 0;

    // Construct and return the new color
    const color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
    return color
  }

  init (a = 0, b = 0, c = 0, d = 0, space = 'rgb') {
    // This catches the case when a falsy value is passed like ''
    a = !a ? 0 : a;

    // Reset all values in case the init function is rerun with new color space
    if (this.space) {
      for (const component in this.space) {
        delete this[this.space[component]];
      }
    }

    if (typeof a === 'number') {
      // Allow for the case that we don't need d...
      space = typeof d === 'string' ? d : space;
      d = typeof d === 'string' ? 0 : d;

      // Assign the values straight to the color
      Object.assign(this, { _a: a, _b: b, _c: c, _d: d, space });
    // If the user gave us an array, make the color from it
    } else if (a instanceof Array) {
      this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
      Object.assign(this, { _a: a[0], _b: a[1], _c: a[2], _d: a[3] || 0 });
    } else if (a instanceof Object) {
      // Set the object up and assign its values directly
      const values = getParameters(a, b);
      Object.assign(this, values);
    } else if (typeof a === 'string') {
      if (isRgb.test(a)) {
        const noWhitespace = a.replace(whitespace, '');
        const [ _a, _b, _c ] = rgb.exec(noWhitespace)
          .slice(1, 4).map(v => parseInt(v));
        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' });
      } else if (isHex.test(a)) {
        const hexParse = v => parseInt(v, 16);
        const [ , _a, _b, _c ] = hex.exec(sixDigitHex(a)).map(hexParse);
        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' });
      } else throw Error('Unsupported string format, can\'t construct Color')
    }

    // Now add the components as a convenience
    const { _a, _b, _c, _d } = this;
    const components = this.space === 'rgb'
      ? { r: _a, g: _b, b: _c }
      : this.space === 'xyz'
        ? { x: _a, y: _b, z: _c }
        : this.space === 'hsl'
          ? { h: _a, s: _b, l: _c }
          : this.space === 'lab'
            ? { l: _a, a: _b, b: _c }
            : this.space === 'lch'
              ? { l: _a, c: _b, h: _c }
              : this.space === 'cmyk'
                ? { c: _a, m: _b, y: _c, k: _d }
                : {};
    Object.assign(this, components);
  }

  lab () {
    // Get the xyz color
    const { x, y, z } = this.xyz();

    // Get the lab components
    const l = (116 * y) - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);

    // Construct and return a new color
    const color = new Color(l, a, b, 'lab');
    return color
  }

  lch () {

    // Get the lab color directly
    const { l, a, b } = this.lab();

    // Get the chromaticity and the hue using polar coordinates
    const c = Math.sqrt(a ** 2 + b ** 2);
    let h = 180 * Math.atan2(b, a) / Math.PI;
    if (h < 0) {
      h *= -1;
      h = 360 - h;
    }

    // Make a new color and return it
    const color = new Color(l, c, h, 'lch');
    return color
  }
  /*
  Conversion Methods
  */

  rgb () {
    if (this.space === 'rgb') {
      return this
    } else if (cieSpace(this.space)) {
      // Convert to the xyz color space
      let { x, y, z } = this;
      if (this.space === 'lab' || this.space === 'lch') {
        // Get the values in the lab space
        let { l, a, b } = this;
        if (this.space === 'lch') {
          const { c, h } = this;
          const dToR = Math.PI / 180;
          a = c * Math.cos(dToR * h);
          b = c * Math.sin(dToR * h);
        }

        // Undo the nonlinear function
        const yL = (l + 16) / 116;
        const xL = a / 500 + yL;
        const zL = yL - b / 200;

        // Get the xyz values
        const ct = 16 / 116;
        const mx = 0.008856;
        const nm = 7.787;
        x = 0.95047 * ((xL ** 3 > mx) ? xL ** 3 : (xL - ct) / nm);
        y = 1.00000 * ((yL ** 3 > mx) ? yL ** 3 : (yL - ct) / nm);
        z = 1.08883 * ((zL ** 3 > mx) ? zL ** 3 : (zL - ct) / nm);
      }

      // Convert xyz to unbounded rgb values
      const rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
      const gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
      const bU = x * 0.0557 + y * -0.2040 + z * 1.0570;

      // Convert the values to true rgb values
      const pow = Math.pow;
      const bd = 0.0031308;
      const r = (rU > bd) ? (1.055 * pow(rU, 1 / 2.4) - 0.055) : 12.92 * rU;
      const g = (gU > bd) ? (1.055 * pow(gU, 1 / 2.4) - 0.055) : 12.92 * gU;
      const b = (bU > bd) ? (1.055 * pow(bU, 1 / 2.4) - 0.055) : 12.92 * bU;

      // Make and return the color
      const color = new Color(255 * r, 255 * g, 255 * b);
      return color
    } else if (this.space === 'hsl') {
      // https://bgrins.github.io/TinyColor/docs/tinycolor.html
      // Get the current hsl values
      let { h, s, l } = this;
      h /= 360;
      s /= 100;
      l /= 100;

      // If we are grey, then just make the color directly
      if (s === 0) {
        l *= 255;
        const color = new Color(l, l, l);
        return color
      }

      // TODO I have no idea what this does :D If you figure it out, tell me!
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;

      // Get the rgb values
      const r = 255 * hueToRgb(p, q, h + 1 / 3);
      const g = 255 * hueToRgb(p, q, h);
      const b = 255 * hueToRgb(p, q, h - 1 / 3);

      // Make a new color
      const color = new Color(r, g, b);
      return color
    } else if (this.space === 'cmyk') {
      // https://gist.github.com/felipesabino/5066336
      // Get the normalised cmyk values
      const { c, m, y, k } = this;

      // Get the rgb values
      const r = 255 * (1 - Math.min(1, c * (1 - k) + k));
      const g = 255 * (1 - Math.min(1, m * (1 - k) + k));
      const b = 255 * (1 - Math.min(1, y * (1 - k) + k));

      // Form the color and return it
      const color = new Color(r, g, b);
      return color
    } else {
      return this
    }
  }

  toArray () {
    const { _a, _b, _c, _d, space } = this;
    return [ _a, _b, _c, _d, space ]
  }

  toHex () {
    const [ r, g, b ] = this._clamped().map(componentHex);
    return `#${r}${g}${b}`
  }

  toRgb () {
    const [ rV, gV, bV ] = this._clamped();
    const string = `rgb(${rV},${gV},${bV})`;
    return string
  }

  toString () {
    return this.toHex()
  }

  xyz () {

    // Normalise the red, green and blue values
    const { _a: r255, _b: g255, _c: b255 } = this.rgb();
    const [ r, g, b ] = [ r255, g255, b255 ].map(v => v / 255);

    // Convert to the lab rgb space
    const rL = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    const gL = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    const bL = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

    // Convert to the xyz color space without bounding the values
    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.00000;
    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;

    // Get the proper xyz values by applying the bounding
    const x = (xU > 0.008856) ? Math.pow(xU, 1 / 3) : (7.787 * xU) + 16 / 116;
    const y = (yU > 0.008856) ? Math.pow(yU, 1 / 3) : (7.787 * yU) + 16 / 116;
    const z = (zU > 0.008856) ? Math.pow(zU, 1 / 3) : (7.787 * zU) + 16 / 116;

    // Make and return the color
    const color = new Color(x, y, z, 'xyz');
    return color
  }

  /*
  Input and Output methods
  */

  _clamped () {
    const { _a, _b, _c } = this.rgb();
    const { max, min, round } = Math;
    const format = v => max(0, min(round(v), 255));
    return [ _a, _b, _c ].map(format)
  }

  /*
  Constructing colors
  */

}

class Point {
  // Initialize
  constructor (...args) {
    this.init(...args);
  }

  // Clone point
  clone () {
    return new Point(this)
  }

  init (x, y) {
    const base = { x: 0, y: 0 };

    // ensure source as object
    const source = Array.isArray(x)
      ? { x: x[0], y: x[1] }
      : typeof x === 'object'
        ? { x: x.x, y: x.y }
        : { x: x, y: y };

    // merge source
    this.x = source.x == null ? base.x : source.x;
    this.y = source.y == null ? base.y : source.y;

    return this
  }

  toArray () {
    return [ this.x, this.y ]
  }

  transform (m) {
    return this.clone().transformO(m)
  }

  // Transform point with matrix
  transformO (m) {
    if (!Matrix.isMatrixLike(m)) {
      m = new Matrix(m);
    }

    const { x, y } = this;

    // Perform the matrix multiplication
    this.x = m.a * x + m.c * y + m.e;
    this.y = m.b * x + m.d * y + m.f;

    return this
  }

}

function point (x, y) {
  return new Point(x, y).transform(this.screenCTM().inverse())
}

function closeEnough (a, b, threshold) {
  return Math.abs(b - a) < (threshold || 1e-6)
}

class Matrix {
  constructor (...args) {
    this.init(...args);
  }

  static formatTransforms (o) {
    // Get all of the parameters required to form the matrix
    const flipBoth = o.flip === 'both' || o.flip === true;
    const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
    const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
    const skewX = o.skew && o.skew.length
      ? o.skew[0]
      : isFinite(o.skew)
        ? o.skew
        : isFinite(o.skewX)
          ? o.skewX
          : 0;
    const skewY = o.skew && o.skew.length
      ? o.skew[1]
      : isFinite(o.skew)
        ? o.skew
        : isFinite(o.skewY)
          ? o.skewY
          : 0;
    const scaleX = o.scale && o.scale.length
      ? o.scale[0] * flipX
      : isFinite(o.scale)
        ? o.scale * flipX
        : isFinite(o.scaleX)
          ? o.scaleX * flipX
          : flipX;
    const scaleY = o.scale && o.scale.length
      ? o.scale[1] * flipY
      : isFinite(o.scale)
        ? o.scale * flipY
        : isFinite(o.scaleY)
          ? o.scaleY * flipY
          : flipY;
    const shear = o.shear || 0;
    const theta = o.rotate || o.theta || 0;
    const origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);
    const ox = origin.x;
    const oy = origin.y;
    // We need Point to be invalid if nothing was passed because we cannot default to 0 here. Thats why NaN
    const position = new Point(o.position || o.px || o.positionX || NaN, o.py || o.positionY || NaN);
    const px = position.x;
    const py = position.y;
    const translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);
    const tx = translate.x;
    const ty = translate.y;
    const relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);
    const rx = relative.x;
    const ry = relative.y;

    // Populate all of the values
    return {
      scaleX, scaleY, skewX, skewY, shear, theta, rx, ry, tx, ty, ox, oy, px, py
    }
  }

  static fromArray (a) {
    return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }
  }

  static isMatrixLike (o) {
    return (
      o.a != null
      || o.b != null
      || o.c != null
      || o.d != null
      || o.e != null
      || o.f != null
    )
  }

  // left matrix, right matrix, target matrix which is overwritten
  static matrixMultiply (l, r, o) {
    // Work out the product directly
    const a = l.a * r.a + l.c * r.b;
    const b = l.b * r.a + l.d * r.b;
    const c = l.a * r.c + l.c * r.d;
    const d = l.b * r.c + l.d * r.d;
    const e = l.e + l.a * r.e + l.c * r.f;
    const f = l.f + l.b * r.e + l.d * r.f;

    // make sure to use local variables because l/r and o could be the same
    o.a = a;
    o.b = b;
    o.c = c;
    o.d = d;
    o.e = e;
    o.f = f;

    return o
  }

  around (cx, cy, matrix) {
    return this.clone().aroundO(cx, cy, matrix)
  }

  // Transform around a center point
  aroundO (cx, cy, matrix) {
    const dx = cx || 0;
    const dy = cy || 0;
    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy)
  }

  // Clones this matrix
  clone () {
    return new Matrix(this)
  }

  // Decomposes this matrix into its affine parameters
  decompose (cx = 0, cy = 0) {
    // Get the parameters from the matrix
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const e = this.e;
    const f = this.f;

    // Figure out if the winding direction is clockwise or counterclockwise
    const determinant = a * d - b * c;
    const ccw = determinant > 0 ? 1 : -1;

    // Since we only shear in x, we can use the x basis to get the x scale
    // and the rotation of the resulting matrix
    const sx = ccw * Math.sqrt(a * a + b * b);
    const thetaRad = Math.atan2(ccw * b, ccw * a);
    const theta = 180 / Math.PI * thetaRad;
    const ct = Math.cos(thetaRad);
    const st = Math.sin(thetaRad);

    // We can then solve the y basis vector simultaneously to get the other
    // two affine parameters directly from these parameters
    const lam = (a * c + b * d) / determinant;
    const sy = ((c * sx) / (lam * a - b)) || ((d * sx) / (lam * b + a));

    // Use the translations
    const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
    const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy);

    // Construct the decomposition and return it
    return {
      // Return the affine parameters
      scaleX: sx,
      scaleY: sy,
      shear: lam,
      rotate: theta,
      translateX: tx,
      translateY: ty,
      originX: cx,
      originY: cy,

      // Return the matrix parameters
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    }
  }

  // Check if two matrices are equal
  equals (other) {
    if (other === this) return true
    const comp = new Matrix(other);
    return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b)
      && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d)
      && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f)
  }

  // Flip matrix on x or y, at a given offset
  flip (axis, around) {
    return this.clone().flipO(axis, around)
  }

  flipO (axis, around) {
    return axis === 'x'
      ? this.scaleO(-1, 1, around, 0)
      : axis === 'y'
        ? this.scaleO(1, -1, 0, around)
        : this.scaleO(-1, -1, axis, around || axis) // Define an x, y flip point
  }

  // Initialize
  init (source) {
    const base = Matrix.fromArray([ 1, 0, 0, 1, 0, 0 ]);

    // ensure source as object
    source = source instanceof Element
      ? source.matrixify()
      : typeof source === 'string'
        ? Matrix.fromArray(source.split(delimiter).map(parseFloat))
        : Array.isArray(source)
          ? Matrix.fromArray(source)
          : (typeof source === 'object' && Matrix.isMatrixLike(source))
            ? source
            : (typeof source === 'object')
              ? new Matrix().transform(source)
              : arguments.length === 6
                ? Matrix.fromArray([].slice.call(arguments))
                : base;

    // Merge the source matrix with the base matrix
    this.a = source.a != null ? source.a : base.a;
    this.b = source.b != null ? source.b : base.b;
    this.c = source.c != null ? source.c : base.c;
    this.d = source.d != null ? source.d : base.d;
    this.e = source.e != null ? source.e : base.e;
    this.f = source.f != null ? source.f : base.f;

    return this
  }

  inverse () {
    return this.clone().inverseO()
  }

  // Inverses matrix
  inverseO () {
    // Get the current parameters out of the matrix
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const e = this.e;
    const f = this.f;

    // Invert the 2x2 matrix in the top left
    const det = a * d - b * c;
    if (!det) throw new Error('Cannot invert ' + this)

    // Calculate the top 2x2 matrix
    const na = d / det;
    const nb = -b / det;
    const nc = -c / det;
    const nd = a / det;

    // Apply the inverted matrix to the top right
    const ne = -(na * e + nc * f);
    const nf = -(nb * e + nd * f);

    // Construct the inverted matrix
    this.a = na;
    this.b = nb;
    this.c = nc;
    this.d = nd;
    this.e = ne;
    this.f = nf;

    return this
  }

  lmultiply (matrix) {
    return this.clone().lmultiplyO(matrix)
  }

  lmultiplyO (matrix) {
    const r = this;
    const l = matrix instanceof Matrix
      ? matrix
      : new Matrix(matrix);

    return Matrix.matrixMultiply(l, r, this)
  }

  // Left multiplies by the given matrix
  multiply (matrix) {
    return this.clone().multiplyO(matrix)
  }

  multiplyO (matrix) {
    // Get the matrices
    const l = this;
    const r = matrix instanceof Matrix
      ? matrix
      : new Matrix(matrix);

    return Matrix.matrixMultiply(l, r, this)
  }

  // Rotate matrix
  rotate (r, cx, cy) {
    return this.clone().rotateO(r, cx, cy)
  }

  rotateO (r, cx = 0, cy = 0) {
    // Convert degrees to radians
    r = radians(r);

    const cos = Math.cos(r);
    const sin = Math.sin(r);

    const { a, b, c, d, e, f } = this;

    this.a = a * cos - b * sin;
    this.b = b * cos + a * sin;
    this.c = c * cos - d * sin;
    this.d = d * cos + c * sin;
    this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
    this.f = f * cos + e * sin - cx * sin - cy * cos + cy;

    return this
  }

  // Scale matrix
  scale (x, y, cx, cy) {
    return this.clone().scaleO(...arguments)
  }

  scaleO (x, y = x, cx = 0, cy = 0) {
    // Support uniform scaling
    if (arguments.length === 3) {
      cy = cx;
      cx = y;
      y = x;
    }

    const { a, b, c, d, e, f } = this;

    this.a = a * x;
    this.b = b * y;
    this.c = c * x;
    this.d = d * y;
    this.e = e * x - cx * x + cx;
    this.f = f * y - cy * y + cy;

    return this
  }

  // Shear matrix
  shear (a, cx, cy) {
    return this.clone().shearO(a, cx, cy)
  }

  shearO (lx, cx = 0, cy = 0) {
    const { a, b, c, d, e, f } = this;

    this.a = a + b * lx;
    this.c = c + d * lx;
    this.e = e + f * lx - cy * lx;

    return this
  }

  // Skew Matrix
  skew (x, y, cx, cy) {
    return this.clone().skewO(...arguments)
  }

  skewO (x, y = x, cx = 0, cy = 0) {
    // support uniformal skew
    if (arguments.length === 3) {
      cy = cx;
      cx = y;
      y = x;
    }

    // Convert degrees to radians
    x = radians(x);
    y = radians(y);

    const lx = Math.tan(x);
    const ly = Math.tan(y);

    const { a, b, c, d, e, f } = this;

    this.a = a + b * lx;
    this.b = b + a * ly;
    this.c = c + d * lx;
    this.d = d + c * ly;
    this.e = e + f * lx - cy * lx;
    this.f = f + e * ly - cx * ly;

    return this
  }

  // SkewX
  skewX (x, cx, cy) {
    return this.skew(x, 0, cx, cy)
  }

  // SkewY
  skewY (y, cx, cy) {
    return this.skew(0, y, cx, cy)
  }

  toArray () {
    return [ this.a, this.b, this.c, this.d, this.e, this.f ]
  }

  // Convert matrix to string
  toString () {
    return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'
  }

  // Transform a matrix into another matrix by manipulating the space
  transform (o) {
    // Check if o is a matrix and then left multiply it directly
    if (Matrix.isMatrixLike(o)) {
      const matrix = new Matrix(o);
      return matrix.multiplyO(this)
    }

    // Get the proposed transformations and the current transformations
    const t = Matrix.formatTransforms(o);
    const current = this;
    const { x: ox, y: oy } = new Point(t.ox, t.oy).transform(current);

    // Construct the resulting matrix
    const transformer = new Matrix()
      .translateO(t.rx, t.ry)
      .lmultiplyO(current)
      .translateO(-ox, -oy)
      .scaleO(t.scaleX, t.scaleY)
      .skewO(t.skewX, t.skewY)
      .shearO(t.shear)
      .rotateO(t.theta)
      .translateO(ox, oy);

    // If we want the origin at a particular place, we force it there
    if (isFinite(t.px) || isFinite(t.py)) {
      const origin = new Point(ox, oy).transform(transformer);
      // TODO: Replace t.px with isFinite(t.px)
      // Doesnt work because t.px is also 0 if it wasnt passed
      const dx = isFinite(t.px) ? t.px - origin.x : 0;
      const dy = isFinite(t.py) ? t.py - origin.y : 0;
      transformer.translateO(dx, dy);
    }

    // Translate now after positioning
    transformer.translateO(t.tx, t.ty);
    return transformer
  }

  // Translate matrix
  translate (x, y) {
    return this.clone().translateO(x, y)
  }

  translateO (x, y) {
    this.e += x || 0;
    this.f += y || 0;
    return this
  }

  valueOf () {
    return {
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    }
  }

}

function ctm () {
  return new Matrix(this.node.getCTM())
}

function screenCTM () {
  /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
     This is needed because FF does not return the transformation matrix
     for the inner coordinate system when getScreenCTM() is called on nested svgs.
     However all other Browsers do that */
  if (typeof this.isRoot === 'function' && !this.isRoot()) {
    const rect = this.rect(1, 1);
    const m = rect.node.getScreenCTM();
    rect.remove();
    return new Matrix(m)
  }
  return new Matrix(this.node.getScreenCTM())
}

register(Matrix, 'Matrix');

function parser () {
  // Reuse cached element if possible
  if (!parser.nodes) {
    const svg = makeInstance().size(2, 0);
    svg.node.style.cssText = [
      'opacity: 0',
      'position: absolute',
      'left: -100%',
      'top: -100%',
      'overflow: hidden'
    ].join(';');

    svg.attr('focusable', 'false');
    svg.attr('aria-hidden', 'true');

    const path = svg.path().node;

    parser.nodes = { svg, path };
  }

  if (!parser.nodes.svg.node.parentNode) {
    const b = globals.document.body || globals.document.documentElement;
    parser.nodes.svg.addTo(b);
  }

  return parser.nodes
}

function isNulledBox (box) {
  return !box.width && !box.height && !box.x && !box.y
}

function domContains (node) {
  return node === globals.document
    || (globals.document.documentElement.contains || function (node) {
      // This is IE - it does not support contains() for top-level SVGs
      while (node.parentNode) {
        node = node.parentNode;
      }
      return node === globals.document
    }).call(globals.document.documentElement, node)
}

class Box {
  constructor (...args) {
    this.init(...args);
  }

  addOffset () {
    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
    this.x += globals.window.pageXOffset;
    this.y += globals.window.pageYOffset;
    return new Box(this)
  }

  init (source) {
    const base = [ 0, 0, 0, 0 ];
    source = typeof source === 'string'
      ? source.split(delimiter).map(parseFloat)
      : Array.isArray(source)
        ? source
        : typeof source === 'object'
          ? [ source.left != null
            ? source.left
            : source.x, source.top != null ? source.top : source.y, source.width, source.height ]
          : arguments.length === 4
            ? [].slice.call(arguments)
            : base;

    this.x = source[0] || 0;
    this.y = source[1] || 0;
    this.width = this.w = source[2] || 0;
    this.height = this.h = source[3] || 0;

    // Add more bounding box properties
    this.x2 = this.x + this.w;
    this.y2 = this.y + this.h;
    this.cx = this.x + this.w / 2;
    this.cy = this.y + this.h / 2;

    return this
  }

  isNulled () {
    return isNulledBox(this)
  }

  // Merge rect box with another, return a new instance
  merge (box) {
    const x = Math.min(this.x, box.x);
    const y = Math.min(this.y, box.y);
    const width = Math.max(this.x + this.width, box.x + box.width) - x;
    const height = Math.max(this.y + this.height, box.y + box.height) - y;

    return new Box(x, y, width, height)
  }

  toArray () {
    return [ this.x, this.y, this.width, this.height ]
  }

  toString () {
    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
  }

  transform (m) {
    if (!(m instanceof Matrix)) {
      m = new Matrix(m);
    }

    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;

    const pts = [
      new Point(this.x, this.y),
      new Point(this.x2, this.y),
      new Point(this.x, this.y2),
      new Point(this.x2, this.y2)
    ];

    pts.forEach(function (p) {
      p = p.transform(m);
      xMin = Math.min(xMin, p.x);
      xMax = Math.max(xMax, p.x);
      yMin = Math.min(yMin, p.y);
      yMax = Math.max(yMax, p.y);
    });

    return new Box(
      xMin, yMin,
      xMax - xMin,
      yMax - yMin
    )
  }

}

function getBox (el, getBBoxFn, retry) {
  let box;

  try {
    // Try to get the box with the provided function
    box = getBBoxFn(el.node);

    // If the box is worthless and not even in the dom, retry
    // by throwing an error here...
    if (isNulledBox(box) && !domContains(el.node)) {
      throw new Error('Element not in the dom')
    }
  } catch (e) {
    // ... and calling the retry handler here
    box = retry(el);
  }

  return box
}

function bbox () {
  // Function to get bbox is getBBox()
  const getBBox = (node) => node.getBBox();

  // Take all measures so that a stupid browser renders the element
  // so we can get the bbox from it when we try again
  const retry = (el) => {
    try {
      const clone = el.clone().addTo(parser().svg).show();
      const box = clone.node.getBBox();
      clone.remove();
      return box
    } catch (e) {
      // We give up...
      throw new Error(`Getting bbox of element "${el.node.nodeName}" is not possible: ${e.toString()}`)
    }
  };

  const box = getBox(this, getBBox, retry);
  const bbox = new Box(box);

  return bbox
}

function rbox (el) {
  const getRBox = (node) => node.getBoundingClientRect();
  const retry = (el) => {
    // There is no point in trying tricks here because if we insert the element into the dom ourselves
    // it obviously will be at the wrong position
    throw new Error(`Getting rbox of element "${el.node.nodeName}" is not possible`)
  };

  const box = getBox(this, getRBox, retry);
  const rbox = new Box(box);

  // If an element was passed, we want the bbox in the coordinate system of that element
  if (el) {
    return rbox.transform(el.screenCTM().inverseO())
  }

  // Else we want it in absolute screen coordinates
  // Therefore we need to add the scrollOffset
  return rbox.addOffset()
}

// Checks whether the given point is inside the bounding box
function inside (x, y) {
  const box = this.bbox();

  return x > box.x
    && y > box.y
    && x < box.x + box.width
    && y < box.y + box.height
}

registerMethods({
  viewbox: {
    viewbox (x, y, width, height) {
      // act as getter
      if (x == null) return new Box(this.attr('viewBox'))

      // act as setter
      return this.attr('viewBox', new Box(x, y, width, height))
    },

    zoom (level, point) {
      // Its best to rely on the attributes here and here is why:
      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)
      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely
      //                        that means, their clientRect is always as big as the content.
      //                        Furthermore this size is incorrect if the element is further transformed by its parents
      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!
      // getBBox: returns the bounding box of its content - that doesnt help!
      let { width, height } = this.attr([ 'width', 'height' ]);

      // Width and height is a string when a number with a unit is present which we can't use
      // So we try clientXYZ
      if ((!width && !height) || (typeof width === 'string' || typeof height === 'string')) {
        width = this.node.clientWidth;
        height = this.node.clientHeight;
      }

      // Giving up...
      if (!width || !height) {
        throw new Error('Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element')
      }

      const v = this.viewbox();

      const zoomX = width / v.width;
      const zoomY = height / v.height;
      const zoom = Math.min(zoomX, zoomY);

      if (level == null) {
        return zoom
      }

      let zoomAmount = zoom / level;

      // Set the zoomAmount to the highest value which is safe to process and recover from
      // The * 100 is a bit of wiggle room for the matrix transformation
      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;

      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);

      const box = new Box(v).transform(
        new Matrix({ scale: zoomAmount, origin: point })
      );

      return this.viewbox(box)
    }
  }
});

register(Box, 'Box');

// import { subClassArray } from './ArrayPolyfill.js'

class List extends Array {
  constructor (arr = [], ...args) {
    super(arr, ...args);
    if (typeof arr === 'number') return this
    this.length = 0;
    this.push(...arr);
  }
}

extend([ List ], {
  each (fnOrMethodName, ...args) {
    if (typeof fnOrMethodName === 'function') {
      return this.map((el, i, arr) => {
        return fnOrMethodName.call(el, el, i, arr)
      })
    } else {
      return this.map(el => {
        return el[fnOrMethodName](...args)
      })
    }
  },

  toArray () {
    return Array.prototype.concat.apply([], this)
  }
});

const reserved = [ 'toArray', 'constructor', 'each' ];

List.extend = function (methods) {
  methods = methods.reduce((obj, name) => {
    // Don't overwrite own methods
    if (reserved.includes(name)) return obj

    // Don't add private methods
    if (name[0] === '_') return obj

    // Relay every call to each()
    obj[name] = function (...attrs) {
      return this.each(name, ...attrs)
    };
    return obj
  }, {});

  extend([ List ], methods);
};

function baseFind (query, parent) {
  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {
    return adopt(node)
  }))
}

// Scoped find method
function find (query) {
  return baseFind(query, this.node)
}

function findOne (query) {
  return adopt(this.node.querySelector(query))
}

let listenerId = 0;
const windowEvents = {};

function getEvents (instance) {
  let n = instance.getEventHolder();

  // We dont want to save events in global space
  if (n === globals.window) n = windowEvents;
  if (!n.events) n.events = {};
  return n.events
}

function getEventTarget (instance) {
  return instance.getEventTarget()
}

function clearEvents (instance) {
  let n = instance.getEventHolder();
  if (n === globals.window) n = windowEvents;
  if (n.events) n.events = {};
}

// Add event binder in the SVG namespace
function on (node, events, listener, binding, options) {
  const l = listener.bind(binding || node);
  const instance = makeInstance(node);
  const bag = getEvents(instance);
  const n = getEventTarget(instance);

  // events can be an array of events or a string of events
  events = Array.isArray(events) ? events : events.split(delimiter);

  // add id to listener
  if (!listener._svgjsListenerId) {
    listener._svgjsListenerId = ++listenerId;
  }

  events.forEach(function (event) {
    const ev = event.split('.')[0];
    const ns = event.split('.')[1] || '*';

    // ensure valid object
    bag[ev] = bag[ev] || {};
    bag[ev][ns] = bag[ev][ns] || {};

    // reference listener
    bag[ev][ns][listener._svgjsListenerId] = l;

    // add listener
    n.addEventListener(ev, l, options || false);
  });
}

// Add event unbinder in the SVG namespace
function off (node, events, listener, options) {
  const instance = makeInstance(node);
  const bag = getEvents(instance);
  const n = getEventTarget(instance);

  // listener can be a function or a number
  if (typeof listener === 'function') {
    listener = listener._svgjsListenerId;
    if (!listener) return
  }

  // events can be an array of events or a string or undefined
  events = Array.isArray(events) ? events : (events || '').split(delimiter);

  events.forEach(function (event) {
    const ev = event && event.split('.')[0];
    const ns = event && event.split('.')[1];
    let namespace, l;

    if (listener) {
      // remove listener reference
      if (bag[ev] && bag[ev][ns || '*']) {
        // removeListener
        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);

        delete bag[ev][ns || '*'][listener];
      }
    } else if (ev && ns) {
      // remove all listeners for a namespaced event
      if (bag[ev] && bag[ev][ns]) {
        for (l in bag[ev][ns]) {
          off(n, [ ev, ns ].join('.'), l);
        }

        delete bag[ev][ns];
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) {
            off(n, [ event, ns ].join('.'));
          }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (bag[ev]) {
        for (namespace in bag[ev]) {
          off(n, [ ev, namespace ].join('.'));
        }

        delete bag[ev];
      }
    } else {
      // remove all listeners on a given node
      for (event in bag) {
        off(n, event);
      }

      clearEvents(instance);
    }
  });
}

function dispatch (node, event, data, options) {
  const n = getEventTarget(node);

  // Dispatch event
  if (event instanceof globals.window.Event) {
    n.dispatchEvent(event);
  } else {
    event = new globals.window.CustomEvent(event, { detail: data, cancelable: true, ...options });
    n.dispatchEvent(event);
  }
  return event
}

class EventTarget extends Base {
  addEventListener () {}

  dispatch (event, data, options) {
    return dispatch(this, event, data, options)
  }

  dispatchEvent (event) {
    const bag = this.getEventHolder().events;
    if (!bag) return true

    const events = bag[event.type];

    for (const i in events) {
      for (const j in events[i]) {
        events[i][j](event);
      }
    }

    return !event.defaultPrevented
  }

  // Fire given event
  fire (event, data, options) {
    this.dispatch(event, data, options);
    return this
  }

  getEventHolder () {
    return this
  }

  getEventTarget () {
    return this
  }

  // Unbind event from listener
  off (event, listener, options) {
    off(this, event, listener, options);
    return this
  }

  // Bind given event to listener
  on (event, listener, binding, options) {
    on(this, event, listener, binding, options);
    return this
  }

  removeEventListener () {}
}

register(EventTarget, 'EventTarget');

function noop () {}

// Default animation values
const timeline = {
  duration: 400,
  ease: '>',
  delay: 0
};

// Default attribute values
const attrs = {

  // fill and stroke
  'fill-opacity': 1,
  'stroke-opacity': 1,
  'stroke-width': 0,
  'stroke-linejoin': 'miter',
  'stroke-linecap': 'butt',
  fill: '#000000',
  stroke: '#000000',
  opacity: 1,

  // position
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,

  // size
  width: 0,
  height: 0,

  // radius
  r: 0,
  rx: 0,
  ry: 0,

  // gradient
  offset: 0,
  'stop-opacity': 1,
  'stop-color': '#000000',

  // text
  'text-anchor': 'start'
};

class SVGArray extends Array {
  constructor (...args) {
    super(...args);
    this.init(...args);
  }

  clone () {
    return new this.constructor(this)
  }

  init (arr) {
    // This catches the case, that native map tries to create an array with new Array(1)
    if (typeof arr === 'number') return this
    this.length = 0;
    this.push(...this.parse(arr));
    return this
  }

  // Parse whitespace separated string
  parse (array = []) {
    // If already is an array, no need to parse it
    if (array instanceof Array) return array

    return array.trim().split(delimiter).map(parseFloat)
  }

  toArray () {
    return Array.prototype.concat.apply([], this)
  }

  toSet () {
    return new Set(this)
  }

  toString () {
    return this.join(' ')
  }

  // Flattens the array if needed
  valueOf () {
    const ret = [];
    ret.push(...this);
    return ret
  }

}

// Module for unit conversions
class SVGNumber {
  // Initialize
  constructor (...args) {
    this.init(...args);
  }

  convert (unit) {
    return new SVGNumber(this.value, unit)
  }

  // Divide number
  divide (number) {
    number = new SVGNumber(number);
    return new SVGNumber(this / number, this.unit || number.unit)
  }

  init (value, unit) {
    unit = Array.isArray(value) ? value[1] : unit;
    value = Array.isArray(value) ? value[0] : value;

    // initialize defaults
    this.value = 0;
    this.unit = unit || '';

    // parse value
    if (typeof value === 'number') {
      // ensure a valid numeric value
      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value;
    } else if (typeof value === 'string') {
      unit = value.match(numberAndUnit);

      if (unit) {
        // make value numeric
        this.value = parseFloat(unit[1]);

        // normalize
        if (unit[5] === '%') {
          this.value /= 100;
        } else if (unit[5] === 's') {
          this.value *= 1000;
        }

        // store unit
        this.unit = unit[5];
      }
    } else {
      if (value instanceof SVGNumber) {
        this.value = value.valueOf();
        this.unit = value.unit;
      }
    }

    return this
  }

  // Subtract number
  minus (number) {
    number = new SVGNumber(number);
    return new SVGNumber(this - number, this.unit || number.unit)
  }

  // Add number
  plus (number) {
    number = new SVGNumber(number);
    return new SVGNumber(this + number, this.unit || number.unit)
  }

  // Multiply number
  times (number) {
    number = new SVGNumber(number);
    return new SVGNumber(this * number, this.unit || number.unit)
  }

  toArray () {
    return [ this.value, this.unit ]
  }

  toJSON () {
    return this.toString()
  }

  toString () {
    return (this.unit === '%'
      ? ~~(this.value * 1e8) / 1e6
      : this.unit === 's'
        ? this.value / 1e3
        : this.value
    ) + this.unit
  }

  valueOf () {
    return this.value
  }

}

const hooks = [];
function registerAttrHook (fn) {
  hooks.push(fn);
}

// Set svg element attribute
function attr (attr, val, ns) {
  // act as full getter
  if (attr == null) {
    // get an object of attributes
    attr = {};
    val = this.node.attributes;

    for (const node of val) {
      attr[node.nodeName] = isNumber.test(node.nodeValue)
        ? parseFloat(node.nodeValue)
        : node.nodeValue;
    }

    return attr
  } else if (attr instanceof Array) {
    // loop through array and get all values
    return attr.reduce((last, curr) => {
      last[curr] = this.attr(curr);
      return last
    }, {})
  } else if (typeof attr === 'object' && attr.constructor === Object) {
    // apply every attribute individually if an object is passed
    for (val in attr) this.attr(val, attr[val]);
  } else if (val === null) {
    // remove value
    this.node.removeAttribute(attr);
  } else if (val == null) {
    // act as a getter if the first and only argument is not an object
    val = this.node.getAttribute(attr);
    return val == null
      ? attrs[attr]
      : isNumber.test(val)
        ? parseFloat(val)
        : val
  } else {
    // Loop through hooks and execute them to convert value
    val = hooks.reduce((_val, hook) => {
      return hook(attr, _val, this)
    }, val);

    // ensure correct numeric values (also accepts NaN and Infinity)
    if (typeof val === 'number') {
      val = new SVGNumber(val);
    } else if (Color.isColor(val)) {
      // ensure full hex color
      val = new Color(val);
    } else if (val.constructor === Array) {
      // Check for plain arrays and parse array values
      val = new SVGArray(val);
    }

    // if the passed attribute is leading...
    if (attr === 'leading') {
      // ... call the leading method instead
      if (this.leading) {
        this.leading(val);
      }
    } else {
      // set given attribute on node
      typeof ns === 'string'
        ? this.node.setAttributeNS(ns, attr, val.toString())
        : this.node.setAttribute(attr, val.toString());
    }

    // rebuild if required
    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {
      this.rebuild();
    }
  }

  return this
}

class Dom extends EventTarget {
  constructor (node, attrs) {
    super();
    this.node = node;
    this.type = node.nodeName;

    if (attrs && node !== attrs) {
      this.attr(attrs);
    }
  }

  // Add given element at a position
  add (element, i) {
    element = makeInstance(element);

    // If non-root svg nodes are added we have to remove their namespaces
    if (element.removeNamespace && this.node instanceof globals.window.SVGElement) {
      element.removeNamespace();
    }

    if (i == null) {
      this.node.appendChild(element.node);
    } else if (element.node !== this.node.childNodes[i]) {
      this.node.insertBefore(element.node, this.node.childNodes[i]);
    }

    return this
  }

  // Add element to given container and return self
  addTo (parent, i) {
    return makeInstance(parent).put(this, i)
  }

  // Returns all child elements
  children () {
    return new List(map(this.node.children, function (node) {
      return adopt(node)
    }))
  }

  // Remove all elements in this container
  clear () {
    // remove children
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }

    return this
  }

  // Clone element
  clone (deep = true) {
    // write dom data to the dom so the clone can pickup the data
    this.writeDataToDom();

    // clone element and assign new id
    return new this.constructor(assignNewId(this.node.cloneNode(deep)))
  }

  // Iterates over all children and invokes a given block
  each (block, deep) {
    const children = this.children();
    let i, il;

    for (i = 0, il = children.length; i < il; i++) {
      block.apply(children[i], [ i, children ]);

      if (deep) {
        children[i].each(block, deep);
      }
    }

    return this
  }

  element (nodeName, attrs) {
    return this.put(new Dom(create(nodeName), attrs))
  }

  // Get first child
  first () {
    return adopt(this.node.firstChild)
  }

  // Get a element at the given index
  get (i) {
    return adopt(this.node.childNodes[i])
  }

  getEventHolder () {
    return this.node
  }

  getEventTarget () {
    return this.node
  }

  // Checks if the given element is a child
  has (element) {
    return this.index(element) >= 0
  }

  html (htmlOrFn, outerHTML) {
    return this.xml(htmlOrFn, outerHTML, html)
  }

  // Get / set id
  id (id) {
    // generate new id if no id set
    if (typeof id === 'undefined' && !this.node.id) {
      this.node.id = eid(this.type);
    }

    // don't set directly with this.node.id to make `null` work correctly
    return this.attr('id', id)
  }

  // Gets index of given element
  index (element) {
    return [].slice.call(this.node.childNodes).indexOf(element.node)
  }

  // Get the last child
  last () {
    return adopt(this.node.lastChild)
  }

  // matches the element vs a css selector
  matches (selector) {
    const el = this.node;
    const matcher = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector || null;
    return matcher && matcher.call(el, selector)
  }

  // Returns the parent element instance
  parent (type) {
    let parent = this;

    // check for parent
    if (!parent.node.parentNode) return null

    // get parent element
    parent = adopt(parent.node.parentNode);

    if (!type) return parent

    // loop trough ancestors if type is given
    do {
      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent
    } while ((parent = adopt(parent.node.parentNode)))

    return parent
  }

  // Basically does the same as `add()` but returns the added element instead
  put (element, i) {
    element = makeInstance(element);
    this.add(element, i);
    return element
  }

  // Add element to given container and return container
  putIn (parent, i) {
    return makeInstance(parent).add(this, i)
  }

  // Remove element
  remove () {
    if (this.parent()) {
      this.parent().removeElement(this);
    }

    return this
  }

  // Remove a given child
  removeElement (element) {
    this.node.removeChild(element.node);

    return this
  }

  // Replace this with element
  replace (element) {
    element = makeInstance(element);

    if (this.node.parentNode) {
      this.node.parentNode.replaceChild(element.node, this.node);
    }

    return element
  }

  round (precision = 2, map = null) {
    const factor = 10 ** precision;
    const attrs = this.attr(map);

    for (const i in attrs) {
      if (typeof attrs[i] === 'number') {
        attrs[i] = Math.round(attrs[i] * factor) / factor;
      }
    }

    this.attr(attrs);
    return this
  }

  // Import / Export raw svg
  svg (svgOrFn, outerSVG) {
    return this.xml(svgOrFn, outerSVG, svg)
  }

  // Return id on string conversion
  toString () {
    return this.id()
  }

  words (text) {
    // This is faster than removing all children and adding a new one
    this.node.textContent = text;
    return this
  }

  wrap (node) {
    const parent = this.parent();

    if (!parent) {
      return this.addTo(node)
    }

    const position = parent.index(this);
    return parent.put(node, position).put(this)
  }

  // write svgjs data to the dom
  writeDataToDom () {
    // dump variables recursively
    this.each(function () {
      this.writeDataToDom();
    });

    return this
  }

  // Import / Export raw svg
  xml (xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === 'boolean') {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    }

    // act as getter if no svg string is given
    if (xmlOrFn == null || typeof xmlOrFn === 'function') {
      // The default for exports is, that the outerNode is included
      outerXML = outerXML == null ? true : outerXML;

      // write svgjs data to the dom
      this.writeDataToDom();
      let current = this;

      // An export modifier was passed
      if (xmlOrFn != null) {
        current = adopt(current.node.cloneNode(true));

        // If the user wants outerHTML we need to process this node, too
        if (outerXML) {
          const result = xmlOrFn(current);
          current = result || current;

          // The user does not want this node? Well, then he gets nothing
          if (result === false) return ''
        }

        // Deep loop through all children and apply modifier
        current.each(function () {
          const result = xmlOrFn(this);
          const _this = result || this;

          // If modifier returns false, discard node
          if (result === false) {
            this.remove();

            // If modifier returns new node, use it
          } else if (result && this !== _this) {
            this.replace(_this);
          }
        }, true);
      }

      // Return outer or inner content
      return outerXML
        ? current.node.outerHTML
        : current.node.innerHTML
    }

    // Act as setter if we got a string

    // The default for import is, that the current node is not replaced
    outerXML = outerXML == null ? false : outerXML;

    // Create temporary holder
    const well = create('wrapper', ns);
    const fragment = globals.document.createDocumentFragment();

    // Dump raw svg
    well.innerHTML = xmlOrFn;

    // Transplant nodes into the fragment
    for (let len = well.children.length; len--;) {
      fragment.appendChild(well.firstElementChild);
    }

    const parent = this.parent();

    // Add the whole fragment at once
    return outerXML
      ? this.replace(fragment) && parent
      : this.add(fragment)
  }
}

extend(Dom, { attr, find, findOne });
register(Dom, 'Dom');

class Element extends Dom {
  constructor (node, attrs) {
    super(node, attrs);

    // initialize data object
    this.dom = {};

    // create circular reference
    this.node.instance = this;

    if (node.hasAttribute('svgjs:data')) {
      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
      this.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});
    }
  }

  // Move element by its center
  center (x, y) {
    return this.cx(x).cy(y)
  }

  // Move by center over x-axis
  cx (x) {
    return x == null
      ? this.x() + this.width() / 2
      : this.x(x - this.width() / 2)
  }

  // Move by center over y-axis
  cy (y) {
    return y == null
      ? this.y() + this.height() / 2
      : this.y(y - this.height() / 2)
  }

  // Get defs
  defs () {
    const root = this.root();
    return root && root.defs()
  }

  // Relative move over x and y axes
  dmove (x, y) {
    return this.dx(x).dy(y)
  }

  // Relative move over x axis
  dx (x = 0) {
    return this.x(new SVGNumber(x).plus(this.x()))
  }

  // Relative move over y axis
  dy (y = 0) {
    return this.y(new SVGNumber(y).plus(this.y()))
  }

  getEventHolder () {
    return this
  }

  // Set height of element
  height (height) {
    return this.attr('height', height)
  }

  // Move element to given x and y values
  move (x, y) {
    return this.x(x).y(y)
  }

  // return array of all ancestors of given type up to the root svg
  parents (until = this.root()) {
    const isSelector = typeof until === 'string';
    if (!isSelector) {
      until = makeInstance(until);
    }
    const parents = new List();
    let parent = this;

    while (
      (parent = parent.parent())
      && parent.node !== globals.document
      && parent.nodeName !== '#document-fragment') {

      parents.push(parent);

      if (!isSelector && (parent.node === until.node)) {
        break
      }
      if (isSelector && parent.matches(until)) {
        break
      }
      if (parent.node === this.root().node) {
        // We worked our way to the root and didn't match `until`
        return null
      }
    }

    return parents
  }

  // Get referenced element form attribute value
  reference (attr) {
    attr = this.attr(attr);
    if (!attr) return null

    const m = (attr + '').match(reference);
    return m ? makeInstance(m[1]) : null
  }

  // Get parent document
  root () {
    const p = this.parent(getClass(root));
    return p && p.root()
  }

  // set given data to the elements data property
  setData (o) {
    this.dom = o;
    return this
  }

  // Set element size to given width and height
  size (width, height) {
    const p = proportionalSize(this, width, height);

    return this
      .width(new SVGNumber(p.width))
      .height(new SVGNumber(p.height))
  }

  // Set width of element
  width (width) {
    return this.attr('width', width)
  }

  // write svgjs data to the dom
  writeDataToDom () {
    // remove previously set data
    this.node.removeAttribute('svgjs:data');

    if (Object.keys(this.dom).length) {
      this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428
    }

    return super.writeDataToDom()
  }

  // Move over x-axis
  x (x) {
    return this.attr('x', x)
  }

  // Move over y-axis
  y (y) {
    return this.attr('y', y)
  }
}

extend(Element, {
  bbox, rbox, inside, point, ctm, screenCTM
});

register(Element, 'Element');

// Define list of available attributes for stroke and fill
const sugar = {
  stroke: [ 'color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset' ],
  fill: [ 'color', 'opacity', 'rule' ],
  prefix: function (t, a) {
    return a === 'color' ? t : t + '-' + a
  }
}

// Add sugar for fill and stroke
;[ 'fill', 'stroke' ].forEach(function (m) {
  const extension = {};
  let i;

  extension[m] = function (o) {
    if (typeof o === 'undefined') {
      return this.attr(m)
    }
    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || (o instanceof Element)) {
      this.attr(m, o);
    } else {
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--) {
        if (o[sugar[m][i]] != null) {
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
        }
      }
    }

    return this
  };

  registerMethods([ 'Element', 'Runner' ], extension);
});

registerMethods([ 'Element', 'Runner' ], {
  // Let the user set the matrix directly
  matrix: function (mat, b, c, d, e, f) {
    // Act as a getter
    if (mat == null) {
      return new Matrix(this)
    }

    // Act as a setter, the user can pass a matrix or a set of numbers
    return this.attr('transform', new Matrix(mat, b, c, d, e, f))
  },

  // Map rotation to transform
  rotate: function (angle, cx, cy) {
    return this.transform({ rotate: angle, ox: cx, oy: cy }, true)
  },

  // Map skew to transform
  skew: function (x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3
      ? this.transform({ skew: x, ox: y, oy: cx }, true)
      : this.transform({ skew: [ x, y ], ox: cx, oy: cy }, true)
  },

  shear: function (lam, cx, cy) {
    return this.transform({ shear: lam, ox: cx, oy: cy }, true)
  },

  // Map scale to transform
  scale: function (x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3
      ? this.transform({ scale: x, ox: y, oy: cx }, true)
      : this.transform({ scale: [ x, y ], ox: cx, oy: cy }, true)
  },

  // Map translate to transform
  translate: function (x, y) {
    return this.transform({ translate: [ x, y ] }, true)
  },

  // Map relative translations to transform
  relative: function (x, y) {
    return this.transform({ relative: [ x, y ] }, true)
  },

  // Map flip to transform
  flip: function (direction = 'both', origin = 'center') {
    if ('xybothtrue'.indexOf(direction) === -1) {
      origin = direction;
      direction = 'both';
    }

    return this.transform({ flip: direction, origin: origin }, true)
  },

  // Opacity
  opacity: function (value) {
    return this.attr('opacity', value)
  }
});

registerMethods('radius', {
  // Add x and y radius
  radius: function (x, y = x) {
    const type = (this._element || this).type;
    return type === 'radialGradient'
      ? this.attr('r', new SVGNumber(x))
      : this.rx(x).ry(y)
  }
});

registerMethods('Path', {
  // Get path length
  length: function () {
    return this.node.getTotalLength()
  },
  // Get point at length
  pointAt: function (length) {
    return new Point(this.node.getPointAtLength(length))
  }
});

registerMethods([ 'Element', 'Runner' ], {
  // Set font
  font: function (a, v) {
    if (typeof a === 'object') {
      for (v in a) this.font(v, a[v]);
      return this
    }

    return a === 'leading'
      ? this.leading(v)
      : a === 'anchor'
        ? this.attr('text-anchor', v)
        : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style'
          ? this.attr('font-' + a, v)
          : this.attr(a, v)
  }
});

// Add events to elements
const methods = [ 'click',
  'dblclick',
  'mousedown',
  'mouseup',
  'mouseover',
  'mouseout',
  'mousemove',
  'mouseenter',
  'mouseleave',
  'touchstart',
  'touchmove',
  'touchleave',
  'touchend',
  'touchcancel' ].reduce(function (last, event) {
  // add event to Element
  const fn = function (f) {
    if (f === null) {
      this.off(event);
    } else {
      this.on(event, f);
    }
    return this
  };

  last[event] = fn;
  return last
}, {});

registerMethods('Element', methods);

// Reset all transformations
function untransform () {
  return this.attr('transform', null)
}

// merge the whole transformation chain into one matrix and returns it
function matrixify () {
  const matrix = (this.attr('transform') || '')
    // split transformations
    .split(transforms).slice(0, -1).map(function (str) {
      // generate key => value pairs
      const kv = str.trim().split('(');
      return [ kv[0],
        kv[1].split(delimiter)
          .map(function (str) {
            return parseFloat(str)
          })
      ]
    })
    .reverse()
    // merge every transformation into one matrix
    .reduce(function (matrix, transform) {
      if (transform[0] === 'matrix') {
        return matrix.lmultiply(Matrix.fromArray(transform[1]))
      }
      return matrix[transform[0]].apply(matrix, transform[1])
    }, new Matrix());

  return matrix
}

// add an element to another parent without changing the visual representation on the screen
function toParent (parent, i) {
  if (this === parent) return this
  const ctm = this.screenCTM();
  const pCtm = parent.screenCTM().inverse();

  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));

  return this
}

// same as above with parent equals root-svg
function toRoot (i) {
  return this.toParent(this.root(), i)
}

// Add transformations
function transform (o, relative) {
  // Act as a getter if no object was passed
  if (o == null || typeof o === 'string') {
    const decomposed = new Matrix(this).decompose();
    return o == null ? decomposed : decomposed[o]
  }

  if (!Matrix.isMatrixLike(o)) {
    // Set the origin according to the defined transform
    o = { ...o, origin: getOrigin(o, this) };
  }

  // The user can pass a boolean, an Element or an Matrix or nothing
  const cleanRelative = relative === true ? this : (relative || false);
  const result = new Matrix(cleanRelative).transform(o);
  return this.attr('transform', result)
}

registerMethods('Element', {
  untransform, matrixify, toParent, toRoot, transform
});

class Container extends Element {
  flatten (parent = this, index) {
    this.each(function () {
      if (this instanceof Container) {
        return this.flatten().ungroup()
      }
    });

    return this
  }

  ungroup (parent = this.parent(), index = parent.index(this)) {
    // when parent != this, we want append all elements to the end
    index = index === -1 ? parent.children().length : index;

    this.each(function (i, children) {
      // reverse each
      return children[children.length - i - 1].toParent(parent, index)
    });

    return this.remove()
  }
}

register(Container, 'Container');

class Defs extends Container {
  constructor (node, attrs = node) {
    super(nodeOrNew('defs', node), attrs);
  }

  flatten () {
    return this
  }

  ungroup () {
    return this
  }
}

register(Defs, 'Defs');

class Shape extends Element {}

register(Shape, 'Shape');

// Radius x value
function rx (rx) {
  return this.attr('rx', rx)
}

// Radius y value
function ry (ry) {
  return this.attr('ry', ry)
}

// Move over x-axis
function x$3 (x) {
  return x == null
    ? this.cx() - this.rx()
    : this.cx(x + this.rx())
}

// Move over y-axis
function y$3 (y) {
  return y == null
    ? this.cy() - this.ry()
    : this.cy(y + this.ry())
}

// Move by center over x-axis
function cx$1 (x) {
  return this.attr('cx', x)
}

// Move by center over y-axis
function cy$1 (y) {
  return this.attr('cy', y)
}

// Set width of element
function width$2 (width) {
  return width == null
    ? this.rx() * 2
    : this.rx(new SVGNumber(width).divide(2))
}

// Set height of element
function height$2 (height) {
  return height == null
    ? this.ry() * 2
    : this.ry(new SVGNumber(height).divide(2))
}

var circled = /*#__PURE__*/Object.freeze({
  __proto__: null,
  rx: rx,
  ry: ry,
  x: x$3,
  y: y$3,
  cx: cx$1,
  cy: cy$1,
  width: width$2,
  height: height$2
});

class Ellipse extends Shape {
  constructor (node, attrs = node) {
    super(nodeOrNew('ellipse', node), attrs);
  }

  size (width, height) {
    const p = proportionalSize(this, width, height);

    return this
      .rx(new SVGNumber(p.width).divide(2))
      .ry(new SVGNumber(p.height).divide(2))
  }
}

extend(Ellipse, circled);

registerMethods('Container', {
  // Create an ellipse
  ellipse: wrapWithAttrCheck(function (width = 0, height = width) {
    return this.put(new Ellipse()).size(width, height).move(0, 0)
  })
});

register(Ellipse, 'Ellipse');

class Fragment extends Dom {
  constructor (node = globals.document.createDocumentFragment()) {
    super(node);
  }

  // Import / Export raw xml
  xml (xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === 'boolean') {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    }

    // because this is a fragment we have to put all elements into a wrapper first
    // before we can get the innerXML from it
    if (xmlOrFn == null || typeof xmlOrFn === 'function') {
      const wrapper = new Dom(create('wrapper', ns));
      wrapper.add(this.node.cloneNode(true));

      return wrapper.xml(false, ns)
    }

    // Act as setter if we got a string
    return super.xml(xmlOrFn, false, ns)
  }

}

register(Fragment, 'Fragment');

function from (x, y) {
  return (this._element || this).type === 'radialGradient'
    ? this.attr({ fx: new SVGNumber(x), fy: new SVGNumber(y) })
    : this.attr({ x1: new SVGNumber(x), y1: new SVGNumber(y) })
}

function to (x, y) {
  return (this._element || this).type === 'radialGradient'
    ? this.attr({ cx: new SVGNumber(x), cy: new SVGNumber(y) })
    : this.attr({ x2: new SVGNumber(x), y2: new SVGNumber(y) })
}

var gradiented = /*#__PURE__*/Object.freeze({
  __proto__: null,
  from: from,
  to: to
});

class Gradient extends Container {
  constructor (type, attrs) {
    super(
      nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type),
      attrs
    );
  }

  // custom attr to handle transform
  attr (a, b, c) {
    if (a === 'transform') a = 'gradientTransform';
    return super.attr(a, b, c)
  }

  bbox () {
    return new Box()
  }

  targets () {
    return baseFind('svg [fill*="' + this.id() + '"]')
  }

  // Alias string conversion to fill
  toString () {
    return this.url()
  }

  // Update gradient
  update (block) {
    // remove all stops
    this.clear();

    // invoke passed block
    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this
  }

  // Return the fill id
  url () {
    return 'url("#' + this.id() + '")'
  }
}

extend(Gradient, gradiented);

registerMethods({
  Container: {
    // Create gradient element in defs
    gradient (...args) {
      return this.defs().gradient(...args)
    }
  },
  // define gradient
  Defs: {
    gradient: wrapWithAttrCheck(function (type, block) {
      return this.put(new Gradient(type)).update(block)
    })
  }
});

register(Gradient, 'Gradient');

class Pattern extends Container {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('pattern', node), attrs);
  }

  // custom attr to handle transform
  attr (a, b, c) {
    if (a === 'transform') a = 'patternTransform';
    return super.attr(a, b, c)
  }

  bbox () {
    return new Box()
  }

  targets () {
    return baseFind('svg [fill*="' + this.id() + '"]')
  }

  // Alias string conversion to fill
  toString () {
    return this.url()
  }

  // Update pattern by rebuilding
  update (block) {
    // remove content
    this.clear();

    // invoke passed block
    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this
  }

  // Return the fill id
  url () {
    return 'url("#' + this.id() + '")'
  }

}

registerMethods({
  Container: {
    // Create pattern element in defs
    pattern (...args) {
      return this.defs().pattern(...args)
    }
  },
  Defs: {
    pattern: wrapWithAttrCheck(function (width, height, block) {
      return this.put(new Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width,
        height: height,
        patternUnits: 'userSpaceOnUse'
      })
    })
  }
});

register(Pattern, 'Pattern');

class Image$1 extends Shape {
  constructor (node, attrs = node) {
    super(nodeOrNew('image', node), attrs);
  }

  // (re)load image
  load (url, callback) {
    if (!url) return this

    const img = new globals.window.Image();

    on(img, 'load', function (e) {
      const p = this.parent(Pattern);

      // ensure image size
      if (this.width() === 0 && this.height() === 0) {
        this.size(img.width, img.height);
      }

      if (p instanceof Pattern) {
        // ensure pattern size if not set
        if (p.width() === 0 && p.height() === 0) {
          p.size(this.width(), this.height());
        }
      }

      if (typeof callback === 'function') {
        callback.call(this, e);
      }
    }, this);

    on(img, 'load error', function () {
      // dont forget to unbind memory leaking events
      off(img);
    });

    return this.attr('href', (img.src = url), xlink)
  }
}

registerAttrHook(function (attr, val, _this) {
  // convert image fill and stroke to patterns
  if (attr === 'fill' || attr === 'stroke') {
    if (isImage.test(val)) {
      val = _this.root().defs().image(val);
    }
  }

  if (val instanceof Image$1) {
    val = _this.root().defs().pattern(0, 0, (pattern) => {
      pattern.add(val);
    });
  }

  return val
});

registerMethods({
  Container: {
    // create image element, load image and set its size
    image: wrapWithAttrCheck(function (source, callback) {
      return this.put(new Image$1()).size(0, 0).load(source, callback)
    })
  }
});

register(Image$1, 'Image');

class PointArray extends SVGArray {
  // Get bounding box of points
  bbox () {
    let maxX = -Infinity;
    let maxY = -Infinity;
    let minX = Infinity;
    let minY = Infinity;
    this.forEach(function (el) {
      maxX = Math.max(el[0], maxX);
      maxY = Math.max(el[1], maxY);
      minX = Math.min(el[0], minX);
      minY = Math.min(el[1], minY);
    });
    return new Box(minX, minY, maxX - minX, maxY - minY)
  }

  // Move point string
  move (x, y) {
    const box = this.bbox();

    // get relative offset
    x -= box.x;
    y -= box.y;

    // move every point
    if (!isNaN(x) && !isNaN(y)) {
      for (let i = this.length - 1; i >= 0; i--) {
        this[i] = [ this[i][0] + x, this[i][1] + y ];
      }
    }

    return this
  }

  // Parse point string and flat array
  parse (array = [ 0, 0 ]) {
    const points = [];

    // if it is an array, we flatten it and therefore clone it to 1 depths
    if (array instanceof Array) {
      array = Array.prototype.concat.apply([], array);
    } else { // Else, it is considered as a string
      // parse points
      array = array.trim().split(delimiter).map(parseFloat);
    }

    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.
    if (array.length % 2 !== 0) array.pop();

    // wrap points in two-tuples
    for (let i = 0, len = array.length; i < len; i = i + 2) {
      points.push([ array[i], array[i + 1] ]);
    }

    return points
  }

  // Resize poly string
  size (width, height) {
    let i;
    const box = this.bbox();

    // recalculate position of all points according to new size
    for (i = this.length - 1; i >= 0; i--) {
      if (box.width) this[i][0] = ((this[i][0] - box.x) * width) / box.width + box.x;
      if (box.height) this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y;
    }

    return this
  }

  // Convert array to line object
  toLine () {
    return {
      x1: this[0][0],
      y1: this[0][1],
      x2: this[1][0],
      y2: this[1][1]
    }
  }

  // Convert array to string
  toString () {
    const array = [];
    // convert to a poly point string
    for (let i = 0, il = this.length; i < il; i++) {
      array.push(this[i].join(','));
    }

    return array.join(' ')
  }

  transform (m) {
    return this.clone().transformO(m)
  }

  // transform points with matrix (similar to Point.transform)
  transformO (m) {
    if (!Matrix.isMatrixLike(m)) {
      m = new Matrix(m);
    }

    for (let i = this.length; i--;) {
      // Perform the matrix multiplication
      const [ x, y ] = this[i];
      this[i][0] = m.a * x + m.c * y + m.e;
      this[i][1] = m.b * x + m.d * y + m.f;
    }

    return this
  }

}

const MorphArray = PointArray;

// Move by left top corner over x-axis
function x$2 (x) {
  return x == null ? this.bbox().x : this.move(x, this.bbox().y)
}

// Move by left top corner over y-axis
function y$2 (y) {
  return y == null ? this.bbox().y : this.move(this.bbox().x, y)
}

// Set width of element
function width$1 (width) {
  const b = this.bbox();
  return width == null ? b.width : this.size(width, b.height)
}

// Set height of element
function height$1 (height) {
  const b = this.bbox();
  return height == null ? b.height : this.size(b.width, height)
}

var pointed = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MorphArray: MorphArray,
  x: x$2,
  y: y$2,
  width: width$1,
  height: height$1
});

class Line extends Shape {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('line', node), attrs);
  }

  // Get array
  array () {
    return new PointArray([
      [ this.attr('x1'), this.attr('y1') ],
      [ this.attr('x2'), this.attr('y2') ]
    ])
  }

  // Move by left top corner
  move (x, y) {
    return this.attr(this.array().move(x, y).toLine())
  }

  // Overwrite native plot() method
  plot (x1, y1, x2, y2) {
    if (x1 == null) {
      return this.array()
    } else if (typeof y1 !== 'undefined') {
      x1 = { x1, y1, x2, y2 };
    } else {
      x1 = new PointArray(x1).toLine();
    }

    return this.attr(x1)
  }

  // Set element size to given width and height
  size (width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr(this.array().size(p.width, p.height).toLine())
  }
}

extend(Line, pointed);

registerMethods({
  Container: {
    // Create a line element
    line: wrapWithAttrCheck(function (...args) {
      // make sure plot is called as a setter
      // x1 is not necessarily a number, it can also be an array, a string and a PointArray
      return Line.prototype.plot.apply(
        this.put(new Line())
        , args[0] != null ? args : [ 0, 0, 0, 0 ]
      )
    })
  }
});

register(Line, 'Line');

class Marker extends Container {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('marker', node), attrs);
  }

  // Set height of element
  height (height) {
    return this.attr('markerHeight', height)
  }

  orient (orient) {
    return this.attr('orient', orient)
  }

  // Set marker refX and refY
  ref (x, y) {
    return this.attr('refX', x).attr('refY', y)
  }

  // Return the fill id
  toString () {
    return 'url(#' + this.id() + ')'
  }

  // Update marker
  update (block) {
    // remove all content
    this.clear();

    // invoke passed block
    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this
  }

  // Set width of element
  width (width) {
    return this.attr('markerWidth', width)
  }

}

registerMethods({
  Container: {
    marker (...args) {
      // Create marker element in defs
      return this.defs().marker(...args)
    }
  },
  Defs: {
    // Create marker
    marker: wrapWithAttrCheck(function (width, height, block) {
      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
      return this.put(new Marker())
        .size(width, height)
        .ref(width / 2, height / 2)
        .viewbox(0, 0, width, height)
        .attr('orient', 'auto')
        .update(block)
    })
  },
  marker: {
    // Create and attach markers
    marker (marker, width, height, block) {
      let attr = [ 'marker' ];

      // Build attribute name
      if (marker !== 'all') attr.push(marker);
      attr = attr.join('-');

      // Set marker attribute
      marker = arguments[1] instanceof Marker
        ? arguments[1]
        : this.defs().marker(width, height, block);

      return this.attr(attr, marker)
    }
  }
});

register(Marker, 'Marker');

/***
Base Class
==========
The base stepper class that will be
***/

function makeSetterGetter (k, f) {
  return function (v) {
    if (v == null) return this[k]
    this[k] = v;
    if (f) f.call(this);
    return this
  }
}

const easing = {
  '-': function (pos) {
    return pos
  },
  '<>': function (pos) {
    return -Math.cos(pos * Math.PI) / 2 + 0.5
  },
  '>': function (pos) {
    return Math.sin(pos * Math.PI / 2)
  },
  '<': function (pos) {
    return -Math.cos(pos * Math.PI / 2) + 1
  },
  bezier: function (x1, y1, x2, y2) {
    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
    return function (t) {
      if (t < 0) {
        if (x1 > 0) {
          return y1 / x1 * t
        } else if (x2 > 0) {
          return y2 / x2 * t
        } else {
          return 0
        }
      } else if (t > 1) {
        if (x2 < 1) {
          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2)
        } else if (x1 < 1) {
          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1)
        } else {
          return 1
        }
      } else {
        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3
      }
    }
  },
  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
  steps: function (steps, stepPosition = 'end') {
    // deal with "jump-" prefix
    stepPosition = stepPosition.split('-').reverse()[0];

    let jumps = steps;
    if (stepPosition === 'none') {
      --jumps;
    } else if (stepPosition === 'both') {
      ++jumps;
    }

    // The beforeFlag is essentially useless
    return (t, beforeFlag = false) => {
      // Step is called currentStep in referenced url
      let step = Math.floor(t * steps);
      const jumping = (t * step) % 1 === 0;

      if (stepPosition === 'start' || stepPosition === 'both') {
        ++step;
      }

      if (beforeFlag && jumping) {
        --step;
      }

      if (t >= 0 && step < 0) {
        step = 0;
      }

      if (t <= 1 && step > jumps) {
        step = jumps;
      }

      return step / jumps
    }
  }
};

class Stepper {
  done () {
    return false
  }
}

/***
Easing Functions
================
***/

class Ease extends Stepper {
  constructor (fn = timeline.ease) {
    super();
    this.ease = easing[fn] || fn;
  }

  step (from, to, pos) {
    if (typeof from !== 'number') {
      return pos < 1 ? from : to
    }
    return from + (to - from) * this.ease(pos)
  }
}

/***
Controller Types
================
***/

class Controller extends Stepper {
  constructor (fn) {
    super();
    this.stepper = fn;
  }

  done (c) {
    return c.done
  }

  step (current, target, dt, c) {
    return this.stepper(current, target, dt, c)
  }

}

function recalculate () {
  // Apply the default parameters
  const duration = (this._duration || 500) / 1000;
  const overshoot = this._overshoot || 0;

  // Calculate the PID natural response
  const eps = 1e-10;
  const pi = Math.PI;
  const os = Math.log(overshoot / 100 + eps);
  const zeta = -os / Math.sqrt(pi * pi + os * os);
  const wn = 3.9 / (zeta * duration);

  // Calculate the Spring values
  this.d = 2 * zeta * wn;
  this.k = wn * wn;
}

class Spring extends Controller {
  constructor (duration = 500, overshoot = 0) {
    super();
    this.duration(duration)
      .overshoot(overshoot);
  }

  step (current, target, dt, c) {
    if (typeof current === 'string') return current
    c.done = dt === Infinity;
    if (dt === Infinity) return target
    if (dt === 0) return current

    if (dt > 100) dt = 16;

    dt /= 1000;

    // Get the previous velocity
    const velocity = c.velocity || 0;

    // Apply the control to get the new position and store it
    const acceleration = -this.d * velocity - this.k * (current - target);
    const newPosition = current
      + velocity * dt
      + acceleration * dt * dt / 2;

    // Store the velocity
    c.velocity = velocity + acceleration * dt;

    // Figure out if we have converged, and if so, pass the value
    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
    return c.done ? target : newPosition
  }
}

extend(Spring, {
  duration: makeSetterGetter('_duration', recalculate),
  overshoot: makeSetterGetter('_overshoot', recalculate)
});

class PID extends Controller {
  constructor (p = 0.1, i = 0.01, d = 0, windup = 1000) {
    super();
    this.p(p).i(i).d(d).windup(windup);
  }

  step (current, target, dt, c) {
    if (typeof current === 'string') return current
    c.done = dt === Infinity;

    if (dt === Infinity) return target
    if (dt === 0) return current

    const p = target - current;
    let i = (c.integral || 0) + p * dt;
    const d = (p - (c.error || 0)) / dt;
    const windup = this._windup;

    // antiwindup
    if (windup !== false) {
      i = Math.max(-windup, Math.min(i, windup));
    }

    c.error = p;
    c.integral = i;

    c.done = Math.abs(p) < 0.001;

    return c.done ? target : current + (this.P * p + this.I * i + this.D * d)
  }
}

extend(PID, {
  windup: makeSetterGetter('_windup'),
  p: makeSetterGetter('P'),
  i: makeSetterGetter('I'),
  d: makeSetterGetter('D')
});

const segmentParameters = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };

const pathHandlers = {
  M: function (c, p, p0) {
    p.x = p0.x = c[0];
    p.y = p0.y = c[1];

    return [ 'M', p.x, p.y ]
  },
  L: function (c, p) {
    p.x = c[0];
    p.y = c[1];
    return [ 'L', c[0], c[1] ]
  },
  H: function (c, p) {
    p.x = c[0];
    return [ 'H', c[0] ]
  },
  V: function (c, p) {
    p.y = c[0];
    return [ 'V', c[0] ]
  },
  C: function (c, p) {
    p.x = c[4];
    p.y = c[5];
    return [ 'C', c[0], c[1], c[2], c[3], c[4], c[5] ]
  },
  S: function (c, p) {
    p.x = c[2];
    p.y = c[3];
    return [ 'S', c[0], c[1], c[2], c[3] ]
  },
  Q: function (c, p) {
    p.x = c[2];
    p.y = c[3];
    return [ 'Q', c[0], c[1], c[2], c[3] ]
  },
  T: function (c, p) {
    p.x = c[0];
    p.y = c[1];
    return [ 'T', c[0], c[1] ]
  },
  Z: function (c, p, p0) {
    p.x = p0.x;
    p.y = p0.y;
    return [ 'Z' ]
  },
  A: function (c, p) {
    p.x = c[5];
    p.y = c[6];
    return [ 'A', c[0], c[1], c[2], c[3], c[4], c[5], c[6] ]
  }
};

const mlhvqtcsaz = 'mlhvqtcsaz'.split('');

for (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
  pathHandlers[mlhvqtcsaz[i]] = (function (i) {
    return function (c, p, p0) {
      if (i === 'H') c[0] = c[0] + p.x;
      else if (i === 'V') c[0] = c[0] + p.y;
      else if (i === 'A') {
        c[5] = c[5] + p.x;
        c[6] = c[6] + p.y;
      } else {
        for (let j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x);
        }
      }

      return pathHandlers[i](c, p, p0)
    }
  })(mlhvqtcsaz[i].toUpperCase());
}

function makeAbsolut (parser) {
  const command = parser.segment[0];
  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0)
}

function segmentComplete (parser) {
  return parser.segment.length && parser.segment.length - 1 === segmentParameters[parser.segment[0].toUpperCase()]
}

function startNewSegment (parser, token) {
  parser.inNumber && finalizeNumber(parser, false);
  const pathLetter = isPathLetter.test(token);

  if (pathLetter) {
    parser.segment = [ token ];
  } else {
    const lastCommand = parser.lastCommand;
    const small = lastCommand.toLowerCase();
    const isSmall = lastCommand === small;
    parser.segment = [ small === 'm' ? (isSmall ? 'l' : 'L') : lastCommand ];
  }

  parser.inSegment = true;
  parser.lastCommand = parser.segment[0];

  return pathLetter
}

function finalizeNumber (parser, inNumber) {
  if (!parser.inNumber) throw new Error('Parser Error')
  parser.number && parser.segment.push(parseFloat(parser.number));
  parser.inNumber = inNumber;
  parser.number = '';
  parser.pointSeen = false;
  parser.hasExponent = false;

  if (segmentComplete(parser)) {
    finalizeSegment(parser);
  }
}

function finalizeSegment (parser) {
  parser.inSegment = false;
  if (parser.absolute) {
    parser.segment = makeAbsolut(parser);
  }
  parser.segments.push(parser.segment);
}

function isArcFlag (parser) {
  if (!parser.segment.length) return false
  const isArc = parser.segment[0].toUpperCase() === 'A';
  const length = parser.segment.length;

  return isArc && (length === 4 || length === 5)
}

function isExponential (parser) {
  return parser.lastToken.toUpperCase() === 'E'
}

function pathParser (d, toAbsolute = true) {

  let index = 0;
  let token = '';
  const parser = {
    segment: [],
    inNumber: false,
    number: '',
    lastToken: '',
    inSegment: false,
    segments: [],
    pointSeen: false,
    hasExponent: false,
    absolute: toAbsolute,
    p0: new Point(),
    p: new Point()
  };

  while ((parser.lastToken = token, token = d.charAt(index++))) {
    if (!parser.inSegment) {
      if (startNewSegment(parser, token)) {
        continue
      }
    }

    if (token === '.') {
      if (parser.pointSeen || parser.hasExponent) {
        finalizeNumber(parser, false);
        --index;
        continue
      }
      parser.inNumber = true;
      parser.pointSeen = true;
      parser.number += token;
      continue
    }

    if (!isNaN(parseInt(token))) {

      if (parser.number === '0' || isArcFlag(parser)) {
        parser.inNumber = true;
        parser.number = token;
        finalizeNumber(parser, true);
        continue
      }

      parser.inNumber = true;
      parser.number += token;
      continue
    }

    if (token === ' ' || token === ',') {
      if (parser.inNumber) {
        finalizeNumber(parser, false);
      }
      continue
    }

    if (token === '-') {
      if (parser.inNumber && !isExponential(parser)) {
        finalizeNumber(parser, false);
        --index;
        continue
      }
      parser.number += token;
      parser.inNumber = true;
      continue
    }

    if (token.toUpperCase() === 'E') {
      parser.number += token;
      parser.hasExponent = true;
      continue
    }

    if (isPathLetter.test(token)) {
      if (parser.inNumber) {
        finalizeNumber(parser, false);
      } else if (!segmentComplete(parser)) {
        throw new Error('parser Error')
      } else {
        finalizeSegment(parser);
      }
      --index;
    }
  }

  if (parser.inNumber) {
    finalizeNumber(parser, false);
  }

  if (parser.inSegment && segmentComplete(parser)) {
    finalizeSegment(parser);
  }

  return parser.segments

}

function arrayToString (a) {
  let s = '';
  for (let i = 0, il = a.length; i < il; i++) {
    s += a[i][0];

    if (a[i][1] != null) {
      s += a[i][1];

      if (a[i][2] != null) {
        s += ' ';
        s += a[i][2];

        if (a[i][3] != null) {
          s += ' ';
          s += a[i][3];
          s += ' ';
          s += a[i][4];

          if (a[i][5] != null) {
            s += ' ';
            s += a[i][5];
            s += ' ';
            s += a[i][6];

            if (a[i][7] != null) {
              s += ' ';
              s += a[i][7];
            }
          }
        }
      }
    }
  }

  return s + ' '
}

class PathArray extends SVGArray {
  // Get bounding box of path
  bbox () {
    parser().path.setAttribute('d', this.toString());
    return new Box(parser.nodes.path.getBBox())
  }

  // Move path string
  move (x, y) {
    // get bounding box of current situation
    const box = this.bbox();

    // get relative offset
    x -= box.x;
    y -= box.y;

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (let l, i = this.length - 1; i >= 0; i--) {
        l = this[i][0];

        if (l === 'M' || l === 'L' || l === 'T') {
          this[i][1] += x;
          this[i][2] += y;
        } else if (l === 'H') {
          this[i][1] += x;
        } else if (l === 'V') {
          this[i][1] += y;
        } else if (l === 'C' || l === 'S' || l === 'Q') {
          this[i][1] += x;
          this[i][2] += y;
          this[i][3] += x;
          this[i][4] += y;

          if (l === 'C') {
            this[i][5] += x;
            this[i][6] += y;
          }
        } else if (l === 'A') {
          this[i][6] += x;
          this[i][7] += y;
        }
      }
    }

    return this
  }

  // Absolutize and parse path to array
  parse (d = 'M0 0') {
    if (Array.isArray(d)) {
      d = Array.prototype.concat.apply([], d).toString();
    }

    return pathParser(d)
  }

  // Resize path string
  size (width, height) {
    // get bounding box of current situation
    const box = this.bbox();
    let i, l;

    // If the box width or height is 0 then we ignore
    // transformations on the respective axis
    box.width = box.width === 0 ? 1 : box.width;
    box.height = box.height === 0 ? 1 : box.height;

    // recalculate position of all points according to new size
    for (i = this.length - 1; i >= 0; i--) {
      l = this[i][0];

      if (l === 'M' || l === 'L' || l === 'T') {
        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y;
      } else if (l === 'H') {
        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
      } else if (l === 'V') {
        this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y;
      } else if (l === 'C' || l === 'S' || l === 'Q') {
        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y;
        this[i][3] = ((this[i][3] - box.x) * width) / box.width + box.x;
        this[i][4] = ((this[i][4] - box.y) * height) / box.height + box.y;

        if (l === 'C') {
          this[i][5] = ((this[i][5] - box.x) * width) / box.width + box.x;
          this[i][6] = ((this[i][6] - box.y) * height) / box.height + box.y;
        }
      } else if (l === 'A') {
        // resize radii
        this[i][1] = (this[i][1] * width) / box.width;
        this[i][2] = (this[i][2] * height) / box.height;

        // move position values
        this[i][6] = ((this[i][6] - box.x) * width) / box.width + box.x;
        this[i][7] = ((this[i][7] - box.y) * height) / box.height + box.y;
      }
    }

    return this
  }

  // Convert array to string
  toString () {
    return arrayToString(this)
  }

}

const getClassForType = (value) => {
  const type = typeof value;

  if (type === 'number') {
    return SVGNumber
  } else if (type === 'string') {
    if (Color.isColor(value)) {
      return Color
    } else if (delimiter.test(value)) {
      return isPathLetter.test(value)
        ? PathArray
        : SVGArray
    } else if (numberAndUnit.test(value)) {
      return SVGNumber
    } else {
      return NonMorphable
    }
  } else if (morphableTypes.indexOf(value.constructor) > -1) {
    return value.constructor
  } else if (Array.isArray(value)) {
    return SVGArray
  } else if (type === 'object') {
    return ObjectBag
  } else {
    return NonMorphable
  }
};

class Morphable {
  constructor (stepper) {
    this._stepper = stepper || new Ease('-');

    this._from = null;
    this._to = null;
    this._type = null;
    this._context = null;
    this._morphObj = null;
  }

  at (pos) {
    return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context)

  }

  done () {
    const complete = this._context
      .map(this._stepper.done)
      .reduce(function (last, curr) {
        return last && curr
      }, true);
    return complete
  }

  from (val) {
    if (val == null) {
      return this._from
    }

    this._from = this._set(val);
    return this
  }

  stepper (stepper) {
    if (stepper == null) return this._stepper
    this._stepper = stepper;
    return this
  }

  to (val) {
    if (val == null) {
      return this._to
    }

    this._to = this._set(val);
    return this
  }

  type (type) {
    // getter
    if (type == null) {
      return this._type
    }

    // setter
    this._type = type;
    return this
  }

  _set (value) {
    if (!this._type) {
      this.type(getClassForType(value));
    }

    let result = (new this._type(value));
    if (this._type === Color) {
      result = this._to
        ? result[this._to[4]]()
        : this._from
          ? result[this._from[4]]()
          : result;
    }

    if (this._type === ObjectBag) {
      result = this._to
        ? result.align(this._to)
        : this._from
          ? result.align(this._from)
          : result;
    }

    result = result.toConsumable();

    this._morphObj = this._morphObj || new this._type();
    this._context = this._context
      || Array.apply(null, Array(result.length))
        .map(Object)
        .map(function (o) {
          o.done = true;
          return o
        });
    return result
  }

}

class NonMorphable {
  constructor (...args) {
    this.init(...args);
  }

  init (val) {
    val = Array.isArray(val) ? val[0] : val;
    this.value = val;
    return this
  }

  toArray () {
    return [ this.value ]
  }

  valueOf () {
    return this.value
  }

}

class TransformBag {
  constructor (...args) {
    this.init(...args);
  }

  init (obj) {
    if (Array.isArray(obj)) {
      obj = {
        scaleX: obj[0],
        scaleY: obj[1],
        shear: obj[2],
        rotate: obj[3],
        translateX: obj[4],
        translateY: obj[5],
        originX: obj[6],
        originY: obj[7]
      };
    }

    Object.assign(this, TransformBag.defaults, obj);
    return this
  }

  toArray () {
    const v = this;

    return [
      v.scaleX,
      v.scaleY,
      v.shear,
      v.rotate,
      v.translateX,
      v.translateY,
      v.originX,
      v.originY
    ]
  }
}

TransformBag.defaults = {
  scaleX: 1,
  scaleY: 1,
  shear: 0,
  rotate: 0,
  translateX: 0,
  translateY: 0,
  originX: 0,
  originY: 0
};

const sortByKey = (a, b) => {
  return (a[0] < b[0] ? -1 : (a[0] > b[0] ? 1 : 0))
};

class ObjectBag {
  constructor (...args) {
    this.init(...args);
  }

  align (other) {
    const values = this.values;
    for (let i = 0, il = values.length; i < il; ++i) {

      // If the type is the same we only need to check if the color is in the correct format
      if (values[i + 1] === other[i + 1]) {
        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {
          const space = other[i + 7];
          const color = new Color(this.values.splice(i + 3, 5))[space]().toArray();
          this.values.splice(i + 3, 0, ...color);
        }

        i += values[i + 2] + 2;
        continue
      }

      if (!other[i + 1]) {
        return this
      }

      // The types differ, so we overwrite the new type with the old one
      // And initialize it with the types default (e.g. black for color or 0 for number)
      const defaultObject = new (other[i + 1])().toArray();

      // Than we fix the values array
      const toDelete = (values[i + 2]) + 3;

      values.splice(i, toDelete, other[i], other[i + 1], other[i + 2], ...defaultObject);

      i += values[i + 2] + 2;
    }
    return this
  }

  init (objOrArr) {
    this.values = [];

    if (Array.isArray(objOrArr)) {
      this.values = objOrArr.slice();
      return
    }

    objOrArr = objOrArr || {};
    const entries = [];

    for (const i in objOrArr) {
      const Type = getClassForType(objOrArr[i]);
      const val = new Type(objOrArr[i]).toArray();
      entries.push([ i, Type, val.length, ...val ]);
    }

    entries.sort(sortByKey);

    this.values = entries.reduce((last, curr) => last.concat(curr), []);
    return this
  }

  toArray () {
    return this.values
  }

  valueOf () {
    const obj = {};
    const arr = this.values;

    // for (var i = 0, len = arr.length; i < len; i += 2) {
    while (arr.length) {
      const key = arr.shift();
      const Type = arr.shift();
      const num = arr.shift();
      const values = arr.splice(0, num);
      obj[key] = new Type(values);// .valueOf()
    }

    return obj
  }

}

const morphableTypes = [
  NonMorphable,
  TransformBag,
  ObjectBag
];

function registerMorphableType (type = []) {
  morphableTypes.push(...[].concat(type));
}

function makeMorphable () {
  extend(morphableTypes, {
    to (val) {
      return new Morphable()
        .type(this.constructor)
        .from(this.toArray())// this.valueOf())
        .to(val)
    },
    fromArray (arr) {
      this.init(arr);
      return this
    },
    toConsumable () {
      return this.toArray()
    },
    morph (from, to, pos, stepper, context) {
      const mapper = function (i, index) {
        return stepper.step(i, to[index], pos, context[index], context)
      };

      return this.fromArray(from.map(mapper))
    }
  });
}

class Path extends Shape {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('path', node), attrs);
  }

  // Get array
  array () {
    return this._array || (this._array = new PathArray(this.attr('d')))
  }

  // Clear array cache
  clear () {
    delete this._array;
    return this
  }

  // Set height of element
  height (height) {
    return height == null ? this.bbox().height : this.size(this.bbox().width, height)
  }

  // Move by left top corner
  move (x, y) {
    return this.attr('d', this.array().move(x, y))
  }

  // Plot new path
  plot (d) {
    return (d == null)
      ? this.array()
      : this.clear().attr('d', typeof d === 'string' ? d : (this._array = new PathArray(d)))
  }

  // Set element size to given width and height
  size (width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr('d', this.array().size(p.width, p.height))
  }

  // Set width of element
  width (width) {
    return width == null ? this.bbox().width : this.size(width, this.bbox().height)
  }

  // Move by left top corner over x-axis
  x (x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y)
  }

  // Move by left top corner over y-axis
  y (y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y)
  }

}

// Define morphable array
Path.prototype.MorphArray = PathArray;

// Add parent method
registerMethods({
  Container: {
    // Create a wrapped path element
    path: wrapWithAttrCheck(function (d) {
      // make sure plot is called as a setter
      return this.put(new Path()).plot(d || new PathArray())
    })
  }
});

register(Path, 'Path');

// Get array
function array () {
  return this._array || (this._array = new PointArray(this.attr('points')))
}

// Clear array cache
function clear () {
  delete this._array;
  return this
}

// Move by left top corner
function move$2 (x, y) {
  return this.attr('points', this.array().move(x, y))
}

// Plot new path
function plot (p) {
  return (p == null)
    ? this.array()
    : this.clear().attr('points', typeof p === 'string'
      ? p
      : (this._array = new PointArray(p)))
}

// Set element size to given width and height
function size$1 (width, height) {
  const p = proportionalSize(this, width, height);
  return this.attr('points', this.array().size(p.width, p.height))
}

var poly = /*#__PURE__*/Object.freeze({
  __proto__: null,
  array: array,
  clear: clear,
  move: move$2,
  plot: plot,
  size: size$1
});

class Polygon extends Shape {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('polygon', node), attrs);
  }
}

registerMethods({
  Container: {
    // Create a wrapped polygon element
    polygon: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polygon()).plot(p || new PointArray())
    })
  }
});

extend(Polygon, pointed);
extend(Polygon, poly);
register(Polygon, 'Polygon');

class Polyline extends Shape {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('polyline', node), attrs);
  }
}

registerMethods({
  Container: {
    // Create a wrapped polygon element
    polyline: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polyline()).plot(p || new PointArray())
    })
  }
});

extend(Polyline, pointed);
extend(Polyline, poly);
register(Polyline, 'Polyline');

class Rect extends Shape {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('rect', node), attrs);
  }
}

extend(Rect, { rx, ry });

registerMethods({
  Container: {
    // Create a rect element
    rect: wrapWithAttrCheck(function (width, height) {
      return this.put(new Rect()).size(width, height)
    })
  }
});

register(Rect, 'Rect');

class Queue {
  constructor () {
    this._first = null;
    this._last = null;
  }

  // Shows us the first item in the list
  first () {
    return this._first && this._first.value
  }

  // Shows us the last item in the list
  last () {
    return this._last && this._last.value
  }

  push (value) {
    // An item stores an id and the provided value
    const item = typeof value.next !== 'undefined' ? value : { value: value, next: null, prev: null };

    // Deal with the queue being empty or populated
    if (this._last) {
      item.prev = this._last;
      this._last.next = item;
      this._last = item;
    } else {
      this._last = item;
      this._first = item;
    }

    // Return the current item
    return item
  }

  // Removes the item that was returned from the push
  remove (item) {
    // Relink the previous item
    if (item.prev) item.prev.next = item.next;
    if (item.next) item.next.prev = item.prev;
    if (item === this._last) this._last = item.prev;
    if (item === this._first) this._first = item.next;

    // Invalidate item
    item.prev = null;
    item.next = null;
  }

  shift () {
    // Check if we have a value
    const remove = this._first;
    if (!remove) return null

    // If we do, remove it and relink things
    this._first = remove.next;
    if (this._first) this._first.prev = null;
    this._last = this._first ? this._last : null;
    return remove.value
  }

}

const Animator = {
  nextDraw: null,
  frames: new Queue(),
  timeouts: new Queue(),
  immediates: new Queue(),
  timer: () => globals.window.performance || globals.window.Date,
  transforms: [],

  frame (fn) {
    // Store the node
    const node = Animator.frames.push({ run: fn });

    // Request an animation frame if we don't have one
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    // Return the node so we can remove it easily
    return node
  },

  timeout (fn, delay) {
    delay = delay || 0;

    // Work out when the event should fire
    const time = Animator.timer().now() + delay;

    // Add the timeout to the end of the queue
    const node = Animator.timeouts.push({ run: fn, time: time });

    // Request another animation frame if we need one
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node
  },

  immediate (fn) {
    // Add the immediate fn to the end of the queue
    const node = Animator.immediates.push(fn);
    // Request another animation frame if we need one
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node
  },

  cancelFrame (node) {
    node != null && Animator.frames.remove(node);
  },

  clearTimeout (node) {
    node != null && Animator.timeouts.remove(node);
  },

  cancelImmediate (node) {
    node != null && Animator.immediates.remove(node);
  },

  _draw (now) {
    // Run all the timeouts we can run, if they are not ready yet, add them
    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
    let nextTimeout = null;
    const lastTimeout = Animator.timeouts.last();
    while ((nextTimeout = Animator.timeouts.shift())) {
      // Run the timeout if its time, or push it to the end
      if (now >= nextTimeout.time) {
        nextTimeout.run();
      } else {
        Animator.timeouts.push(nextTimeout);
      }

      // If we hit the last item, we should stop shifting out more items
      if (nextTimeout === lastTimeout) break
    }

    // Run all of the animation frames
    let nextFrame = null;
    const lastFrame = Animator.frames.last();
    while ((nextFrame !== lastFrame) && (nextFrame = Animator.frames.shift())) {
      nextFrame.run(now);
    }

    let nextImmediate = null;
    while ((nextImmediate = Animator.immediates.shift())) {
      nextImmediate();
    }

    // If we have remaining timeouts or frames, draw until we don't anymore
    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first()
      ? globals.window.requestAnimationFrame(Animator._draw)
      : null;
  }
};

const makeSchedule = function (runnerInfo) {
  const start = runnerInfo.start;
  const duration = runnerInfo.runner.duration();
  const end = start + duration;
  return { start: start, duration: duration, end: end, runner: runnerInfo.runner }
};

const defaultSource = function () {
  const w = globals.window;
  return (w.performance || w.Date).now()
};

class Timeline extends EventTarget {
  // Construct a new timeline on the given element
  constructor (timeSource = defaultSource) {
    super();

    this._timeSource = timeSource;

    // Store the timing variables
    this._startTime = 0;
    this._speed = 1.0;

    // Determines how long a runner is hold in memory. Can be a dt or true/false
    this._persist = 0;

    // Keep track of the running animations and their starting parameters
    this._nextFrame = null;
    this._paused = true;
    this._runners = [];
    this._runnerIds = [];
    this._lastRunnerId = -1;
    this._time = 0;
    this._lastSourceTime = 0;
    this._lastStepTime = 0;

    // Make sure that step is always called in class context
    this._step = this._stepFn.bind(this, false);
    this._stepImmediate = this._stepFn.bind(this, true);
  }

  active () {
    return !!this._nextFrame
  }

  finish () {
    // Go to end and pause
    this.time(this.getEndTimeOfTimeline() + 1);
    return this.pause()
  }

  // Calculates the end of the timeline
  getEndTime () {
    const lastRunnerInfo = this.getLastRunnerInfo();
    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
    return lastStartTime + lastDuration
  }

  getEndTimeOfTimeline () {
    const endTimes = this._runners.map((i) => i.start + i.runner.duration());
    return Math.max(0, ...endTimes)
  }

  getLastRunnerInfo () {
    return this.getRunnerInfoById(this._lastRunnerId)
  }

  getRunnerInfoById (id) {
    return this._runners[this._runnerIds.indexOf(id)] || null
  }

  pause () {
    this._paused = true;
    return this._continue()
  }

  persist (dtOrForever) {
    if (dtOrForever == null) return this._persist
    this._persist = dtOrForever;
    return this
  }

  play () {
    // Now make sure we are not paused and continue the animation
    this._paused = false;
    return this.updateTime()._continue()
  }

  reverse (yes) {
    const currentSpeed = this.speed();
    if (yes == null) return this.speed(-currentSpeed)

    const positive = Math.abs(currentSpeed);
    return this.speed(yes ? -positive : positive)
  }

  // schedules a runner on the timeline
  schedule (runner, delay, when) {
    if (runner == null) {
      return this._runners.map(makeSchedule)
    }

    // The start time for the next animation can either be given explicitly,
    // derived from the current timeline time or it can be relative to the
    // last start time to chain animations directly

    let absoluteStartTime = 0;
    const endTime = this.getEndTime();
    delay = delay || 0;

    // Work out when to start the animation
    if (when == null || when === 'last' || when === 'after') {
      // Take the last time and increment
      absoluteStartTime = endTime;
    } else if (when === 'absolute' || when === 'start') {
      absoluteStartTime = delay;
      delay = 0;
    } else if (when === 'now') {
      absoluteStartTime = this._time;
    } else if (when === 'relative') {
      const runnerInfo = this.getRunnerInfoById(runner.id);
      if (runnerInfo) {
        absoluteStartTime = runnerInfo.start + delay;
        delay = 0;
      }
    } else if (when === 'with-last') {
      const lastRunnerInfo = this.getLastRunnerInfo();
      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
      absoluteStartTime = lastStartTime;
    } else {
      throw new Error('Invalid value for the "when" parameter')
    }

    // Manage runner
    runner.unschedule();
    runner.timeline(this);

    const persist = runner.persist();
    const runnerInfo = {
      persist: persist === null ? this._persist : persist,
      start: absoluteStartTime + delay,
      runner
    };

    this._lastRunnerId = runner.id;

    this._runners.push(runnerInfo);
    this._runners.sort((a, b) => a.start - b.start);
    this._runnerIds = this._runners.map(info => info.runner.id);

    this.updateTime()._continue();
    return this
  }

  seek (dt) {
    return this.time(this._time + dt)
  }

  source (fn) {
    if (fn == null) return this._timeSource
    this._timeSource = fn;
    return this
  }

  speed (speed) {
    if (speed == null) return this._speed
    this._speed = speed;
    return this
  }

  stop () {
    // Go to start and pause
    this.time(0);
    return this.pause()
  }

  time (time) {
    if (time == null) return this._time
    this._time = time;
    return this._continue(true)
  }

  // Remove the runner from this timeline
  unschedule (runner) {
    const index = this._runnerIds.indexOf(runner.id);
    if (index < 0) return this

    this._runners.splice(index, 1);
    this._runnerIds.splice(index, 1);

    runner.timeline(null);
    return this
  }

  // Makes sure, that after pausing the time doesn't jump
  updateTime () {
    if (!this.active()) {
      this._lastSourceTime = this._timeSource();
    }
    return this
  }

  // Checks if we are running and continues the animation
  _continue (immediateStep = false) {
    Animator.cancelFrame(this._nextFrame);
    this._nextFrame = null;

    if (immediateStep) return this._stepImmediate()
    if (this._paused) return this

    this._nextFrame = Animator.frame(this._step);
    return this
  }

  _stepFn (immediateStep = false) {
    // Get the time delta from the last time and update the time
    const time = this._timeSource();
    let dtSource = time - this._lastSourceTime;

    if (immediateStep) dtSource = 0;

    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
    this._lastSourceTime = time;

    // Only update the time if we use the timeSource.
    // Otherwise use the current time
    if (!immediateStep) {
      // Update the time
      this._time += dtTime;
      this._time = this._time < 0 ? 0 : this._time;
    }
    this._lastStepTime = this._time;
    this.fire('time', this._time);

    // This is for the case that the timeline was seeked so that the time
    // is now before the startTime of the runner. Thats why we need to set
    // the runner to position 0

    // FIXME:
    // However, reseting in insertion order leads to bugs. Considering the case,
    // where 2 runners change the same attribute but in different times,
    // reseting both of them will lead to the case where the later defined
    // runner always wins the reset even if the other runner started earlier
    // and therefore should win the attribute battle
    // this can be solved by reseting them backwards
    for (let k = this._runners.length; k--;) {
      // Get and run the current runner and ignore it if its inactive
      const runnerInfo = this._runners[k];
      const runner = runnerInfo.runner;

      // Make sure that we give the actual difference
      // between runner start time and now
      const dtToStart = this._time - runnerInfo.start;

      // Dont run runner if not started yet
      // and try to reset it
      if (dtToStart <= 0) {
        runner.reset();
      }
    }

    // Run all of the runners directly
    let runnersLeft = false;
    for (let i = 0, len = this._runners.length; i < len; i++) {
      // Get and run the current runner and ignore it if its inactive
      const runnerInfo = this._runners[i];
      const runner = runnerInfo.runner;
      let dt = dtTime;

      // Make sure that we give the actual difference
      // between runner start time and now
      const dtToStart = this._time - runnerInfo.start;

      // Dont run runner if not started yet
      if (dtToStart <= 0) {
        runnersLeft = true;
        continue
      } else if (dtToStart < dt) {
        // Adjust dt to make sure that animation is on point
        dt = dtToStart;
      }

      if (!runner.active()) continue

      // If this runner is still going, signal that we need another animation
      // frame, otherwise, remove the completed runner
      const finished = runner.step(dt).done;
      if (!finished) {
        runnersLeft = true;
        // continue
      } else if (runnerInfo.persist !== true) {
        // runner is finished. And runner might get removed
        const endTime = runner.duration() - runner.time() + this._time;

        if (endTime + runnerInfo.persist < this._time) {
          // Delete runner and correct index
          runner.unschedule();
          --i;
          --len;
        }
      }
    }

    // Basically: we continue when there are runners right from us in time
    // when -->, and when runners are left from us when <--
    if ((runnersLeft && !(this._speed < 0 && this._time === 0)) || (this._runnerIds.length && this._speed < 0 && this._time > 0)) {
      this._continue();
    } else {
      this.pause();
      this.fire('finished');
    }

    return this
  }

}

registerMethods({
  Element: {
    timeline: function (timeline) {
      if (timeline == null) {
        this._timeline = (this._timeline || new Timeline());
        return this._timeline
      } else {
        this._timeline = timeline;
        return this
      }
    }
  }
});

class Runner extends EventTarget {
  constructor (options) {
    super();

    // Store a unique id on the runner, so that we can identify it later
    this.id = Runner.id++;

    // Ensure a default value
    options = options == null
      ? timeline.duration
      : options;

    // Ensure that we get a controller
    options = typeof options === 'function'
      ? new Controller(options)
      : options;

    // Declare all of the variables
    this._element = null;
    this._timeline = null;
    this.done = false;
    this._queue = [];

    // Work out the stepper and the duration
    this._duration = typeof options === 'number' && options;
    this._isDeclarative = options instanceof Controller;
    this._stepper = this._isDeclarative ? options : new Ease();

    // We copy the current values from the timeline because they can change
    this._history = {};

    // Store the state of the runner
    this.enabled = true;
    this._time = 0;
    this._lastTime = 0;

    // At creation, the runner is in reseted state
    this._reseted = true;

    // Save transforms applied to this runner
    this.transforms = new Matrix();
    this.transformId = 1;

    // Looping variables
    this._haveReversed = false;
    this._reverse = false;
    this._loopsDone = 0;
    this._swing = false;
    this._wait = 0;
    this._times = 1;

    this._frameId = null;

    // Stores how long a runner is stored after beeing done
    this._persist = this._isDeclarative ? true : null;
  }

  static sanitise (duration, delay, when) {
    // Initialise the default parameters
    let times = 1;
    let swing = false;
    let wait = 0;
    duration = duration || timeline.duration;
    delay = delay || timeline.delay;
    when = when || 'last';

    // If we have an object, unpack the values
    if (typeof duration === 'object' && !(duration instanceof Stepper)) {
      delay = duration.delay || delay;
      when = duration.when || when;
      swing = duration.swing || swing;
      times = duration.times || times;
      wait = duration.wait || wait;
      duration = duration.duration || timeline.duration;
    }

    return {
      duration: duration,
      delay: delay,
      swing: swing,
      times: times,
      wait: wait,
      when: when
    }
  }

  active (enabled) {
    if (enabled == null) return this.enabled
    this.enabled = enabled;
    return this
  }

  /*
  Private Methods
  ===============
  Methods that shouldn't be used externally
  */
  addTransform (transform, index) {
    this.transforms.lmultiplyO(transform);
    return this
  }

  after (fn) {
    return this.on('finished', fn)
  }

  animate (duration, delay, when) {
    const o = Runner.sanitise(duration, delay, when);
    const runner = new Runner(o.duration);
    if (this._timeline) runner.timeline(this._timeline);
    if (this._element) runner.element(this._element);
    return runner.loop(o).schedule(o.delay, o.when)
  }

  clearTransform () {
    this.transforms = new Matrix();
    return this
  }

  // TODO: Keep track of all transformations so that deletion is faster
  clearTransformsFromQueue () {
    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {
      this._queue = this._queue.filter((item) => {
        return !item.isTransform
      });
    }
  }

  delay (delay) {
    return this.animate(0, delay)
  }

  duration () {
    return this._times * (this._wait + this._duration) - this._wait
  }

  during (fn) {
    return this.queue(null, fn)
  }

  ease (fn) {
    this._stepper = new Ease(fn);
    return this
  }
  /*
  Runner Definitions
  ==================
  These methods help us define the runtime behaviour of the Runner or they
  help us make new runners from the current runner
  */

  element (element) {
    if (element == null) return this._element
    this._element = element;
    element._prepareRunner();
    return this
  }

  finish () {
    return this.step(Infinity)
  }

  loop (times, swing, wait) {
    // Deal with the user passing in an object
    if (typeof times === 'object') {
      swing = times.swing;
      wait = times.wait;
      times = times.times;
    }

    // Sanitise the values and store them
    this._times = times || Infinity;
    this._swing = swing || false;
    this._wait = wait || 0;

    // Allow true to be passed
    if (this._times === true) { this._times = Infinity; }

    return this
  }

  loops (p) {
    const loopDuration = this._duration + this._wait;
    if (p == null) {
      const loopsDone = Math.floor(this._time / loopDuration);
      const relativeTime = (this._time - loopsDone * loopDuration);
      const position = relativeTime / this._duration;
      return Math.min(loopsDone + position, this._times)
    }
    const whole = Math.floor(p);
    const partial = p % 1;
    const time = loopDuration * whole + this._duration * partial;
    return this.time(time)
  }

  persist (dtOrForever) {
    if (dtOrForever == null) return this._persist
    this._persist = dtOrForever;
    return this
  }

  position (p) {
    // Get all of the variables we need
    const x = this._time;
    const d = this._duration;
    const w = this._wait;
    const t = this._times;
    const s = this._swing;
    const r = this._reverse;
    let position;

    if (p == null) {
      /*
      This function converts a time to a position in the range [0, 1]
      The full explanation can be found in this desmos demonstration
        https://www.desmos.com/calculator/u4fbavgche
      The logic is slightly simplified here because we can use booleans
      */

      // Figure out the value without thinking about the start or end time
      const f = function (x) {
        const swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));
        const backwards = (swinging && !r) || (!swinging && r);
        const uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;
        const clipped = Math.max(Math.min(uncliped, 1), 0);
        return clipped
      };

      // Figure out the value by incorporating the start time
      const endTime = t * (w + d) - w;
      position = x <= 0
        ? Math.round(f(1e-5))
        : x < endTime
          ? f(x)
          : Math.round(f(endTime - 1e-5));
      return position
    }

    // Work out the loops done and add the position to the loops done
    const loopsDone = Math.floor(this.loops());
    const swingForward = s && (loopsDone % 2 === 0);
    const forwards = (swingForward && !r) || (r && swingForward);
    position = loopsDone + (forwards ? p : 1 - p);
    return this.loops(position)
  }

  progress (p) {
    if (p == null) {
      return Math.min(1, this._time / this.duration())
    }
    return this.time(p * this.duration())
  }

  /*
  Basic Functionality
  ===================
  These methods allow us to attach basic functions to the runner directly
  */
  queue (initFn, runFn, retargetFn, isTransform) {
    this._queue.push({
      initialiser: initFn || noop,
      runner: runFn || noop,
      retarget: retargetFn,
      isTransform: isTransform,
      initialised: false,
      finished: false
    });
    const timeline = this.timeline();
    timeline && this.timeline()._continue();
    return this
  }

  reset () {
    if (this._reseted) return this
    this.time(0);
    this._reseted = true;
    return this
  }

  reverse (reverse) {
    this._reverse = reverse == null ? !this._reverse : reverse;
    return this
  }

  schedule (timeline, delay, when) {
    // The user doesn't need to pass a timeline if we already have one
    if (!(timeline instanceof Timeline)) {
      when = delay;
      delay = timeline;
      timeline = this.timeline();
    }

    // If there is no timeline, yell at the user...
    if (!timeline) {
      throw Error('Runner cannot be scheduled without timeline')
    }

    // Schedule the runner on the timeline provided
    timeline.schedule(this, delay, when);
    return this
  }

  step (dt) {
    // If we are inactive, this stepper just gets skipped
    if (!this.enabled) return this

    // Update the time and get the new position
    dt = dt == null ? 16 : dt;
    this._time += dt;
    const position = this.position();

    // Figure out if we need to run the stepper in this frame
    const running = this._lastPosition !== position && this._time >= 0;
    this._lastPosition = position;

    // Figure out if we just started
    const duration = this.duration();
    const justStarted = this._lastTime <= 0 && this._time > 0;
    const justFinished = this._lastTime < duration && this._time >= duration;

    this._lastTime = this._time;
    if (justStarted) {
      this.fire('start', this);
    }

    // Work out if the runner is finished set the done flag here so animations
    // know, that they are running in the last step (this is good for
    // transformations which can be merged)
    const declarative = this._isDeclarative;
    this.done = !declarative && !justFinished && this._time >= duration;

    // Runner is running. So its not in reseted state anymore
    this._reseted = false;

    let converged = false;
    // Call initialise and the run function
    if (running || declarative) {
      this._initialise(running);

      // clear the transforms on this runner so they dont get added again and again
      this.transforms = new Matrix();
      converged = this._run(declarative ? dt : position);

      this.fire('step', this);
    }
    // correct the done flag here
    // declaritive animations itself know when they converged
    this.done = this.done || (converged && declarative);
    if (justFinished) {
      this.fire('finished', this);
    }
    return this
  }

  /*
  Runner animation methods
  ========================
  Control how the animation plays
  */
  time (time) {
    if (time == null) {
      return this._time
    }
    const dt = time - this._time;
    this.step(dt);
    return this
  }

  timeline (timeline) {
    // check explicitly for undefined so we can set the timeline to null
    if (typeof timeline === 'undefined') return this._timeline
    this._timeline = timeline;
    return this
  }

  unschedule () {
    const timeline = this.timeline();
    timeline && timeline.unschedule(this);
    return this
  }

  // Run each initialise function in the runner if required
  _initialise (running) {
    // If we aren't running, we shouldn't initialise when not declarative
    if (!running && !this._isDeclarative) return

    // Loop through all of the initialisers
    for (let i = 0, len = this._queue.length; i < len; ++i) {
      // Get the current initialiser
      const current = this._queue[i];

      // Determine whether we need to initialise
      const needsIt = this._isDeclarative || (!current.initialised && running);
      running = !current.finished;

      // Call the initialiser if we need to
      if (needsIt && running) {
        current.initialiser.call(this);
        current.initialised = true;
      }
    }
  }

  // Save a morpher to the morpher list so that we can retarget it later
  _rememberMorpher (method, morpher) {
    this._history[method] = {
      morpher: morpher,
      caller: this._queue[this._queue.length - 1]
    };

    // We have to resume the timeline in case a controller
    // is already done without being ever run
    // This can happen when e.g. this is done:
    //    anim = el.animate(new SVG.Spring)
    // and later
    //    anim.move(...)
    if (this._isDeclarative) {
      const timeline = this.timeline();
      timeline && timeline.play();
    }
  }

  // Try to set the target for a morpher if the morpher exists, otherwise
  // Run each run function for the position or dt given
  _run (positionOrDt) {
    // Run all of the _queue directly
    let allfinished = true;
    for (let i = 0, len = this._queue.length; i < len; ++i) {
      // Get the current function to run
      const current = this._queue[i];

      // Run the function if its not finished, we keep track of the finished
      // flag for the sake of declarative _queue
      const converged = current.runner.call(this, positionOrDt);
      current.finished = current.finished || (converged === true);
      allfinished = allfinished && current.finished;
    }

    // We report when all of the constructors are finished
    return allfinished
  }

  // do nothing and return false
  _tryRetarget (method, target, extra) {
    if (this._history[method]) {
      // if the last method wasnt even initialised, throw it away
      if (!this._history[method].caller.initialised) {
        const index = this._queue.indexOf(this._history[method].caller);
        this._queue.splice(index, 1);
        return false
      }

      // for the case of transformations, we use the special retarget function
      // which has access to the outer scope
      if (this._history[method].caller.retarget) {
        this._history[method].caller.retarget.call(this, target, extra);
        // for everything else a simple morpher change is sufficient
      } else {
        this._history[method].morpher.to(target);
      }

      this._history[method].caller.finished = false;
      const timeline = this.timeline();
      timeline && timeline.play();
      return true
    }
    return false
  }

}

Runner.id = 0;

class FakeRunner {
  constructor (transforms = new Matrix(), id = -1, done = true) {
    this.transforms = transforms;
    this.id = id;
    this.done = done;
  }

  clearTransformsFromQueue () { }
}

extend([ Runner, FakeRunner ], {
  mergeWith (runner) {
    return new FakeRunner(
      runner.transforms.lmultiply(this.transforms),
      runner.id
    )
  }
});

// FakeRunner.emptyRunner = new FakeRunner()

const lmultiply = (last, curr) => last.lmultiplyO(curr);
const getRunnerTransform = (runner) => runner.transforms;

function mergeTransforms () {
  // Find the matrix to apply to the element and apply it
  const runners = this._transformationRunners.runners;
  const netTransform = runners
    .map(getRunnerTransform)
    .reduce(lmultiply, new Matrix());

  this.transform(netTransform);

  this._transformationRunners.merge();

  if (this._transformationRunners.length() === 1) {
    this._frameId = null;
  }
}

class RunnerArray {
  constructor () {
    this.runners = [];
    this.ids = [];
  }

  add (runner) {
    if (this.runners.includes(runner)) return
    const id = runner.id + 1;

    this.runners.push(runner);
    this.ids.push(id);

    return this
  }

  clearBefore (id) {
    const deleteCnt = this.ids.indexOf(id + 1) || 1;
    this.ids.splice(0, deleteCnt, 0);
    this.runners.splice(0, deleteCnt, new FakeRunner())
      .forEach((r) => r.clearTransformsFromQueue());
    return this
  }

  edit (id, newRunner) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1, id + 1);
    this.runners.splice(index, 1, newRunner);
    return this
  }

  getByID (id) {
    return this.runners[this.ids.indexOf(id + 1)]
  }

  length () {
    return this.ids.length
  }

  merge () {
    let lastRunner = null;
    for (let i = 0; i < this.runners.length; ++i) {
      const runner = this.runners[i];

      const condition = lastRunner
        && runner.done && lastRunner.done
        // don't merge runner when persisted on timeline
        && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id))
        && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));

      if (condition) {
        // the +1 happens in the function
        this.remove(runner.id);
        const newRunner = runner.mergeWith(lastRunner);
        this.edit(lastRunner.id, newRunner);
        lastRunner = newRunner;
        --i;
      } else {
        lastRunner = runner;
      }
    }

    return this
  }

  remove (id) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1);
    this.runners.splice(index, 1);
    return this
  }

}

registerMethods({
  Element: {
    animate (duration, delay, when) {
      const o = Runner.sanitise(duration, delay, when);
      const timeline = this.timeline();
      return new Runner(o.duration)
        .loop(o)
        .element(this)
        .timeline(timeline.play())
        .schedule(o.delay, o.when)
    },

    delay (by, when) {
      return this.animate(0, by, when)
    },

    // this function searches for all runners on the element and deletes the ones
    // which run before the current one. This is because absolute transformations
    // overwfrite anything anyway so there is no need to waste time computing
    // other runners
    _clearTransformRunnersBefore (currentRunner) {
      this._transformationRunners.clearBefore(currentRunner.id);
    },

    _currentTransform (current) {
      return this._transformationRunners.runners
        // we need the equal sign here to make sure, that also transformations
        // on the same runner which execute before the current transformation are
        // taken into account
        .filter((runner) => runner.id <= current.id)
        .map(getRunnerTransform)
        .reduce(lmultiply, new Matrix())
    },

    _addRunner (runner) {
      this._transformationRunners.add(runner);

      // Make sure that the runner merge is executed at the very end of
      // all Animator functions. Thats why we use immediate here to execute
      // the merge right after all frames are run
      Animator.cancelImmediate(this._frameId);
      this._frameId = Animator.immediate(mergeTransforms.bind(this));
    },

    _prepareRunner () {
      if (this._frameId == null) {
        this._transformationRunners = new RunnerArray()
          .add(new FakeRunner(new Matrix(this)));
      }
    }
  }
});

// Will output the elements from array A that are not in the array B
const difference = (a, b) => a.filter(x => !b.includes(x));

extend(Runner, {
  attr (a, v) {
    return this.styleAttr('attr', a, v)
  },

  // Add animatable styles
  css (s, v) {
    return this.styleAttr('css', s, v)
  },

  styleAttr (type, nameOrAttrs, val) {
    if (typeof nameOrAttrs === 'string') {
      return this.styleAttr(type, { [nameOrAttrs]: val })
    }

    let attrs = nameOrAttrs;
    if (this._tryRetarget(type, attrs)) return this

    let morpher = new Morphable(this._stepper).to(attrs);
    let keys = Object.keys(attrs);

    this.queue(function () {
      morpher = morpher.from(this.element()[type](keys));
    }, function (pos) {
      this.element()[type](morpher.at(pos).valueOf());
      return morpher.done()
    }, function (newToAttrs) {

      // Check if any new keys were added
      const newKeys = Object.keys(newToAttrs);
      const differences = difference(newKeys, keys);

      // If their are new keys, initialize them and add them to morpher
      if (differences.length) {
        // Get the values
        const addedFromAttrs = this.element()[type](differences);

        // Get the already initialized values
        const oldFromAttrs = new ObjectBag(morpher.from()).valueOf();

        // Merge old and new
        Object.assign(oldFromAttrs, addedFromAttrs);
        morpher.from(oldFromAttrs);
      }

      // Get the object from the morpher
      const oldToAttrs = new ObjectBag(morpher.to()).valueOf();

      // Merge in new attributes
      Object.assign(oldToAttrs, newToAttrs);

      // Change morpher target
      morpher.to(oldToAttrs);

      // Make sure that we save the work we did so we don't need it to do again
      keys = newKeys;
      attrs = newToAttrs;
    });

    this._rememberMorpher(type, morpher);
    return this
  },

  zoom (level, point) {
    if (this._tryRetarget('zoom', level, point)) return this

    let morpher = new Morphable(this._stepper).to(new SVGNumber(level));

    this.queue(function () {
      morpher = morpher.from(this.element().zoom());
    }, function (pos) {
      this.element().zoom(morpher.at(pos), point);
      return morpher.done()
    }, function (newLevel, newPoint) {
      point = newPoint;
      morpher.to(newLevel);
    });

    this._rememberMorpher('zoom', morpher);
    return this
  },

  /**
   ** absolute transformations
   **/

  //
  // M v -----|-----(D M v = F v)------|----->  T v
  //
  // 1. define the final state (T) and decompose it (once)
  //    t = [tx, ty, the, lam, sy, sx]
  // 2. on every frame: pull the current state of all previous transforms
  //    (M - m can change)
  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
  //   - Note F(0) = M
  //   - Note F(1) = T
  // 4. Now you get the delta matrix as a result: D = F * inv(M)

  transform (transforms, relative, affine) {
    // If we have a declarative function, we should retarget it if possible
    relative = transforms.relative || relative;
    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {
      return this
    }

    // Parse the parameters
    const isMatrix = Matrix.isMatrixLike(transforms);
    affine = transforms.affine != null
      ? transforms.affine
      : (affine != null ? affine : !isMatrix);

    // Create a morepher and set its type
    const morpher = new Morphable(this._stepper)
      .type(affine ? TransformBag : Matrix);

    let origin;
    let element;
    let current;
    let currentAngle;
    let startTransform;

    function setup () {
      // make sure element and origin is defined
      element = element || this.element();
      origin = origin || getOrigin(transforms, element);

      startTransform = new Matrix(relative ? undefined : element);

      // add the runner to the element so it can merge transformations
      element._addRunner(this);

      // Deactivate all transforms that have run so far if we are absolute
      if (!relative) {
        element._clearTransformRunnersBefore(this);
      }
    }

    function run (pos) {
      // clear all other transforms before this in case something is saved
      // on this runner. We are absolute. We dont need these!
      if (!relative) this.clearTransform();

      const { x, y } = new Point(origin).transform(element._currentTransform(this));

      let target = new Matrix({ ...transforms, origin: [ x, y ] });
      let start = this._isDeclarative && current
        ? current
        : startTransform;

      if (affine) {
        target = target.decompose(x, y);
        start = start.decompose(x, y);

        // Get the current and target angle as it was set
        const rTarget = target.rotate;
        const rCurrent = start.rotate;

        // Figure out the shortest path to rotate directly
        const possibilities = [ rTarget - 360, rTarget, rTarget + 360 ];
        const distances = possibilities.map(a => Math.abs(a - rCurrent));
        const shortest = Math.min(...distances);
        const index = distances.indexOf(shortest);
        target.rotate = possibilities[index];
      }

      if (relative) {
        // we have to be careful here not to overwrite the rotation
        // with the rotate method of Matrix
        if (!isMatrix) {
          target.rotate = transforms.rotate || 0;
        }
        if (this._isDeclarative && currentAngle) {
          start.rotate = currentAngle;
        }
      }

      morpher.from(start);
      morpher.to(target);

      const affineParameters = morpher.at(pos);
      currentAngle = affineParameters.rotate;
      current = new Matrix(affineParameters);

      this.addTransform(current);
      element._addRunner(this);
      return morpher.done()
    }

    function retarget (newTransforms) {
      // only get a new origin if it changed since the last call
      if (
        (newTransforms.origin || 'center').toString()
        !== (transforms.origin || 'center').toString()
      ) {
        origin = getOrigin(newTransforms, element);
      }

      // overwrite the old transformations with the new ones
      transforms = { ...newTransforms, origin };
    }

    this.queue(setup, run, retarget, true);
    this._isDeclarative && this._rememberMorpher('transform', morpher);
    return this
  },

  // Animatable x-axis
  x (x, relative) {
    return this._queueNumber('x', x)
  },

  // Animatable y-axis
  y (y) {
    return this._queueNumber('y', y)
  },

  dx (x = 0) {
    return this._queueNumberDelta('x', x)
  },

  dy (y = 0) {
    return this._queueNumberDelta('y', y)
  },

  dmove (x, y) {
    return this.dx(x).dy(y)
  },

  _queueNumberDelta (method, to) {
    to = new SVGNumber(to);

    // Try to change the target if we have this method already registerd
    if (this._tryRetarget(method, to)) return this

    // Make a morpher and queue the animation
    const morpher = new Morphable(this._stepper).to(to);
    let from = null;
    this.queue(function () {
      from = this.element()[method]();
      morpher.from(from);
      morpher.to(from + to);
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done()
    }, function (newTo) {
      morpher.to(from + new SVGNumber(newTo));
    });

    // Register the morpher so that if it is changed again, we can retarget it
    this._rememberMorpher(method, morpher);
    return this
  },

  _queueObject (method, to) {
    // Try to change the target if we have this method already registerd
    if (this._tryRetarget(method, to)) return this

    // Make a morpher and queue the animation
    const morpher = new Morphable(this._stepper).to(to);
    this.queue(function () {
      morpher.from(this.element()[method]());
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done()
    });

    // Register the morpher so that if it is changed again, we can retarget it
    this._rememberMorpher(method, morpher);
    return this
  },

  _queueNumber (method, value) {
    return this._queueObject(method, new SVGNumber(value))
  },

  // Animatable center x-axis
  cx (x) {
    return this._queueNumber('cx', x)
  },

  // Animatable center y-axis
  cy (y) {
    return this._queueNumber('cy', y)
  },

  // Add animatable move
  move (x, y) {
    return this.x(x).y(y)
  },

  // Add animatable center
  center (x, y) {
    return this.cx(x).cy(y)
  },

  // Add animatable size
  size (width, height) {
    // animate bbox based size for all other elements
    let box;

    if (!width || !height) {
      box = this._element.bbox();
    }

    if (!width) {
      width = box.width / box.height * height;
    }

    if (!height) {
      height = box.height / box.width * width;
    }

    return this
      .width(width)
      .height(height)
  },

  // Add animatable width
  width (width) {
    return this._queueNumber('width', width)
  },

  // Add animatable height
  height (height) {
    return this._queueNumber('height', height)
  },

  // Add animatable plot
  plot (a, b, c, d) {
    // Lines can be plotted with 4 arguments
    if (arguments.length === 4) {
      return this.plot([ a, b, c, d ])
    }

    if (this._tryRetarget('plot', a)) return this

    const morpher = new Morphable(this._stepper)
      .type(this._element.MorphArray).to(a);

    this.queue(function () {
      morpher.from(this._element.array());
    }, function (pos) {
      this._element.plot(morpher.at(pos));
      return morpher.done()
    });

    this._rememberMorpher('plot', morpher);
    return this
  },

  // Add leading method
  leading (value) {
    return this._queueNumber('leading', value)
  },

  // Add animatable viewbox
  viewbox (x, y, width, height) {
    return this._queueObject('viewbox', new Box(x, y, width, height))
  },

  update (o) {
    if (typeof o !== 'object') {
      return this.update({
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      })
    }

    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', o.offset);

    return this
  }
});

extend(Runner, { rx, ry, from, to });
register(Runner, 'Runner');

class Svg extends Container {
  constructor (node, attrs = node) {
    super(nodeOrNew('svg', node), attrs);
    this.namespace();
  }

  // Creates and returns defs element
  defs () {
    if (!this.isRoot()) return this.root().defs()

    return adopt(this.node.querySelector('defs'))
      || this.put(new Defs())
  }

  isRoot () {
    return !this.node.parentNode
      || (!(this.node.parentNode instanceof globals.window.SVGElement) && this.node.parentNode.nodeName !== '#document-fragment')
  }

  // Add namespaces
  namespace () {
    if (!this.isRoot()) return this.root().namespace()
    return this
      .attr({ xmlns: svg, version: '1.1' })
      .attr('xmlns:xlink', xlink, xmlns)
      .attr('xmlns:svgjs', svgjs, xmlns)
  }

  removeNamespace () {
    return this.attr({ xmlns: null, version: null })
      .attr('xmlns:xlink', null, xmlns)
      .attr('xmlns:svgjs', null, xmlns)
  }

  // Check if this is a root svg
  // If not, call root() from this element
  root () {
    if (this.isRoot()) return this
    return super.root()
  }

}

registerMethods({
  Container: {
    // Create nested svg document
    nested: wrapWithAttrCheck(function () {
      return this.put(new Svg())
    })
  }
});

register(Svg, 'Svg', true);

class Symbol$1 extends Container {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('symbol', node), attrs);
  }
}

registerMethods({
  Container: {
    symbol: wrapWithAttrCheck(function () {
      return this.put(new Symbol$1())
    })
  }
});

register(Symbol$1, 'Symbol');

// Create plain text node
function plain (text) {
  // clear if build mode is disabled
  if (this._build === false) {
    this.clear();
  }

  // create text node
  this.node.appendChild(globals.document.createTextNode(text));

  return this
}

// Get length of text element
function length () {
  return this.node.getComputedTextLength()
}

// Move over x-axis
// Text is moved by its bounding box
// text-anchor does NOT matter
function x$1 (x, box = this.bbox()) {
  if (x == null) {
    return box.x
  }

  return this.attr('x', this.attr('x') + x - box.x)
}

// Move over y-axis
function y$1 (y, box = this.bbox()) {
  if (y == null) {
    return box.y
  }

  return this.attr('y', this.attr('y') + y - box.y)
}

function move$1 (x, y, box = this.bbox()) {
  return this.x(x, box).y(y, box)
}

// Move center over x-axis
function cx (x, box = this.bbox()) {
  if (x == null) {
    return box.cx
  }

  return this.attr('x', this.attr('x') + x - box.cx)
}

// Move center over y-axis
function cy (y, box = this.bbox()) {
  if (y == null) {
    return box.cy
  }

  return this.attr('y', this.attr('y') + y - box.cy)
}

function center (x, y, box = this.bbox()) {
  return this.cx(x, box).cy(y, box)
}

function ax (x) {
  return this.attr('x', x)
}

function ay (y) {
  return this.attr('y', y)
}

function amove (x, y) {
  return this.ax(x).ay(y)
}

// Enable / disable build mode
function build (build) {
  this._build = !!build;
  return this
}

var textable = /*#__PURE__*/Object.freeze({
  __proto__: null,
  plain: plain,
  length: length,
  x: x$1,
  y: y$1,
  move: move$1,
  cx: cx,
  cy: cy,
  center: center,
  ax: ax,
  ay: ay,
  amove: amove,
  build: build
});

class Text extends Shape {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('text', node), attrs);

    this.dom.leading = new SVGNumber(1.3); // store leading value for rebuilding
    this._rebuild = true; // enable automatic updating of dy values
    this._build = false; // disable build mode for adding multiple lines
  }

  // Set / get leading
  leading (value) {
    // act as getter
    if (value == null) {
      return this.dom.leading
    }

    // act as setter
    this.dom.leading = new SVGNumber(value);

    return this.rebuild()
  }

  // Rebuild appearance type
  rebuild (rebuild) {
    // store new rebuild flag if given
    if (typeof rebuild === 'boolean') {
      this._rebuild = rebuild;
    }

    // define position of all lines
    if (this._rebuild) {
      const self = this;
      let blankLineOffset = 0;
      const leading = this.dom.leading;

      this.each(function (i) {
        const fontSize = globals.window.getComputedStyle(this.node)
          .getPropertyValue('font-size');

        const dy = leading * new SVGNumber(fontSize);

        if (this.dom.newLined) {
          this.attr('x', self.attr('x'));

          if (this.text() === '\n') {
            blankLineOffset += dy;
          } else {
            this.attr('dy', i ? dy + blankLineOffset : 0);
            blankLineOffset = 0;
          }
        }
      });

      this.fire('rebuild');
    }

    return this
  }

  // overwrite method from parent to set data properly
  setData (o) {
    this.dom = o;
    this.dom.leading = new SVGNumber(o.leading || 1.3);
    return this
  }

  // Set the text content
  text (text) {
    // act as getter
    if (text === undefined) {
      const children = this.node.childNodes;
      let firstLine = 0;
      text = '';

      for (let i = 0, len = children.length; i < len; ++i) {
        // skip textPaths - they are no lines
        if (children[i].nodeName === 'textPath') {
          if (i === 0) firstLine = 1;
          continue
        }

        // add newline if its not the first child and newLined is set to true
        if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {
          text += '\n';
        }

        // add content of this node
        text += children[i].textContent;
      }

      return text
    }

    // remove existing content
    this.clear().build(true);

    if (typeof text === 'function') {
      // call block
      text.call(this, this);
    } else {
      // store text and make sure text is not blank
      text = (text + '').split('\n');

      // build new lines
      for (let j = 0, jl = text.length; j < jl; j++) {
        this.newLine(text[j]);
      }
    }

    // disable build mode and rebuild lines
    return this.build(false).rebuild()
  }

}

extend(Text, textable);

registerMethods({
  Container: {
    // Create text element
    text: wrapWithAttrCheck(function (text = '') {
      return this.put(new Text()).text(text)
    }),

    // Create plain text element
    plain: wrapWithAttrCheck(function (text = '') {
      return this.put(new Text()).plain(text)
    })
  }
});

register(Text, 'Text');

class Tspan extends Shape {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('tspan', node), attrs);
    this._build = false; // disable build mode for adding multiple lines
  }

  // Shortcut dx
  dx (dx) {
    return this.attr('dx', dx)
  }

  // Shortcut dy
  dy (dy) {
    return this.attr('dy', dy)
  }

  // Create new line
  newLine () {
    // mark new line
    this.dom.newLined = true;

    // fetch parent
    const text = this.parent();

    // early return in case we are not in a text element
    if (!(text instanceof Text)) {
      return this
    }

    const i = text.index(this);

    const fontSize = globals.window.getComputedStyle(this.node)
      .getPropertyValue('font-size');
    const dy = text.dom.leading * new SVGNumber(fontSize);

    // apply new position
    return this.dy(i ? dy : 0).attr('x', text.x())
  }

  // Set text content
  text (text) {
    if (text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '')

    if (typeof text === 'function') {
      this.clear().build(true);
      text.call(this, this);
      this.build(false);
    } else {
      this.plain(text);
    }

    return this
  }

}

extend(Tspan, textable);

registerMethods({
  Tspan: {
    tspan: wrapWithAttrCheck(function (text = '') {
      const tspan = new Tspan();

      // clear if build mode is disabled
      if (!this._build) {
        this.clear();
      }

      // add new tspan
      return this.put(tspan).text(text)
    })
  },
  Text: {
    newLine: function (text = '') {
      return this.tspan(text).newLine()
    }
  }
});

register(Tspan, 'Tspan');

class Circle extends Shape {
  constructor (node, attrs = node) {
    super(nodeOrNew('circle', node), attrs);
  }

  radius (r) {
    return this.attr('r', r)
  }

  // Radius x value
  rx (rx) {
    return this.attr('r', rx)
  }

  // Alias radius x value
  ry (ry) {
    return this.rx(ry)
  }

  size (size) {
    return this.radius(new SVGNumber(size).divide(2))
  }
}

extend(Circle, { x: x$3, y: y$3, cx: cx$1, cy: cy$1, width: width$2, height: height$2 });

registerMethods({
  Container: {
    // Create circle element
    circle: wrapWithAttrCheck(function (size = 0) {
      return this.put(new Circle())
        .size(size)
        .move(0, 0)
    })
  }
});

register(Circle, 'Circle');

class ClipPath extends Container {
  constructor (node, attrs = node) {
    super(nodeOrNew('clipPath', node), attrs);
  }

  // Unclip all clipped elements and remove itself
  remove () {
    // unclip all targets
    this.targets().forEach(function (el) {
      el.unclip();
    });

    // remove clipPath from parent
    return super.remove()
  }

  targets () {
    return baseFind('svg [clip-path*="' + this.id() + '"]')
  }
}

registerMethods({
  Container: {
    // Create clipping element
    clip: wrapWithAttrCheck(function () {
      return this.defs().put(new ClipPath())
    })
  },
  Element: {
    // Distribute clipPath to svg element
    clipper () {
      return this.reference('clip-path')
    },

    clipWith (element) {
      // use given clip or create a new one
      const clipper = element instanceof ClipPath
        ? element
        : this.parent().clip().add(element);

      // apply mask
      return this.attr('clip-path', 'url("#' + clipper.id() + '")')
    },

    // Unclip element
    unclip () {
      return this.attr('clip-path', null)
    }
  }
});

register(ClipPath, 'ClipPath');

class ForeignObject extends Element {
  constructor (node, attrs = node) {
    super(nodeOrNew('foreignObject', node), attrs);
  }
}

registerMethods({
  Container: {
    foreignObject: wrapWithAttrCheck(function (width, height) {
      return this.put(new ForeignObject()).size(width, height)
    })
  }
});

register(ForeignObject, 'ForeignObject');

function dmove (dx, dy) {
  this.children().forEach((child, i) => {

    let bbox;

    // We have to wrap this for elements that dont have a bbox
    // e.g. title and other descriptive elements
    try {
      // Get the childs bbox
      bbox = child.bbox();
    } catch (e) {
      return
    }

    // Get childs matrix
    const m = new Matrix(child);
    // Translate childs matrix by amount and
    // transform it back into parents space
    const matrix = m.translate(dx, dy).transform(m.inverse());
    // Calculate new x and y from old box
    const p = new Point(bbox.x, bbox.y).transform(matrix);
    // Move element
    child.move(p.x, p.y);
  });

  return this
}

function dx (dx) {
  return this.dmove(dx, 0)
}

function dy (dy) {
  return this.dmove(0, dy)
}

function height (height, box = this.bbox()) {
  if (height == null) return box.height
  return this.size(box.width, height, box)
}

function move (x = 0, y = 0, box = this.bbox()) {
  const dx = x - box.x;
  const dy = y - box.y;

  return this.dmove(dx, dy)
}

function size (width, height, box = this.bbox()) {
  const p = proportionalSize(this, width, height, box);
  const scaleX = p.width / box.width;
  const scaleY = p.height / box.height;

  this.children().forEach((child, i) => {
    const o = new Point(box).transform(new Matrix(child).inverse());
    child.scale(scaleX, scaleY, o.x, o.y);
  });

  return this
}

function width (width, box = this.bbox()) {
  if (width == null) return box.width
  return this.size(width, box.height, box)
}

function x (x, box = this.bbox()) {
  if (x == null) return box.x
  return this.move(x, box.y, box)
}

function y (y, box = this.bbox()) {
  if (y == null) return box.y
  return this.move(box.x, y, box)
}

var containerGeometry = /*#__PURE__*/Object.freeze({
  __proto__: null,
  dmove: dmove,
  dx: dx,
  dy: dy,
  height: height,
  move: move,
  size: size,
  width: width,
  x: x,
  y: y
});

class G extends Container {
  constructor (node, attrs = node) {
    super(nodeOrNew('g', node), attrs);
  }
}

extend(G, containerGeometry);

registerMethods({
  Container: {
    // Create a group element
    group: wrapWithAttrCheck(function () {
      return this.put(new G())
    })
  }
});

register(G, 'G');

class A extends Container {
  constructor (node, attrs = node) {
    super(nodeOrNew('a', node), attrs);
  }

  // Link target attribute
  target (target) {
    return this.attr('target', target)
  }

  // Link url
  to (url) {
    return this.attr('href', url, xlink)
  }

}

extend(A, containerGeometry);

registerMethods({
  Container: {
    // Create a hyperlink element
    link: wrapWithAttrCheck(function (url) {
      return this.put(new A()).to(url)
    })
  },
  Element: {
    unlink () {
      const link = this.linker();

      if (!link) return this

      const parent = link.parent();

      if (!parent) {
        return this.remove()
      }

      const index = parent.index(link);
      parent.add(this, index);

      link.remove();
      return this
    },
    linkTo (url) {
      // reuse old link if possible
      let link = this.linker();

      if (!link) {
        link = new A();
        this.wrap(link);
      }

      if (typeof url === 'function') {
        url.call(link, link);
      } else {
        link.to(url);
      }

      return this
    },
    linker () {
      const link = this.parent();
      if (link && link.node.nodeName.toLowerCase() === 'a') {
        return link
      }

      return null
    }
  }
});

register(A, 'A');

class Mask extends Container {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('mask', node), attrs);
  }

  // Unmask all masked elements and remove itself
  remove () {
    // unmask all targets
    this.targets().forEach(function (el) {
      el.unmask();
    });

    // remove mask from parent
    return super.remove()
  }

  targets () {
    return baseFind('svg [mask*="' + this.id() + '"]')
  }
}

registerMethods({
  Container: {
    mask: wrapWithAttrCheck(function () {
      return this.defs().put(new Mask())
    })
  },
  Element: {
    // Distribute mask to svg element
    masker () {
      return this.reference('mask')
    },

    maskWith (element) {
      // use given mask or create a new one
      const masker = element instanceof Mask
        ? element
        : this.parent().mask().add(element);

      // apply mask
      return this.attr('mask', 'url("#' + masker.id() + '")')
    },

    // Unmask element
    unmask () {
      return this.attr('mask', null)
    }
  }
});

register(Mask, 'Mask');

class Stop extends Element {
  constructor (node, attrs = node) {
    super(nodeOrNew('stop', node), attrs);
  }

  // add color stops
  update (o) {
    if (typeof o === 'number' || o instanceof SVGNumber) {
      o = {
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      };
    }

    // set attributes
    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));

    return this
  }
}

registerMethods({
  Gradient: {
    // Add a color stop
    stop: function (offset, color, opacity) {
      return this.put(new Stop()).update(offset, color, opacity)
    }
  }
});

register(Stop, 'Stop');

function cssRule (selector, rule) {
  if (!selector) return ''
  if (!rule) return selector

  let ret = selector + '{';

  for (const i in rule) {
    ret += unCamelCase(i) + ':' + rule[i] + ';';
  }

  ret += '}';

  return ret
}

class Style extends Element {
  constructor (node, attrs = node) {
    super(nodeOrNew('style', node), attrs);
  }

  addText (w = '') {
    this.node.textContent += w;
    return this
  }

  font (name, src, params = {}) {
    return this.rule('@font-face', {
      fontFamily: name,
      src: src,
      ...params
    })
  }

  rule (selector, obj) {
    return this.addText(cssRule(selector, obj))
  }
}

registerMethods('Dom', {
  style (selector, obj) {
    return this.put(new Style()).rule(selector, obj)
  },
  fontface  (name, src, params) {
    return this.put(new Style()).font(name, src, params)
  }
});

register(Style, 'Style');

class TextPath extends Text {
  // Initialize node
  constructor (node, attrs = node) {
    super(nodeOrNew('textPath', node), attrs);
  }

  // return the array of the path track element
  array () {
    const track = this.track();

    return track ? track.array() : null
  }

  // Plot path if any
  plot (d) {
    const track = this.track();
    let pathArray = null;

    if (track) {
      pathArray = track.plot(d);
    }

    return (d == null) ? pathArray : this
  }

  // Get the path element
  track () {
    return this.reference('href')
  }
}

registerMethods({
  Container: {
    textPath: wrapWithAttrCheck(function (text, path) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = this.text(text);
      }

      return text.path(path)
    })
  },
  Text: {
    // Create path for text to run on
    path: wrapWithAttrCheck(function (track, importNodes = true) {
      const textPath = new TextPath();

      // if track is a path, reuse it
      if (!(track instanceof Path)) {
        // create path element
        track = this.defs().path(track);
      }

      // link textPath to path and add content
      textPath.attr('href', '#' + track, xlink);

      // Transplant all nodes from text to textPath
      let node;
      if (importNodes) {
        while ((node = this.node.firstChild)) {
          textPath.node.appendChild(node);
        }
      }

      // add textPath element as child node and return textPath
      return this.put(textPath)
    }),

    // Get the textPath children
    textPath () {
      return this.findOne('textPath')
    }
  },
  Path: {
    // creates a textPath from this path
    text: wrapWithAttrCheck(function (text) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = new Text().addTo(this.parent()).text(text);
      }

      // Create textPath from text and path and return
      return text.path(this)
    }),

    targets () {
      return baseFind('svg textPath').filter((node) => {
        return (node.attr('href') || '').includes(this.id())
      })

      // Does not work in IE11. Use when IE support is dropped
      // return baseFind('svg textPath[*|href*="' + this.id() + '"]')
    }
  }
});

TextPath.prototype.MorphArray = PathArray;
register(TextPath, 'TextPath');

class Use extends Shape {
  constructor (node, attrs = node) {
    super(nodeOrNew('use', node), attrs);
  }

  // Use element as a reference
  use (element, file) {
    // Set lined element
    return this.attr('href', (file || '') + '#' + element, xlink)
  }
}

registerMethods({
  Container: {
    // Create a use element
    use: wrapWithAttrCheck(function (element, file) {
      return this.put(new Use()).use(element, file)
    })
  }
});

register(Use, 'Use');

/* Optional Modules */

extend([
  Svg,
  Symbol$1,
  Image$1,
  Pattern,
  Marker
], getMethodsFor('viewbox'));

extend([
  Line,
  Polyline,
  Polygon,
  Path
], getMethodsFor('marker'));

extend(Text, getMethodsFor('Text'));
extend(Path, getMethodsFor('Path'));

extend(Defs, getMethodsFor('Defs'));

extend([
  Text,
  Tspan
], getMethodsFor('Tspan'));

extend([
  Rect,
  Ellipse,
  Gradient,
  Runner
], getMethodsFor('radius'));

extend(EventTarget, getMethodsFor('EventTarget'));
extend(Dom, getMethodsFor('Dom'));
extend(Element, getMethodsFor('Element'));
extend(Shape, getMethodsFor('Shape'));
extend([ Container, Fragment ], getMethodsFor('Container'));
extend(Gradient, getMethodsFor('Gradient'));

extend(Runner, getMethodsFor('Runner'));

List.extend(getMethodNames());

registerMorphableType([
  SVGNumber,
  Color,
  Box,
  Matrix,
  SVGArray,
  PointArray,
  PathArray,
  Point
]);

makeMorphable();

// Normalise attributes
const normaliseAttributes = (attr) => {
  for (const a in attr) {
    if (!/fill|stroke|opacity|transform/.test(a)) { delete attr[a]; }
  }

  return attr
};

extend(Shape, {
  // Convert element to path
  toPath (replace = true) {
    var d;

    switch (this.type) {
    case 'rect': {
      let {
        width: w,
        height: h,
        rx,
        ry,
        x,
        y
      } = this.attr(['width', 'height', 'rx', 'ry', 'x', 'y']);

      // normalise radius values, just like the original does it (or should do)
      if (rx < 0) rx = 0;
      if (ry < 0) ry = 0;
      rx = rx || ry;
      ry = ry || rx;
      if (rx > w / 2) rx = w / 2;
      if (ry > h / 2) ry = h / 2;

      if (rx && ry) {
        // if there are round corners

        d = [
          ['M', rx + x, y],
          ['h', w - 2 * rx],
          ['a', rx, ry, 0, 0, 1, rx, ry],
          ['v', h - 2 * ry],
          ['a', rx, ry, 0, 0, 1, -rx, ry],
          ['h', -w + 2 * rx],
          ['a', rx, ry, 0, 0, 1, -rx, -ry],
          ['v', -h + 2 * ry],
          ['a', rx, ry, 0, 0, 1, rx, -ry],
          ['z']
        ];
      } else {
        // no round corners, no need to draw arcs
        d = [
          ['M', x, y],
          ['h', w],
          ['v', h],
          ['h', -w],
          ['v', -h],
          ['z']
        ];
      }

      break
    }
    case 'circle':
    case 'ellipse': {
      let rx = this.rx();
      let ry = this.ry();
      let { cx, cy } = this.attr(['cx', 'cy']);

      d = [
        ['M', cx - rx, cy],
        ['A', rx, ry, 0, 0, 0, cx + rx, cy],
        ['A', rx, ry, 0, 0, 0, cx - rx, cy],
        ['z']
      ];

      break
    }
    case 'polygon':
    case 'polyline':
    case 'line':

      d = this.array().map(function (arr) {
        return ['L'].concat(arr)
      });

      d[0][0] = 'M';

      if (this.type === 'polygon') { d.push('Z'); }

      break
    case 'path':
      d = this.array();
      break
    default:
      throw new Error('SVG toPath got unsupported type ' + this.type, this)
    }

    const path = new Path()
      .plot(d)
      .attr(normaliseAttributes(this.attr()));

    if (replace) {
      this.replace(path);
    }

    return path
  }

});

// Author: Axel Antoine
class SVGBuildInfo {
    totalTime = Infinity;
    passesInfo = new Array();
}
class SVGBuilder {
    options;
    drawPasses = new Array;
    constructor(options = {}) {
        this.options = {
            prettifySVG: false,
            ...options
        };
    }
    async buildSVG(viewmap, size, info = new SVGBuildInfo()) {
        const buildStartTime = Date.now();
        const svg = new Svg();
        svg.width(size.w);
        svg.height(size.h);
        // Call the draw passes
        for (let i = 0; i < this.drawPasses.length; i++) {
            const pass = this.drawPasses[i];
            const passStartTime = Date.now();
            await pass.draw(svg, viewmap);
            info.passesInfo.push({
                name: pass.name,
                order: i,
                time: Date.now() - passStartTime,
            });
        }
        info.totalTime = Date.now() - buildStartTime;
        return svg;
    }
}

// Author: Axel Antoine
class SVGRenderInfo {
    resolution = { w: Infinity, h: Infinity };
    renderingTime = Infinity;
    viewmapBuildInfo = new ViewmapBuildInfo();
    svgBuildInfo = new SVGBuildInfo();
}
class SVGRenderer {
    viewmap = new Viewmap();
    svgBuilder = new SVGBuilder();
    /**
     * Render a SVG file from the given meshes and returns it.
     * @param meshes Mehses to render
     * @param camera Camera used to compute the perspective
     * @param size Size of the render (will be scaled by camera aspect ratio)
     * @param options Options to customize the render
     * @param info Object containing info (e.g. times) on the rendering process
     * @returns SVG object from the Svgdotjs lib
     */
    async generateSVG(meshes, camera, size, options = {}, info = new SVGRenderInfo()) {
        const renderStartTime = Date.now();
        // Setup camera
        const renderSize = {
            w: size.w,
            h: size.w / camera.aspect
        };
        info.resolution = renderSize;
        // Viewmap Build
        await this.viewmap.build(meshes, camera, renderSize, options.viewmap, info.viewmapBuildInfo);
        // SVG Buid
        const svg = await this.svgBuilder.buildSVG(this.viewmap, renderSize, info.svgBuildInfo);
        info.renderingTime = Date.now() - renderStartTime;
        return svg;
    }
    addDrawPass(pass) {
        if (!this.svgBuilder.drawPasses.includes(pass)) {
            this.svgBuilder.drawPasses.push(pass);
        }
    }
    removeDrawPass(pass) {
        this.svgBuilder.drawPasses.remove(pass);
    }
    clearDrawPasses() {
        this.svgBuilder.drawPasses.clear();
    }
}

// Split strategy constants
const CENTER = 0;
const AVERAGE = 1;
const SAH = 2;
const CONTAINED = 2;

// SAH cost constants
// TODO: hone these costs more. The relative difference between them should be the
// difference in measured time to perform a triangle intersection vs traversing
// bounds.
const TRIANGLE_INTERSECT_COST = 1.25;
const TRAVERSAL_COST = 1;


// Build constants
const BYTES_PER_NODE = 6 * 4 + 4 + 4;
const IS_LEAFNODE_FLAG = 0xFFFF;

// EPSILON for computing floating point error during build
// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics
const FLOAT32_EPSILON = Math.pow( 2, - 24 );

class MeshBVHNode {

	constructor() {

		// internal nodes have boundingData, left, right, and splitAxis
		// leaf nodes have offset and count (referring to primitives in the mesh geometry)

	}

}

function arrayToBox( nodeIndex32, array, target ) {

	target.min.x = array[ nodeIndex32 ];
	target.min.y = array[ nodeIndex32 + 1 ];
	target.min.z = array[ nodeIndex32 + 2 ];

	target.max.x = array[ nodeIndex32 + 3 ];
	target.max.y = array[ nodeIndex32 + 4 ];
	target.max.z = array[ nodeIndex32 + 5 ];

	return target;

}

function getLongestEdgeIndex( bounds ) {

	let splitDimIdx = - 1;
	let splitDist = - Infinity;

	for ( let i = 0; i < 3; i ++ ) {

		const dist = bounds[ i + 3 ] - bounds[ i ];
		if ( dist > splitDist ) {

			splitDist = dist;
			splitDimIdx = i;

		}

	}

	return splitDimIdx;

}

// copys bounds a into bounds b
function copyBounds( source, target ) {

	target.set( source );

}

// sets bounds target to the union of bounds a and b
function unionBounds( a, b, target ) {

	let aVal, bVal;
	for ( let d = 0; d < 3; d ++ ) {

		const d3 = d + 3;

		// set the minimum values
		aVal = a[ d ];
		bVal = b[ d ];
		target[ d ] = aVal < bVal ? aVal : bVal;

		// set the max values
		aVal = a[ d3 ];
		bVal = b[ d3 ];
		target[ d3 ] = aVal > bVal ? aVal : bVal;

	}

}

// expands the given bounds by the provided triangle bounds
function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {

	for ( let d = 0; d < 3; d ++ ) {

		const tCenter = triangleBounds[ startIndex + 2 * d ];
		const tHalf = triangleBounds[ startIndex + 2 * d + 1 ];

		const tMin = tCenter - tHalf;
		const tMax = tCenter + tHalf;

		if ( tMin < bounds[ d ] ) {

			bounds[ d ] = tMin;

		}

		if ( tMax > bounds[ d + 3 ] ) {

			bounds[ d + 3 ] = tMax;

		}

	}

}

// compute bounds surface area
function computeSurfaceArea( bounds ) {

	const d0 = bounds[ 3 ] - bounds[ 0 ];
	const d1 = bounds[ 4 ] - bounds[ 1 ];
	const d2 = bounds[ 5 ] - bounds[ 2 ];

	return 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );

}

function ensureIndex( geo, options ) {

	if ( ! geo.index ) {

		const vertexCount = geo.attributes.position.count;
		const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
		let index;
		if ( vertexCount > 65535 ) {

			index = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );

		} else {

			index = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );

		}

		geo.setIndex( new BufferAttribute( index, 1 ) );

		for ( let i = 0; i < vertexCount; i ++ ) {

			index[ i ] = i;

		}

	}

}

// Computes the set of { offset, count } ranges which need independent BVH roots. Each
// region in the geometry index that belongs to a different set of material groups requires
// a separate BVH root, so that triangles indices belonging to one group never get swapped
// with triangle indices belongs to another group. For example, if the groups were like this:
//
// [-------------------------------------------------------------]
// |__________________|
//   g0 = [0, 20]  |______________________||_____________________|
//                      g1 = [16, 40]           g2 = [41, 60]
//
// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].
function getRootIndexRanges( geo ) {

	if ( ! geo.groups || ! geo.groups.length ) {

		return [ { offset: 0, count: geo.index.count / 3 } ];

	}

	const ranges = [];
	const rangeBoundaries = new Set();
	for ( const group of geo.groups ) {

		rangeBoundaries.add( group.start );
		rangeBoundaries.add( group.start + group.count );

	}

	// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(
	const sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );
	for ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {

		const start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];
		ranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );

	}

	return ranges;

}

// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If
// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.
// These are computed together to avoid redundant accesses to bounds array.
function getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {

	let minx = Infinity;
	let miny = Infinity;
	let minz = Infinity;
	let maxx = - Infinity;
	let maxy = - Infinity;
	let maxz = - Infinity;

	let cminx = Infinity;
	let cminy = Infinity;
	let cminz = Infinity;
	let cmaxx = - Infinity;
	let cmaxy = - Infinity;
	let cmaxz = - Infinity;

	const includeCentroid = centroidTarget !== null;
	for ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {

		const cx = triangleBounds[ i + 0 ];
		const hx = triangleBounds[ i + 1 ];
		const lx = cx - hx;
		const rx = cx + hx;
		if ( lx < minx ) minx = lx;
		if ( rx > maxx ) maxx = rx;
		if ( includeCentroid && cx < cminx ) cminx = cx;
		if ( includeCentroid && cx > cmaxx ) cmaxx = cx;

		const cy = triangleBounds[ i + 2 ];
		const hy = triangleBounds[ i + 3 ];
		const ly = cy - hy;
		const ry = cy + hy;
		if ( ly < miny ) miny = ly;
		if ( ry > maxy ) maxy = ry;
		if ( includeCentroid && cy < cminy ) cminy = cy;
		if ( includeCentroid && cy > cmaxy ) cmaxy = cy;

		const cz = triangleBounds[ i + 4 ];
		const hz = triangleBounds[ i + 5 ];
		const lz = cz - hz;
		const rz = cz + hz;
		if ( lz < minz ) minz = lz;
		if ( rz > maxz ) maxz = rz;
		if ( includeCentroid && cz < cminz ) cminz = cz;
		if ( includeCentroid && cz > cmaxz ) cmaxz = cz;

	}

	target[ 0 ] = minx;
	target[ 1 ] = miny;
	target[ 2 ] = minz;

	target[ 3 ] = maxx;
	target[ 4 ] = maxy;
	target[ 5 ] = maxz;

	if ( includeCentroid ) {

		centroidTarget[ 0 ] = cminx;
		centroidTarget[ 1 ] = cminy;
		centroidTarget[ 2 ] = cminz;

		centroidTarget[ 3 ] = cmaxx;
		centroidTarget[ 4 ] = cmaxy;
		centroidTarget[ 5 ] = cmaxz;

	}

}

// A stand alone function for retrieving the centroid bounds.
function getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {

	let cminx = Infinity;
	let cminy = Infinity;
	let cminz = Infinity;
	let cmaxx = - Infinity;
	let cmaxy = - Infinity;
	let cmaxz = - Infinity;

	for ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {

		const cx = triangleBounds[ i + 0 ];
		if ( cx < cminx ) cminx = cx;
		if ( cx > cmaxx ) cmaxx = cx;

		const cy = triangleBounds[ i + 2 ];
		if ( cy < cminy ) cminy = cy;
		if ( cy > cmaxy ) cmaxy = cy;

		const cz = triangleBounds[ i + 4 ];
		if ( cz < cminz ) cminz = cz;
		if ( cz > cmaxz ) cmaxz = cz;

	}

	centroidTarget[ 0 ] = cminx;
	centroidTarget[ 1 ] = cminy;
	centroidTarget[ 2 ] = cminz;

	centroidTarget[ 3 ] = cmaxx;
	centroidTarget[ 4 ] = cmaxy;
	centroidTarget[ 5 ] = cmaxz;

}


// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split
// will be on the left and elements on the right side of the split will be on the right. returns the index
// of the first element on the right side, or offset + count if there are no elements on the right side.
function partition( index, triangleBounds, offset, count, split ) {

	let left = offset;
	let right = offset + count - 1;
	const pos = split.pos;
	const axisOffset = split.axis * 2;

	// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme
	while ( true ) {

		while ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {

			left ++;

		}


		// if a triangle center lies on the partition plane it is considered to be on the right side
		while ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {

			right --;

		}

		if ( left < right ) {

			// we need to swap all of the information associated with the triangles at index
			// left and right; that's the verts in the geometry index, the bounds,
			// and perhaps the SAH planes

			for ( let i = 0; i < 3; i ++ ) {

				let t0 = index[ left * 3 + i ];
				index[ left * 3 + i ] = index[ right * 3 + i ];
				index[ right * 3 + i ] = t0;

				let t1 = triangleBounds[ left * 6 + i * 2 + 0 ];
				triangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];
				triangleBounds[ right * 6 + i * 2 + 0 ] = t1;

				let t2 = triangleBounds[ left * 6 + i * 2 + 1 ];
				triangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];
				triangleBounds[ right * 6 + i * 2 + 1 ] = t2;

			}

			left ++;
			right --;

		} else {

			return left;

		}

	}

}

const BIN_COUNT = 32;
const binsSort = ( a, b ) => a.candidate - b.candidate;
const sahBins = new Array( BIN_COUNT ).fill().map( () => {

	return {

		count: 0,
		bounds: new Float32Array( 6 ),
		rightCacheBounds: new Float32Array( 6 ),
		leftCacheBounds: new Float32Array( 6 ),
		candidate: 0,

	};

} );
const leftBounds = new Float32Array( 6 );

function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {

	let axis = - 1;
	let pos = 0;

	// Center
	if ( strategy === CENTER ) {

		axis = getLongestEdgeIndex( centroidBoundingData );
		if ( axis !== - 1 ) {

			pos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;

		}

	} else if ( strategy === AVERAGE ) {

		axis = getLongestEdgeIndex( nodeBoundingData );
		if ( axis !== - 1 ) {

			pos = getAverage( triangleBounds, offset, count, axis );

		}

	} else if ( strategy === SAH ) {

		const rootSurfaceArea = computeSurfaceArea( nodeBoundingData );
		let bestCost = TRIANGLE_INTERSECT_COST * count;

		// iterate over all axes
		const cStart = offset * 6;
		const cEnd = ( offset + count ) * 6;
		for ( let a = 0; a < 3; a ++ ) {

			const axisLeft = centroidBoundingData[ a ];
			const axisRight = centroidBoundingData[ a + 3 ];
			const axisLength = axisRight - axisLeft;
			const binWidth = axisLength / BIN_COUNT;

			// If we have fewer triangles than we're planning to split then just check all
			// the triangle positions because it will be faster.
			if ( count < BIN_COUNT / 4 ) {

				// initialize the bin candidates
				const truncatedBins = [ ...sahBins ];
				truncatedBins.length = count;

				// set the candidates
				let b = 0;
				for ( let c = cStart; c < cEnd; c += 6, b ++ ) {

					const bin = truncatedBins[ b ];
					bin.candidate = triangleBounds[ c + 2 * a ];
					bin.count = 0;

					const {
						bounds,
						leftCacheBounds,
						rightCacheBounds,
					} = bin;
					for ( let d = 0; d < 3; d ++ ) {

						rightCacheBounds[ d ] = Infinity;
						rightCacheBounds[ d + 3 ] = - Infinity;

						leftCacheBounds[ d ] = Infinity;
						leftCacheBounds[ d + 3 ] = - Infinity;

						bounds[ d ] = Infinity;
						bounds[ d + 3 ] = - Infinity;

					}

					expandByTriangleBounds( c, triangleBounds, bounds );

				}

				truncatedBins.sort( binsSort );

				// remove redundant splits
				let splitCount = count;
				for ( let bi = 0; bi < splitCount; bi ++ ) {

					const bin = truncatedBins[ bi ];
					while ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {

						truncatedBins.splice( bi + 1, 1 );
						splitCount --;

					}

				}

				// find the appropriate bin for each triangle and expand the bounds.
				for ( let c = cStart; c < cEnd; c += 6 ) {

					const center = triangleBounds[ c + 2 * a ];
					for ( let bi = 0; bi < splitCount; bi ++ ) {

						const bin = truncatedBins[ bi ];
						if ( center >= bin.candidate ) {

							expandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );

						} else {

							expandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );
							bin.count ++;

						}

					}

				}

				// expand all the bounds
				for ( let bi = 0; bi < splitCount; bi ++ ) {

					const bin = truncatedBins[ bi ];
					const leftCount = bin.count;
					const rightCount = count - bin.count;

					// check the cost of this split
					const leftBounds = bin.leftCacheBounds;
					const rightBounds = bin.rightCacheBounds;

					let leftProb = 0;
					if ( leftCount !== 0 ) {

						leftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;

					}

					let rightProb = 0;
					if ( rightCount !== 0 ) {

						rightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;

					}

					const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (
						leftProb * leftCount + rightProb * rightCount
					);

					if ( cost < bestCost ) {

						axis = a;
						bestCost = cost;
						pos = bin.candidate;

					}

				}

			} else {

				// reset the bins
				for ( let i = 0; i < BIN_COUNT; i ++ ) {

					const bin = sahBins[ i ];
					bin.count = 0;
					bin.candidate = axisLeft + binWidth + i * binWidth;

					const bounds = bin.bounds;
					for ( let d = 0; d < 3; d ++ ) {

						bounds[ d ] = Infinity;
						bounds[ d + 3 ] = - Infinity;

					}

				}

				// iterate over all center positions
				for ( let c = cStart; c < cEnd; c += 6 ) {

					const triCenter = triangleBounds[ c + 2 * a ];
					const relativeCenter = triCenter - axisLeft;

					// in the partition function if the centroid lies on the split plane then it is
					// considered to be on the right side of the split
					let binIndex = ~ ~ ( relativeCenter / binWidth );
					if ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;

					const bin = sahBins[ binIndex ];
					bin.count ++;

					expandByTriangleBounds( c, triangleBounds, bin.bounds );

				}

				// cache the unioned bounds from right to left so we don't have to regenerate them each time
				const lastBin = sahBins[ BIN_COUNT - 1 ];
				copyBounds( lastBin.bounds, lastBin.rightCacheBounds );
				for ( let i = BIN_COUNT - 2; i >= 0; i -- ) {

					const bin = sahBins[ i ];
					const nextBin = sahBins[ i + 1 ];
					unionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );

				}

				let leftCount = 0;
				for ( let i = 0; i < BIN_COUNT - 1; i ++ ) {

					const bin = sahBins[ i ];
					const binCount = bin.count;
					const bounds = bin.bounds;

					const nextBin = sahBins[ i + 1 ];
					const rightBounds = nextBin.rightCacheBounds;

					// dont do anything with the bounds if the new bounds have no triangles
					if ( binCount !== 0 ) {

						if ( leftCount === 0 ) {

							copyBounds( bounds, leftBounds );

						} else {

							unionBounds( bounds, leftBounds, leftBounds );

						}

					}

					leftCount += binCount;

					// check the cost of this split
					let leftProb = 0;
					let rightProb = 0;

					if ( leftCount !== 0 ) {

						leftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;

					}

					const rightCount = count - leftCount;
					if ( rightCount !== 0 ) {

						rightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;

					}

					const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (
						leftProb * leftCount + rightProb * rightCount
					);

					if ( cost < bestCost ) {

						axis = a;
						bestCost = cost;
						pos = bin.candidate;

					}

				}

			}

		}

	} else {

		console.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );

	}

	return { axis, pos };

}

// returns the average coordinate on the specified axis of the all the provided triangles
function getAverage( triangleBounds, offset, count, axis ) {

	let avg = 0;
	for ( let i = offset, end = offset + count; i < end; i ++ ) {

		avg += triangleBounds[ i * 6 + axis * 2 ];

	}

	return avg / count;

}

// precomputes the bounding box for each triangle; required for quickly calculating tree splits.
// result is an array of size tris.length * 6 where triangle i maps to a
// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,
// representing the center and half-extent in each dimension of triangle i
function computeTriangleBounds( geo, fullBounds ) {

	const posAttr = geo.attributes.position;
	const posArr = posAttr.array;
	const index = geo.index.array;
	const triCount = index.length / 3;
	const triangleBounds = new Float32Array( triCount * 6 );

	// support for an interleaved position buffer
	const bufferOffset = posAttr.offset || 0;
	let stride = 3;
	if ( posAttr.isInterleavedBufferAttribute ) {

		stride = posAttr.data.stride;

	}

	for ( let tri = 0; tri < triCount; tri ++ ) {

		const tri3 = tri * 3;
		const tri6 = tri * 6;
		const ai = index[ tri3 + 0 ] * stride + bufferOffset;
		const bi = index[ tri3 + 1 ] * stride + bufferOffset;
		const ci = index[ tri3 + 2 ] * stride + bufferOffset;

		for ( let el = 0; el < 3; el ++ ) {

			const a = posArr[ ai + el ];
			const b = posArr[ bi + el ];
			const c = posArr[ ci + el ];

			let min = a;
			if ( b < min ) min = b;
			if ( c < min ) min = c;

			let max = a;
			if ( b > max ) max = b;
			if ( c > max ) max = c;

			// Increase the bounds size by float32 epsilon to avoid precision errors when
			// converting to 32 bit float. Scale the epsilon by the size of the numbers being
			// worked with.
			const halfExtents = ( max - min ) / 2;
			const el2 = el * 2;
			triangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;
			triangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;

			if ( min < fullBounds[ el ] ) fullBounds[ el ] = min;
			if ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;

		}

	}

	return triangleBounds;

}

function buildTree( geo, options ) {

	function triggerProgress( trianglesProcessed ) {

		if ( onProgress ) {

			onProgress( trianglesProcessed / totalTriangles );

		}

	}

	// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,
	// recording the offset and count of its triangles and writing them into the reordered geometry index.
	function splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {

		if ( ! reachedMaxDepth && depth >= maxDepth ) {

			reachedMaxDepth = true;
			if ( verbose ) {

				console.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );
				console.warn( geo );

			}

		}

		// early out if we've met our capacity
		if ( count <= maxLeafTris || depth >= maxDepth ) {

			triggerProgress( offset + count );
			node.offset = offset;
			node.count = count;
			return node;

		}

		// Find where to split the volume
		const split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );
		if ( split.axis === - 1 ) {

			triggerProgress( offset + count );
			node.offset = offset;
			node.count = count;
			return node;

		}

		const splitOffset = partition( indexArray, triangleBounds, offset, count, split );

		// create the two new child nodes
		if ( splitOffset === offset || splitOffset === offset + count ) {

			triggerProgress( offset + count );
			node.offset = offset;
			node.count = count;

		} else {

			node.splitAxis = split.axis;

			// create the left child and compute its bounding box
			const left = new MeshBVHNode();
			const lstart = offset;
			const lcount = splitOffset - offset;
			node.left = left;
			left.boundingData = new Float32Array( 6 );

			getBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );
			splitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );

			// repeat for right
			const right = new MeshBVHNode();
			const rstart = splitOffset;
			const rcount = count - lcount;
			node.right = right;
			right.boundingData = new Float32Array( 6 );

			getBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );
			splitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );

		}

		return node;

	}

	ensureIndex( geo, options );

	// Compute the full bounds of the geometry at the same time as triangle bounds because
	// we'll need it for the root bounds in the case with no groups and it should be fast here.
	// We can't use the geometrying bounding box if it's available because it may be out of date.
	const fullBounds = new Float32Array( 6 );
	const cacheCentroidBoundingData = new Float32Array( 6 );
	const triangleBounds = computeTriangleBounds( geo, fullBounds );
	const indexArray = geo.index.array;
	const maxDepth = options.maxDepth;
	const verbose = options.verbose;
	const maxLeafTris = options.maxLeafTris;
	const strategy = options.strategy;
	const onProgress = options.onProgress;
	const totalTriangles = geo.index.count / 3;
	let reachedMaxDepth = false;

	const roots = [];
	const ranges = getRootIndexRanges( geo );

	if ( ranges.length === 1 ) {

		const range = ranges[ 0 ];
		const root = new MeshBVHNode();
		root.boundingData = fullBounds;
		getCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );

		splitNode( root, range.offset, range.count, cacheCentroidBoundingData );
		roots.push( root );

	} else {

		for ( let range of ranges ) {

			const root = new MeshBVHNode();
			root.boundingData = new Float32Array( 6 );
			getBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );

			splitNode( root, range.offset, range.count, cacheCentroidBoundingData );
			roots.push( root );

		}

	}

	return roots;

}

function buildPackedTree( geo, options ) {

	// boundingData  				: 6 float32
	// right / offset 				: 1 uint32
	// splitAxis / isLeaf + count 	: 1 uint32 / 2 uint16
	const roots = buildTree( geo, options );

	let float32Array;
	let uint32Array;
	let uint16Array;
	const packedRoots = [];
	const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
	for ( let i = 0; i < roots.length; i ++ ) {

		const root = roots[ i ];
		let nodeCount = countNodes( root );

		const buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );
		float32Array = new Float32Array( buffer );
		uint32Array = new Uint32Array( buffer );
		uint16Array = new Uint16Array( buffer );
		populateBuffer( 0, root );
		packedRoots.push( buffer );

	}

	return packedRoots;

	function countNodes( node ) {

		if ( node.count ) {

			return 1;

		} else {

			return 1 + countNodes( node.left ) + countNodes( node.right );

		}

	}

	function populateBuffer( byteOffset, node ) {

		const stride4Offset = byteOffset / 4;
		const stride2Offset = byteOffset / 2;
		const isLeaf = ! ! node.count;
		const boundingData = node.boundingData;
		for ( let i = 0; i < 6; i ++ ) {

			float32Array[ stride4Offset + i ] = boundingData[ i ];

		}

		if ( isLeaf ) {

			const offset = node.offset;
			const count = node.count;
			uint32Array[ stride4Offset + 6 ] = offset;
			uint16Array[ stride2Offset + 14 ] = count;
			uint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;
			return byteOffset + BYTES_PER_NODE;

		} else {

			const left = node.left;
			const right = node.right;
			const splitAxis = node.splitAxis;

			let nextUnusedPointer;
			nextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );

			if ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {

				throw new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );

			}

			uint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;
			nextUnusedPointer = populateBuffer( nextUnusedPointer, right );

			uint32Array[ stride4Offset + 7 ] = splitAxis;
			return nextUnusedPointer;

		}

	}

}

class SeparatingAxisBounds {

	constructor() {

		this.min = Infinity;
		this.max = - Infinity;

	}

	setFromPointsField( points, field ) {

		let min = Infinity;
		let max = - Infinity;
		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const p = points[ i ];
			const val = p[ field ];
			min = val < min ? val : min;
			max = val > max ? val : max;

		}

		this.min = min;
		this.max = max;

	}

	setFromPoints( axis, points ) {

		let min = Infinity;
		let max = - Infinity;
		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const p = points[ i ];
			const val = axis.dot( p );
			min = val < min ? val : min;
			max = val > max ? val : max;

		}

		this.min = min;
		this.max = max;

	}

	isSeparated( other ) {

		return this.min > other.max || other.min > this.max;

	}

}

SeparatingAxisBounds.prototype.setFromBox = ( function () {

	const p = new Vector3();
	return function setFromBox( axis, box ) {

		const boxMin = box.min;
		const boxMax = box.max;
		let min = Infinity;
		let max = - Infinity;
		for ( let x = 0; x <= 1; x ++ ) {

			for ( let y = 0; y <= 1; y ++ ) {

				for ( let z = 0; z <= 1; z ++ ) {

					p.x = boxMin.x * x + boxMax.x * ( 1 - x );
					p.y = boxMin.y * y + boxMax.y * ( 1 - y );
					p.z = boxMin.z * z + boxMax.z * ( 1 - z );

					const val = axis.dot( p );
					min = Math.min( val, min );
					max = Math.max( val, max );

				}

			}

		}

		this.min = min;
		this.max = max;

	};

} )();

( (function () {

	const cacheSatBounds = new SeparatingAxisBounds();
	return function areIntersecting( shape1, shape2 ) {

		const points1 = shape1.points;
		const satAxes1 = shape1.satAxes;
		const satBounds1 = shape1.satBounds;

		const points2 = shape2.points;
		const satAxes2 = shape2.satAxes;
		const satBounds2 = shape2.satBounds;

		// check axes of the first shape
		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds1[ i ];
			const sa = satAxes1[ i ];
			cacheSatBounds.setFromPoints( sa, points2 );
			if ( sb.isSeparated( cacheSatBounds ) ) return false;

		}

		// check axes of the second shape
		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds2[ i ];
			const sa = satAxes2[ i ];
			cacheSatBounds.setFromPoints( sa, points1 );
			if ( sb.isSeparated( cacheSatBounds ) ) return false;

		}

	};

}) )();

const closestPointLineToLine = ( function () {

	// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56
	const dir1 = new Vector3();
	const dir2 = new Vector3();
	const v02 = new Vector3();
	return function closestPointLineToLine( l1, l2, result ) {

		const v0 = l1.start;
		const v10 = dir1;
		const v2 = l2.start;
		const v32 = dir2;

		v02.subVectors( v0, v2 );
		dir1.subVectors( l1.end, l2.start );
		dir2.subVectors( l2.end, l2.start );

		// float d0232 = v02.Dot(v32);
		const d0232 = v02.dot( v32 );

		// float d3210 = v32.Dot(v10);
		const d3210 = v32.dot( v10 );

		// float d3232 = v32.Dot(v32);
		const d3232 = v32.dot( v32 );

		// float d0210 = v02.Dot(v10);
		const d0210 = v02.dot( v10 );

		// float d1010 = v10.Dot(v10);
		const d1010 = v10.dot( v10 );

		// float denom = d1010*d3232 - d3210*d3210;
		const denom = d1010 * d3232 - d3210 * d3210;

		let d, d2;
		if ( denom !== 0 ) {

			d = ( d0232 * d3210 - d0210 * d3232 ) / denom;

		} else {

			d = 0;

		}

		d2 = ( d0232 + d * d3210 ) / d3232;

		result.x = d;
		result.y = d2;

	};

} )();

const closestPointsSegmentToSegment = ( function () {

	// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187
	const paramResult = new Vector2();
	const temp1 = new Vector3();
	const temp2 = new Vector3();
	return function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {

		closestPointLineToLine( l1, l2, paramResult );

		let d = paramResult.x;
		let d2 = paramResult.y;
		if ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {

			l1.at( d, target1 );
			l2.at( d2, target2 );

			return;

		} else if ( d >= 0 && d <= 1 ) {

			// Only d2 is out of bounds.
			if ( d2 < 0 ) {

				l2.at( 0, target2 );

			} else {

				l2.at( 1, target2 );

			}

			l1.closestPointToPoint( target2, true, target1 );
			return;

		} else if ( d2 >= 0 && d2 <= 1 ) {

			// Only d is out of bounds.
			if ( d < 0 ) {

				l1.at( 0, target1 );

			} else {

				l1.at( 1, target1 );

			}

			l2.closestPointToPoint( target1, true, target2 );
			return;

		} else {

			// Both u and u2 are out of bounds.
			let p;
			if ( d < 0 ) {

				p = l1.start;

			} else {

				p = l1.end;

			}

			let p2;
			if ( d2 < 0 ) {

				p2 = l2.start;

			} else {

				p2 = l2.end;

			}

			const closestPoint = temp1;
			const closestPoint2 = temp2;
			l1.closestPointToPoint( p2, true, temp1 );
			l2.closestPointToPoint( p, true, temp2 );

			if ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {

				target1.copy( closestPoint );
				target2.copy( p2 );
				return;

			} else {

				target1.copy( p );
				target2.copy( closestPoint2 );
				return;

			}

		}

	};

} )();


const sphereIntersectTriangle = ( function () {

	// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js
	const closestPointTemp = new Vector3();
	const projectedPointTemp = new Vector3();
	const planeTemp = new Plane();
	const lineTemp = new Line3();
	return function sphereIntersectTriangle( sphere, triangle ) {

		const { radius, center } = sphere;
		const { a, b, c } = triangle;

		// phase 1
		lineTemp.start = a;
		lineTemp.end = b;
		const closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint1.distanceTo( center ) <= radius ) return true;

		lineTemp.start = a;
		lineTemp.end = c;
		const closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint2.distanceTo( center ) <= radius ) return true;

		lineTemp.start = b;
		lineTemp.end = c;
		const closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint3.distanceTo( center ) <= radius ) return true;

		// phase 2
		const plane = triangle.getPlane( planeTemp );
		const dp = Math.abs( plane.distanceToPoint( center ) );
		if ( dp <= radius ) {

			const pp = plane.projectPoint( center, projectedPointTemp );
			const cp = triangle.containsPoint( pp );
			if ( cp ) return true;

		}

		return false;

	};

} )();

const DIST_EPSILON = 1e-15;
function isNearZero( value ) {

	return Math.abs( value ) < DIST_EPSILON;

}

class ExtendedTriangle extends Triangle {

	constructor( ...args ) {

		super( ...args );

		this.isExtendedTriangle = true;
		this.satAxes = new Array( 4 ).fill().map( () => new Vector3() );
		this.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );
		this.points = [ this.a, this.b, this.c ];
		this.sphere = new Sphere();
		this.plane = new Plane();
		this.needsUpdate = true;

	}

	intersectsSphere( sphere ) {

		return sphereIntersectTriangle( sphere, this );

	}

	update() {

		const a = this.a;
		const b = this.b;
		const c = this.c;
		const points = this.points;

		const satAxes = this.satAxes;
		const satBounds = this.satBounds;

		const axis0 = satAxes[ 0 ];
		const sab0 = satBounds[ 0 ];
		this.getNormal( axis0 );
		sab0.setFromPoints( axis0, points );

		const axis1 = satAxes[ 1 ];
		const sab1 = satBounds[ 1 ];
		axis1.subVectors( a, b );
		sab1.setFromPoints( axis1, points );

		const axis2 = satAxes[ 2 ];
		const sab2 = satBounds[ 2 ];
		axis2.subVectors( b, c );
		sab2.setFromPoints( axis2, points );

		const axis3 = satAxes[ 3 ];
		const sab3 = satBounds[ 3 ];
		axis3.subVectors( c, a );
		sab3.setFromPoints( axis3, points );

		this.sphere.setFromPoints( this.points );
		this.plane.setFromNormalAndCoplanarPoint( axis0, a );
		this.needsUpdate = false;

	}

}

ExtendedTriangle.prototype.closestPointToSegment = ( function () {

	const point1 = new Vector3();
	const point2 = new Vector3();
	const edge = new Line3();

	return function distanceToSegment( segment, target1 = null, target2 = null ) {

		const { start, end } = segment;
		const points = this.points;
		let distSq;
		let closestDistanceSq = Infinity;

		// check the triangle edges
		for ( let i = 0; i < 3; i ++ ) {

			const nexti = ( i + 1 ) % 3;
			edge.start.copy( points[ i ] );
			edge.end.copy( points[ nexti ] );

			closestPointsSegmentToSegment( edge, segment, point1, point2 );

			distSq = point1.distanceToSquared( point2 );
			if ( distSq < closestDistanceSq ) {

				closestDistanceSq = distSq;
				if ( target1 ) target1.copy( point1 );
				if ( target2 ) target2.copy( point2 );

			}

		}

		// check end points
		this.closestPointToPoint( start, point1 );
		distSq = start.distanceToSquared( point1 );
		if ( distSq < closestDistanceSq ) {

			closestDistanceSq = distSq;
			if ( target1 ) target1.copy( point1 );
			if ( target2 ) target2.copy( start );

		}

		this.closestPointToPoint( end, point1 );
		distSq = end.distanceToSquared( point1 );
		if ( distSq < closestDistanceSq ) {

			closestDistanceSq = distSq;
			if ( target1 ) target1.copy( point1 );
			if ( target2 ) target2.copy( end );

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();

ExtendedTriangle.prototype.intersectsTriangle = ( function () {

	const saTri2 = new ExtendedTriangle();
	const arr1 = new Array( 3 );
	const arr2 = new Array( 3 );
	const cachedSatBounds = new SeparatingAxisBounds();
	const cachedSatBounds2 = new SeparatingAxisBounds();
	const cachedAxis = new Vector3();
	const dir1 = new Vector3();
	const dir2 = new Vector3();
	const tempDir = new Vector3();
	const edge = new Line3();
	const edge1 = new Line3();
	const edge2 = new Line3();

	// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least
	// be a line contained by both triangles if not a different special case somehow represented in the return result.
	return function intersectsTriangle( other, target = null ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		if ( ! other.isExtendedTriangle ) {

			saTri2.copy( other );
			saTri2.update();
			other = saTri2;

		} else if ( other.needsUpdate ) {

			other.update();

		}

		const plane1 = this.plane;
		const plane2 = other.plane;

		if ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {

			// perform separating axis intersection test only for coplanar triangles
			const satBounds1 = this.satBounds;
			const satAxes1 = this.satAxes;
			arr2[ 0 ] = other.a;
			arr2[ 1 ] = other.b;
			arr2[ 2 ] = other.c;
			for ( let i = 0; i < 4; i ++ ) {

				const sb = satBounds1[ i ];
				const sa = satAxes1[ i ];
				cachedSatBounds.setFromPoints( sa, arr2 );
				if ( sb.isSeparated( cachedSatBounds ) ) return false;

			}

			const satBounds2 = other.satBounds;
			const satAxes2 = other.satAxes;
			arr1[ 0 ] = this.a;
			arr1[ 1 ] = this.b;
			arr1[ 2 ] = this.c;
			for ( let i = 0; i < 4; i ++ ) {

				const sb = satBounds2[ i ];
				const sa = satAxes2[ i ];
				cachedSatBounds.setFromPoints( sa, arr1 );
				if ( sb.isSeparated( cachedSatBounds ) ) return false;

			}

			// check crossed axes
			for ( let i = 0; i < 4; i ++ ) {

				const sa1 = satAxes1[ i ];
				for ( let i2 = 0; i2 < 4; i2 ++ ) {

					const sa2 = satAxes2[ i2 ];
					cachedAxis.crossVectors( sa1, sa2 );
					cachedSatBounds.setFromPoints( cachedAxis, arr1 );
					cachedSatBounds2.setFromPoints( cachedAxis, arr2 );
					if ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;

				}

			}

			if ( target ) {

				// TODO find two points that intersect on the edges and make that the result
				console.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );

				target.start.set( 0, 0, 0 );
				target.end.set( 0, 0, 0 );

			}

			return true;

		} else {

			// find the edge that intersects the other triangle plane
			const points1 = this.points;
			let found1 = false;
			let count1 = 0;
			for ( let i = 0; i < 3; i ++ ) {

				const p = points1[ i ];
				const pNext = points1[ ( i + 1 ) % 3 ];

				edge.start.copy( p );
				edge.end.copy( pNext );
				edge.delta( dir1 );

				const targetPoint = found1 ? edge1.start : edge1.end;
				const startIntersects = isNearZero( plane2.distanceToPoint( p ) );
				if ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {

					// if the edge lies on the plane then take the line
					edge1.copy( edge );
					count1 = 2;
					break;

				}

				// check if the start point is near the plane because "intersectLine" is not robust to that case
				const doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;
				if ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {

					count1 ++;
					if ( found1 ) {

						break;

					}

					found1 = true;

				}

			}

			if ( count1 === 1 && this.containsPoint( edge1.start ) ) {

				if ( target ) {

					target.start.copy( edge1.start );
					target.end.copy( edge1.start );

				}

				return true;

			} else if ( count1 !== 2 ) {

				return false;

			}

			// find the other triangles edge that intersects this plane
			const points2 = other.points;
			let found2 = false;
			let count2 = 0;
			for ( let i = 0; i < 3; i ++ ) {

				const p = points2[ i ];
				const pNext = points2[ ( i + 1 ) % 3 ];

				edge.start.copy( p );
				edge.end.copy( pNext );
				edge.delta( dir2 );

				const targetPoint = found2 ? edge2.start : edge2.end;
				const startIntersects = isNearZero( plane1.distanceToPoint( p ) );
				if ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {

					// if the edge lies on the plane then take the line
					edge2.copy( edge );
					count2 = 2;
					break;

				}

				// check if the start point is near the plane because "intersectLine" is not robust to that case
				const doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;
				if ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {

					count2 ++;
					if ( found2 ) {

						break;

					}

					found2 = true;

				}

			}

			if ( count2 === 1 && this.containsPoint( edge2.start ) ) {

				if ( target ) {

					target.start.copy( edge2.start );
					target.end.copy( edge2.start );

				}

				return true;

			} else if ( count2 !== 2 ) {

				return false;

			}

			// find swap the second edge so both lines are running the same direction
			edge1.delta( dir1 );
			edge2.delta( dir2 );

			if ( dir1.dot( dir2 ) < 0 ) {

				let tmp = edge2.start;
				edge2.start = edge2.end;
				edge2.end = tmp;

			}

			// check if the edges are overlapping
			const s1 = edge1.start.dot( dir1 );
			const e1 = edge1.end.dot( dir1 );
			const s2 = edge2.start.dot( dir1 );
			const e2 = edge2.end.dot( dir1 );
			const separated1 = e1 < s2;
			const separated2 = s1 < e2;

			if ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {

				return false;

			}

			// assign the target output
			if ( target ) {

				tempDir.subVectors( edge1.start, edge2.start );
				if ( tempDir.dot( dir1 ) > 0 ) {

					target.start.copy( edge1.start );

				} else {

					target.start.copy( edge2.start );

				}

				tempDir.subVectors( edge1.end, edge2.end );
				if ( tempDir.dot( dir1 ) < 0 ) {

					target.end.copy( edge1.end );

				} else {

					target.end.copy( edge2.end );

				}

			}

			return true;

		}

	};

} )();


ExtendedTriangle.prototype.distanceToPoint = ( function () {

	const target = new Vector3();
	return function distanceToPoint( point ) {

		this.closestPointToPoint( point, target );
		return point.distanceTo( target );

	};

} )();


ExtendedTriangle.prototype.distanceToTriangle = ( function () {

	const point = new Vector3();
	const point2 = new Vector3();
	const cornerFields = [ 'a', 'b', 'c' ];
	const line1 = new Line3();
	const line2 = new Line3();

	return function distanceToTriangle( other, target1 = null, target2 = null ) {

		const lineTarget = target1 || target2 ? line1 : null;
		if ( this.intersectsTriangle( other, lineTarget ) ) {

			if ( target1 || target2 ) {

				if ( target1 ) lineTarget.getCenter( target1 );
				if ( target2 ) lineTarget.getCenter( target2 );

			}

			return 0;

		}

		let closestDistanceSq = Infinity;

		// check all point distances
		for ( let i = 0; i < 3; i ++ ) {

			let dist;
			const field = cornerFields[ i ];
			const otherVec = other[ field ];
			this.closestPointToPoint( otherVec, point );

			dist = otherVec.distanceToSquared( point );

			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( point );
				if ( target2 ) target2.copy( otherVec );

			}


			const thisVec = this[ field ];
			other.closestPointToPoint( thisVec, point );

			dist = thisVec.distanceToSquared( point );

			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( thisVec );
				if ( target2 ) target2.copy( point );

			}

		}

		for ( let i = 0; i < 3; i ++ ) {

			const f11 = cornerFields[ i ];
			const f12 = cornerFields[ ( i + 1 ) % 3 ];
			line1.set( this[ f11 ], this[ f12 ] );
			for ( let i2 = 0; i2 < 3; i2 ++ ) {

				const f21 = cornerFields[ i2 ];
				const f22 = cornerFields[ ( i2 + 1 ) % 3 ];
				line2.set( other[ f21 ], other[ f22 ] );

				closestPointsSegmentToSegment( line1, line2, point, point2 );

				const dist = point.distanceToSquared( point2 );
				if ( dist < closestDistanceSq ) {

					closestDistanceSq = dist;
					if ( target1 ) target1.copy( point );
					if ( target2 ) target2.copy( point2 );

				}

			}

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();

class OrientedBox extends Box3 {

	constructor( ...args ) {

		super( ...args );

		this.isOrientedBox = true;
		this.matrix = new Matrix4();
		this.invMatrix = new Matrix4();
		this.points = new Array( 8 ).fill().map( () => new Vector3() );
		this.satAxes = new Array( 3 ).fill().map( () => new Vector3() );
		this.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );
		this.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );
		this.needsUpdate = false;

	}

	set( min, max, matrix ) {

		super.set( min, max );
		this.matrix.copy( matrix );
		this.needsUpdate = true;

	}

	copy( other ) {

		super.copy( other );
		this.matrix.copy( other.matrix );
		this.needsUpdate = true;

	}

}

OrientedBox.prototype.update = ( function () {

	return function update() {

		const matrix = this.matrix;
		const min = this.min;
		const max = this.max;

		const points = this.points;
		for ( let x = 0; x <= 1; x ++ ) {

			for ( let y = 0; y <= 1; y ++ ) {

				for ( let z = 0; z <= 1; z ++ ) {

					const i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );
					const v = points[ i ];
					v.x = x ? max.x : min.x;
					v.y = y ? max.y : min.y;
					v.z = z ? max.z : min.z;

					v.applyMatrix4( matrix );

				}

			}

		}

		const satBounds = this.satBounds;
		const satAxes = this.satAxes;
		const minVec = points[ 0 ];
		for ( let i = 0; i < 3; i ++ ) {

			const axis = satAxes[ i ];
			const sb = satBounds[ i ];
			const index = 1 << i;
			const pi = points[ index ];

			axis.subVectors( minVec, pi );
			sb.setFromPoints( axis, points );

		}

		const alignedSatBounds = this.alignedSatBounds;
		alignedSatBounds[ 0 ].setFromPointsField( points, 'x' );
		alignedSatBounds[ 1 ].setFromPointsField( points, 'y' );
		alignedSatBounds[ 2 ].setFromPointsField( points, 'z' );

		this.invMatrix.copy( this.matrix ).invert();
		this.needsUpdate = false;

	};

} )();

OrientedBox.prototype.intersectsBox = ( function () {

	const aabbBounds = new SeparatingAxisBounds();
	return function intersectsBox( box ) {

		// TODO: should this be doing SAT against the AABB?
		if ( this.needsUpdate ) {

			this.update();

		}

		const min = box.min;
		const max = box.max;
		const satBounds = this.satBounds;
		const satAxes = this.satAxes;
		const alignedSatBounds = this.alignedSatBounds;

		aabbBounds.min = min.x;
		aabbBounds.max = max.x;
		if ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;

		aabbBounds.min = min.y;
		aabbBounds.max = max.y;
		if ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;

		aabbBounds.min = min.z;
		aabbBounds.max = max.z;
		if ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;

		for ( let i = 0; i < 3; i ++ ) {

			const axis = satAxes[ i ];
			const sb = satBounds[ i ];
			aabbBounds.setFromBox( axis, box );
			if ( sb.isSeparated( aabbBounds ) ) return false;

		}

		return true;

	};

} )();

OrientedBox.prototype.intersectsTriangle = ( function () {

	const saTri = new ExtendedTriangle();
	const pointsArr = new Array( 3 );
	const cachedSatBounds = new SeparatingAxisBounds();
	const cachedSatBounds2 = new SeparatingAxisBounds();
	const cachedAxis = new Vector3();
	return function intersectsTriangle( triangle ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		if ( ! triangle.isExtendedTriangle ) {

			saTri.copy( triangle );
			saTri.update();
			triangle = saTri;

		} else if ( triangle.needsUpdate ) {

			triangle.update();

		}

		const satBounds = this.satBounds;
		const satAxes = this.satAxes;

		pointsArr[ 0 ] = triangle.a;
		pointsArr[ 1 ] = triangle.b;
		pointsArr[ 2 ] = triangle.c;

		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds[ i ];
			const sa = satAxes[ i ];
			cachedSatBounds.setFromPoints( sa, pointsArr );
			if ( sb.isSeparated( cachedSatBounds ) ) return false;

		}

		const triSatBounds = triangle.satBounds;
		const triSatAxes = triangle.satAxes;
		const points = this.points;
		for ( let i = 0; i < 3; i ++ ) {

			const sb = triSatBounds[ i ];
			const sa = triSatAxes[ i ];
			cachedSatBounds.setFromPoints( sa, points );
			if ( sb.isSeparated( cachedSatBounds ) ) return false;

		}

		// check crossed axes
		for ( let i = 0; i < 3; i ++ ) {

			const sa1 = satAxes[ i ];
			for ( let i2 = 0; i2 < 4; i2 ++ ) {

				const sa2 = triSatAxes[ i2 ];
				cachedAxis.crossVectors( sa1, sa2 );
				cachedSatBounds.setFromPoints( cachedAxis, pointsArr );
				cachedSatBounds2.setFromPoints( cachedAxis, points );
				if ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;

			}

		}

		return true;

	};

} )();

OrientedBox.prototype.closestPointToPoint = ( function () {

	return function closestPointToPoint( point, target1 ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		target1
			.copy( point )
			.applyMatrix4( this.invMatrix )
			.clamp( this.min, this.max )
			.applyMatrix4( this.matrix );

		return target1;

	};

} )();

OrientedBox.prototype.distanceToPoint = ( function () {

	const target = new Vector3();
	return function distanceToPoint( point ) {

		this.closestPointToPoint( point, target );
		return point.distanceTo( target );

	};

} )();

OrientedBox.prototype.distanceToBox = ( function () {

	const xyzFields = [ 'x', 'y', 'z' ];
	const segments1 = new Array( 12 ).fill().map( () => new Line3() );
	const segments2 = new Array( 12 ).fill().map( () => new Line3() );

	const point1 = new Vector3();
	const point2 = new Vector3();

	// early out if we find a value below threshold
	return function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		if ( this.intersectsBox( box ) ) {

			if ( target1 || target2 ) {

				box.getCenter( point2 );
				this.closestPointToPoint( point2, point1 );
				box.closestPointToPoint( point1, point2 );

				if ( target1 ) target1.copy( point1 );
				if ( target2 ) target2.copy( point2 );

			}

			return 0;

		}

		const threshold2 = threshold * threshold;
		const min = box.min;
		const max = box.max;
		const points = this.points;


		// iterate over every edge and compare distances
		let closestDistanceSq = Infinity;

		// check over all these points
		for ( let i = 0; i < 8; i ++ ) {

			const p = points[ i ];
			point2.copy( p ).clamp( min, max );

			const dist = p.distanceToSquared( point2 );
			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( p );
				if ( target2 ) target2.copy( point2 );

				if ( dist < threshold2 ) return Math.sqrt( dist );

			}

		}

		// generate and check all line segment distances
		let count = 0;
		for ( let i = 0; i < 3; i ++ ) {

			for ( let i1 = 0; i1 <= 1; i1 ++ ) {

				for ( let i2 = 0; i2 <= 1; i2 ++ ) {

					const nextIndex = ( i + 1 ) % 3;
					const nextIndex2 = ( i + 2 ) % 3;

					// get obb line segments
					const index = i1 << nextIndex | i2 << nextIndex2;
					const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
					const p1 = points[ index ];
					const p2 = points[ index2 ];
					const line1 = segments1[ count ];
					line1.set( p1, p2 );


					// get aabb line segments
					const f1 = xyzFields[ i ];
					const f2 = xyzFields[ nextIndex ];
					const f3 = xyzFields[ nextIndex2 ];
					const line2 = segments2[ count ];
					const start = line2.start;
					const end = line2.end;

					start[ f1 ] = min[ f1 ];
					start[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];
					start[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];

					end[ f1 ] = max[ f1 ];
					end[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];
					end[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];

					count ++;

				}

			}

		}

		// check all the other boxes point
		for ( let x = 0; x <= 1; x ++ ) {

			for ( let y = 0; y <= 1; y ++ ) {

				for ( let z = 0; z <= 1; z ++ ) {

					point2.x = x ? max.x : min.x;
					point2.y = y ? max.y : min.y;
					point2.z = z ? max.z : min.z;

					this.closestPointToPoint( point2, point1 );
					const dist = point2.distanceToSquared( point1 );
					if ( dist < closestDistanceSq ) {

						closestDistanceSq = dist;
						if ( target1 ) target1.copy( point1 );
						if ( target2 ) target2.copy( point2 );

						if ( dist < threshold2 ) return Math.sqrt( dist );

					}

				}

			}

		}

		for ( let i = 0; i < 12; i ++ ) {

			const l1 = segments1[ i ];
			for ( let i2 = 0; i2 < 12; i2 ++ ) {

				const l2 = segments2[ i2 ];
				closestPointsSegmentToSegment( l1, l2, point1, point2 );
				const dist = point1.distanceToSquared( point2 );
				if ( dist < closestDistanceSq ) {

					closestDistanceSq = dist;
					if ( target1 ) target1.copy( point1 );
					if ( target2 ) target2.copy( point2 );

					if ( dist < threshold2 ) return Math.sqrt( dist );

				}

			}

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();

// Ripped and modified From THREE.js Mesh raycast
// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115
const vA = /* @__PURE__ */ new Vector3();
const vB = /* @__PURE__ */ new Vector3();
const vC = /* @__PURE__ */ new Vector3();

const uvA = /* @__PURE__ */ new Vector2();
const uvB = /* @__PURE__ */ new Vector2();
const uvC = /* @__PURE__ */ new Vector2();

const intersectionPoint = /* @__PURE__ */ new Vector3();
function checkIntersection( ray, pA, pB, pC, point, side ) {

	let intersect;
	if ( side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	const distance = ray.origin.distanceTo( point );

	return {

		distance: distance,
		point: point.clone(),

	};

}

function checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {

	vA.fromBufferAttribute( position, a );
	vB.fromBufferAttribute( position, b );
	vC.fromBufferAttribute( position, c );

	const intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );

	if ( intersection ) {

		if ( uv ) {

			uvA.fromBufferAttribute( uv, a );
			uvB.fromBufferAttribute( uv, b );
			uvC.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( vA, vB, vC, face.normal );

		intersection.face = face;
		intersection.faceIndex = a;

	}

	return intersection;

}

// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258
function intersectTri( geo, side, ray, tri, intersections ) {

	const triOffset = tri * 3;
	const a = geo.index.getX( triOffset );
	const b = geo.index.getX( triOffset + 1 );
	const c = geo.index.getX( triOffset + 2 );

	const intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );

	if ( intersection ) {

		intersection.faceIndex = tri;
		if ( intersections ) intersections.push( intersection );
		return intersection;

	}

	return null;

}

function intersectTris( geo, side, ray, offset, count, intersections ) {

	for ( let i = offset, end = offset + count; i < end; i ++ ) {

		intersectTri( geo, side, ray, i, intersections );

	}

}

function intersectClosestTri( geo, side, ray, offset, count ) {

	let dist = Infinity;
	let res = null;
	for ( let i = offset, end = offset + count; i < end; i ++ ) {

		const intersection = intersectTri( geo, side, ray, i );
		if ( intersection && intersection.distance < dist ) {

			res = intersection;
			dist = intersection.distance;

		}

	}

	return res;

}

// converts the given BVH raycast intersection to align with the three.js raycast
// structure (include object, world space distance and point).
function convertRaycastIntersect( hit, object, raycaster ) {

	if ( hit === null ) {

		return null;

	}

	hit.point.applyMatrix4( object.matrixWorld );
	hit.distance = hit.point.distanceTo( raycaster.ray.origin );
	hit.object = object;

	if ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {

		return null;

	} else {

		return hit;

	}

}

// sets the vertices of triangle `tri` with the 3 vertices after i
function setTriangle( tri, i, index, pos ) {

	const ta = tri.a;
	const tb = tri.b;
	const tc = tri.c;

	let i0 = i;
	let i1 = i + 1;
	let i2 = i + 2;
	if ( index ) {

		i0 = index.getX( i );
		i1 = index.getX( i + 1 );
		i2 = index.getX( i + 2 );

	}

	ta.x = pos.getX( i0 );
	ta.y = pos.getY( i0 );
	ta.z = pos.getZ( i0 );

	tb.x = pos.getX( i1 );
	tb.y = pos.getY( i1 );
	tb.z = pos.getZ( i1 );

	tc.x = pos.getX( i2 );
	tc.y = pos.getY( i2 );
	tc.z = pos.getZ( i2 );

}

function iterateOverTriangles(
	offset,
	count,
	geometry,
	intersectsTriangleFunc,
	contained,
	depth,
	triangle
) {

	const index = geometry.index;
	const pos = geometry.attributes.position;
	for ( let i = offset, l = count + offset; i < l; i ++ ) {

		setTriangle( triangle, i * 3, index, pos );
		triangle.needsUpdate = true;

		if ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {

			return true;

		}

	}

	return false;

}

class PrimitivePool {

	constructor( getNewPrimitive ) {

		this._getNewPrimitive = getNewPrimitive;
		this._primitives = [];

	}

	getPrimitive() {

		const primitives = this._primitives;
		if ( primitives.length === 0 ) {

			return this._getNewPrimitive();

		} else {

			return primitives.pop();

		}

	}

	releasePrimitive( primitive ) {

		this._primitives.push( primitive );

	}

}

function IS_LEAF( n16, uint16Array ) {

	return uint16Array[ n16 + 15 ] === 0xFFFF;

}

function OFFSET( n32, uint32Array ) {

	return uint32Array[ n32 + 6 ];

}

function COUNT( n16, uint16Array ) {

	return uint16Array[ n16 + 14 ];

}

function LEFT_NODE( n32 ) {

	return n32 + 8;

}

function RIGHT_NODE( n32, uint32Array ) {

	return uint32Array[ n32 + 6 ];

}

function SPLIT_AXIS( n32, uint32Array ) {

	return uint32Array[ n32 + 7 ];

}

function BOUNDING_DATA_INDEX( n32 ) {

	return n32;

}

const boundingBox = new Box3();
const boxIntersection = new Vector3();
const xyzFields = [ 'x', 'y', 'z' ];

function raycast( nodeIndex32, geometry, side, ray, intersects ) {

	let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

	const isLeaf = IS_LEAF( nodeIndex16, uint16Array );
	if ( isLeaf ) {

		const offset = OFFSET( nodeIndex32, uint32Array );
		const count = COUNT( nodeIndex16, uint16Array );

		intersectTris( geometry, side, ray, offset, count, intersects );

	} else {

		const leftIndex = LEFT_NODE( nodeIndex32 );
		if ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {

			raycast( leftIndex, geometry, side, ray, intersects );

		}

		const rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );
		if ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {

			raycast( rightIndex, geometry, side, ray, intersects );

		}

	}

}

function raycastFirst( nodeIndex32, geometry, side, ray ) {

	let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

	const isLeaf = IS_LEAF( nodeIndex16, uint16Array );
	if ( isLeaf ) {

		const offset = OFFSET( nodeIndex32, uint32Array );
		const count = COUNT( nodeIndex16, uint16Array );
		return intersectClosestTri( geometry, side, ray, offset, count );

	} else {

		// consider the position of the split plane with respect to the oncoming ray; whichever direction
		// the ray is coming from, look for an intersection among that side of the tree first
		const splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );
		const xyzAxis = xyzFields[ splitAxis ];
		const rayDir = ray.direction[ xyzAxis ];
		const leftToRight = rayDir >= 0;

		// c1 is the child to check first
		let c1, c2;
		if ( leftToRight ) {

			c1 = LEFT_NODE( nodeIndex32 );
			c2 = RIGHT_NODE( nodeIndex32, uint32Array );

		} else {

			c1 = RIGHT_NODE( nodeIndex32, uint32Array );
			c2 = LEFT_NODE( nodeIndex32 );

		}

		const c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );
		const c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;

		// if we got an intersection in the first node and it's closer than the second node's bounding
		// box, we don't need to consider the second node because it couldn't possibly be a better result
		if ( c1Result ) {

			// check if the point is within the second bounds
			// "point" is in the local frame of the bvh
			const point = c1Result.point[ xyzAxis ];
			const isOutside = leftToRight ?
				point <= float32Array[ c2 + splitAxis ] : // min bounding data
				point >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data

			if ( isOutside ) {

				return c1Result;

			}

		}

		// either there was no intersection in the first node, or there could still be a closer
		// intersection in the second, so check the second node and then take the better of the two
		const c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );
		const c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;

		if ( c1Result && c2Result ) {

			return c1Result.distance <= c2Result.distance ? c1Result : c2Result;

		} else {

			return c1Result || c2Result || null;

		}

	}

}

const shapecast = ( function () {

	let _box1, _box2;
	const boxStack = [];
	const boxPool = new PrimitivePool( () => new Box3() );

	return function shapecast( ...args ) {

		_box1 = boxPool.getPrimitive();
		_box2 = boxPool.getPrimitive();
		boxStack.push( _box1, _box2 );

		const result = shapecastTraverse( ...args );

		boxPool.releasePrimitive( _box1 );
		boxPool.releasePrimitive( _box2 );
		boxStack.pop();
		boxStack.pop();

		const length = boxStack.length;
		if ( length > 0 ) {

			_box2 = boxStack[ length - 1 ];
			_box1 = boxStack[ length - 2 ];

		}

		return result;

	};

	function shapecastTraverse(
		nodeIndex32,
		geometry,
		intersectsBoundsFunc,
		intersectsRangeFunc,
		nodeScoreFunc = null,
		nodeIndexByteOffset = 0, // offset for unique node identifier
		depth = 0
	) {

		// Define these inside the function so it has access to the local variables needed
		// when converting to the buffer equivalents
		function getLeftOffset( nodeIndex32 ) {

			let nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;

			// traverse until we find a leaf
			while ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {

				nodeIndex32 = LEFT_NODE( nodeIndex32 );
				nodeIndex16 = nodeIndex32 * 2;

			}

			return OFFSET( nodeIndex32, uint32Array );

		}

		function getRightEndOffset( nodeIndex32 ) {

			let nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;

			// traverse until we find a leaf
			while ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {

				// adjust offset to point to the right node
				nodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );
				nodeIndex16 = nodeIndex32 * 2;

			}

			// return the end offset of the triangle range
			return OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );

		}

		let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

		const isLeaf = IS_LEAF( nodeIndex16, uint16Array );
		if ( isLeaf ) {

			const offset = OFFSET( nodeIndex32, uint32Array );
			const count = COUNT( nodeIndex16, uint16Array );
			arrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );
			return intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );

		} else {

			const left = LEFT_NODE( nodeIndex32 );
			const right = RIGHT_NODE( nodeIndex32, uint32Array );
			let c1 = left;
			let c2 = right;

			let score1, score2;
			let box1, box2;
			if ( nodeScoreFunc ) {

				box1 = _box1;
				box2 = _box2;

				// bounding data is not offset
				arrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );
				arrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );

				score1 = nodeScoreFunc( box1 );
				score2 = nodeScoreFunc( box2 );

				if ( score2 < score1 ) {

					c1 = right;
					c2 = left;

					const temp = score1;
					score1 = score2;
					score2 = temp;

					box1 = box2;
					// box2 is always set before use below

				}

			}

			// Check box 1 intersection
			if ( ! box1 ) {

				box1 = _box1;
				arrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );

			}

			const isC1Leaf = IS_LEAF( c1 * 2, uint16Array );
			const c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );

			let c1StopTraversal;
			if ( c1Intersection === CONTAINED ) {

				const offset = getLeftOffset( c1 );
				const end = getRightEndOffset( c1 );
				const count = end - offset;

				c1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );

			} else {

				c1StopTraversal =
					c1Intersection &&
					shapecastTraverse(
						c1,
						geometry,
						intersectsBoundsFunc,
						intersectsRangeFunc,
						nodeScoreFunc,
						nodeIndexByteOffset,
						depth + 1
					);

			}

			if ( c1StopTraversal ) return true;

			// Check box 2 intersection
			// cached box2 will have been overwritten by previous traversal
			box2 = _box2;
			arrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );

			const isC2Leaf = IS_LEAF( c2 * 2, uint16Array );
			const c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );

			let c2StopTraversal;
			if ( c2Intersection === CONTAINED ) {

				const offset = getLeftOffset( c2 );
				const end = getRightEndOffset( c2 );
				const count = end - offset;

				c2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );

			} else {

				c2StopTraversal =
					c2Intersection &&
					shapecastTraverse(
						c2,
						geometry,
						intersectsBoundsFunc,
						intersectsRangeFunc,
						nodeScoreFunc,
						nodeIndexByteOffset,
						depth + 1
					);

			}

			if ( c2StopTraversal ) return true;

			return false;

		}

	}

} )();

const intersectsGeometry = ( function () {

	const triangle = new ExtendedTriangle();
	const triangle2 = new ExtendedTriangle();
	const invertedMat = new Matrix4();

	const obb = new OrientedBox();
	const obb2 = new OrientedBox();

	return function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {

		let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

		if ( cachedObb === null ) {

			if ( ! otherGeometry.boundingBox ) {

				otherGeometry.computeBoundingBox();

			}

			obb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );
			cachedObb = obb;

		}

		const isLeaf = IS_LEAF( nodeIndex16, uint16Array );
		if ( isLeaf ) {

			const thisGeometry = geometry;
			const thisIndex = thisGeometry.index;
			const thisPos = thisGeometry.attributes.position;

			const index = otherGeometry.index;
			const pos = otherGeometry.attributes.position;

			const offset = OFFSET( nodeIndex32, uint32Array );
			const count = COUNT( nodeIndex16, uint16Array );

			// get the inverse of the geometry matrix so we can transform our triangles into the
			// geometry space we're trying to test. We assume there are fewer triangles being checked
			// here.
			invertedMat.copy( geometryToBvh ).invert();

			if ( otherGeometry.boundsTree ) {

				arrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );
				obb2.matrix.copy( invertedMat );
				obb2.needsUpdate = true;

				const res = otherGeometry.boundsTree.shapecast( {

					intersectsBounds: box => obb2.intersectsBox( box ),

					intersectsTriangle: tri => {

						tri.a.applyMatrix4( geometryToBvh );
						tri.b.applyMatrix4( geometryToBvh );
						tri.c.applyMatrix4( geometryToBvh );
						tri.needsUpdate = true;

						for ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {

							// this triangle needs to be transformed into the current BVH coordinate frame
							setTriangle( triangle2, i, thisIndex, thisPos );
							triangle2.needsUpdate = true;
							if ( tri.intersectsTriangle( triangle2 ) ) {

								return true;

							}

						}

						return false;

					}

				} );

				return res;

			} else {

				for ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {

					// this triangle needs to be transformed into the current BVH coordinate frame
					setTriangle( triangle, i, thisIndex, thisPos );
					triangle.a.applyMatrix4( invertedMat );
					triangle.b.applyMatrix4( invertedMat );
					triangle.c.applyMatrix4( invertedMat );
					triangle.needsUpdate = true;

					for ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {

						setTriangle( triangle2, i2, index, pos );
						triangle2.needsUpdate = true;

						if ( triangle.intersectsTriangle( triangle2 ) ) {

							return true;

						}

					}

				}

			}

		} else {

			const left = nodeIndex32 + 8;
			const right = uint32Array[ nodeIndex32 + 6 ];

			arrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );
			const leftIntersection =
				cachedObb.intersectsBox( boundingBox ) &&
				intersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );

			if ( leftIntersection ) return true;

			arrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );
			const rightIntersection =
				cachedObb.intersectsBox( boundingBox ) &&
				intersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );

			if ( rightIntersection ) return true;

			return false;

		}

	};

} )();

function intersectRay( nodeIndex32, array, ray, target ) {

	arrayToBox( nodeIndex32, array, boundingBox );
	return ray.intersectBox( boundingBox, target );

}

const bufferStack = [];
let _prevBuffer;
let _float32Array;
let _uint16Array;
let _uint32Array;
function setBuffer( buffer ) {

	if ( _prevBuffer ) {

		bufferStack.push( _prevBuffer );

	}

	_prevBuffer = buffer;
	_float32Array = new Float32Array( buffer );
	_uint16Array = new Uint16Array( buffer );
	_uint32Array = new Uint32Array( buffer );

}

function clearBuffer() {

	_prevBuffer = null;
	_float32Array = null;
	_uint16Array = null;
	_uint32Array = null;

	if ( bufferStack.length ) {

		setBuffer( bufferStack.pop() );

	}

}

const SKIP_GENERATION = Symbol( 'skip tree generation' );

const aabb = /* @__PURE__ */ new Box3();
const aabb2 = /* @__PURE__ */ new Box3();
const tempMatrix = /* @__PURE__ */ new Matrix4();
const obb = /* @__PURE__ */ new OrientedBox();
const obb2 = /* @__PURE__ */ new OrientedBox();
const temp = /* @__PURE__ */ new Vector3();
const temp1 = /* @__PURE__ */ new Vector3();
const temp2 = /* @__PURE__ */ new Vector3();
const temp3 = /* @__PURE__ */ new Vector3();
const temp4 = /* @__PURE__ */ new Vector3();
const tempBox = /* @__PURE__ */ new Box3();
const trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );

class MeshBVH {

	static serialize( bvh, options = {} ) {

		if ( options.isBufferGeometry ) {

			console.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );

			return MeshBVH.serialize(
				arguments[ 0 ],
				{
					cloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],
				}
			);

		}

		options = {
			cloneBuffers: true,
			...options,
		};

		const geometry = bvh.geometry;
		const rootData = bvh._roots;
		const indexAttribute = geometry.getIndex();
		let result;
		if ( options.cloneBuffers ) {

			result = {
				roots: rootData.map( root => root.slice() ),
				index: indexAttribute.array.slice(),
			};

		} else {

			result = {
				roots: rootData,
				index: indexAttribute.array,
			};

		}

		return result;

	}

	static deserialize( data, geometry, options = {} ) {

		if ( typeof options === 'boolean' ) {

			console.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );

			return MeshBVH.deserialize(
				arguments[ 0 ],
				arguments[ 1 ],
				{
					setIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],
				}
			);

		}

		options = {
			setIndex: true,
			...options,
		};

		const { index, roots } = data;
		const bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );
		bvh._roots = roots;

		if ( options.setIndex ) {

			const indexAttribute = geometry.getIndex();
			if ( indexAttribute === null ) {

				const newIndex = new BufferAttribute( data.index, 1, false );
				geometry.setIndex( newIndex );

			} else if ( indexAttribute.array !== index ) {

				indexAttribute.array.set( index );
				indexAttribute.needsUpdate = true;

			}

		}

		return bvh;

	}

	constructor( geometry, options = {} ) {

		if ( ! geometry.isBufferGeometry ) {

			throw new Error( 'MeshBVH: Only BufferGeometries are supported.' );

		} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {

			throw new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );

		}

		// default options
		options = Object.assign( {

			strategy: CENTER,
			maxDepth: 40,
			maxLeafTris: 10,
			verbose: true,
			useSharedArrayBuffer: false,
			setBoundingBox: true,
			onProgress: null,

			// undocumented options

			// Whether to skip generating the tree. Used for deserialization.
			[ SKIP_GENERATION ]: false,

		}, options );

		if ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {

			throw new Error( 'MeshBVH: SharedArrayBuffer is not available.' );

		}

		this._roots = null;
		if ( ! options[ SKIP_GENERATION ] ) {

			this._roots = buildPackedTree( geometry, options );

			if ( ! geometry.boundingBox && options.setBoundingBox ) {

				geometry.boundingBox = this.getBoundingBox( new Box3() );

			}

		}

		// retain references to the geometry so we can use them it without having to
		// take a geometry reference in every function.
		this.geometry = geometry;

	}

	refit( nodeIndices = null ) {

		if ( nodeIndices && Array.isArray( nodeIndices ) ) {

			nodeIndices = new Set( nodeIndices );

		}

		const geometry = this.geometry;
		const indexArr = geometry.index.array;
		const posAttr = geometry.attributes.position;
		const posArr = posAttr.array;

		// support for an interleaved position buffer
		const bufferOffset = posAttr.offset || 0;
		let stride = 3;
		if ( posAttr.isInterleavedBufferAttribute ) {

			stride = posAttr.data.stride;

		}

		let buffer, uint32Array, uint16Array, float32Array;
		let byteOffset = 0;
		const roots = this._roots;
		for ( let i = 0, l = roots.length; i < l; i ++ ) {

			buffer = roots[ i ];
			uint32Array = new Uint32Array( buffer );
			uint16Array = new Uint16Array( buffer );
			float32Array = new Float32Array( buffer );

			_traverse( 0, byteOffset );
			byteOffset += buffer.byteLength;

		}

		function _traverse( node32Index, byteOffset, force = false ) {

			const node16Index = node32Index * 2;
			const isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;
			if ( isLeaf ) {

				const offset = uint32Array[ node32Index + 6 ];
				const count = uint16Array[ node16Index + 14 ];

				let minx = Infinity;
				let miny = Infinity;
				let minz = Infinity;
				let maxx = - Infinity;
				let maxy = - Infinity;
				let maxz = - Infinity;
				for ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {

					const index = indexArr[ i ] * stride + bufferOffset;
					const x = posArr[ index + 0 ];
					const y = posArr[ index + 1 ];
					const z = posArr[ index + 2 ];

					if ( x < minx ) minx = x;
					if ( x > maxx ) maxx = x;

					if ( y < miny ) miny = y;
					if ( y > maxy ) maxy = y;

					if ( z < minz ) minz = z;
					if ( z > maxz ) maxz = z;

				}

				if (
					float32Array[ node32Index + 0 ] !== minx ||
					float32Array[ node32Index + 1 ] !== miny ||
					float32Array[ node32Index + 2 ] !== minz ||

					float32Array[ node32Index + 3 ] !== maxx ||
					float32Array[ node32Index + 4 ] !== maxy ||
					float32Array[ node32Index + 5 ] !== maxz
				) {

					float32Array[ node32Index + 0 ] = minx;
					float32Array[ node32Index + 1 ] = miny;
					float32Array[ node32Index + 2 ] = minz;

					float32Array[ node32Index + 3 ] = maxx;
					float32Array[ node32Index + 4 ] = maxy;
					float32Array[ node32Index + 5 ] = maxz;

					return true;

				} else {

					return false;

				}

			} else {

				const left = node32Index + 8;
				const right = uint32Array[ node32Index + 6 ];

				// the identifying node indices provided by the shapecast function include offsets of all
				// root buffers to guarantee they're unique between roots so offset left and right indices here.
				const offsetLeft = left + byteOffset;
				const offsetRight = right + byteOffset;
				let forceChildren = force;
				let includesLeft = false;
				let includesRight = false;

				if ( nodeIndices ) {

					// if we see that neither the left or right child are included in the set that need to be updated
					// then we assume that all children need to be updated.
					if ( ! forceChildren ) {

						includesLeft = nodeIndices.has( offsetLeft );
						includesRight = nodeIndices.has( offsetRight );
						forceChildren = ! includesLeft && ! includesRight;

					}

				} else {

					includesLeft = true;
					includesRight = true;

				}

				const traverseLeft = forceChildren || includesLeft;
				const traverseRight = forceChildren || includesRight;

				let leftChange = false;
				if ( traverseLeft ) {

					leftChange = _traverse( left, byteOffset, forceChildren );

				}

				let rightChange = false;
				if ( traverseRight ) {

					rightChange = _traverse( right, byteOffset, forceChildren );

				}

				const didChange = leftChange || rightChange;
				if ( didChange ) {

					for ( let i = 0; i < 3; i ++ ) {

						const lefti = left + i;
						const righti = right + i;
						const minLeftValue = float32Array[ lefti ];
						const maxLeftValue = float32Array[ lefti + 3 ];
						const minRightValue = float32Array[ righti ];
						const maxRightValue = float32Array[ righti + 3 ];

						float32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
						float32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;

					}

				}

				return didChange;

			}

		}

	}

	traverse( callback, rootIndex = 0 ) {

		const buffer = this._roots[ rootIndex ];
		const uint32Array = new Uint32Array( buffer );
		const uint16Array = new Uint16Array( buffer );
		_traverse( 0 );

		function _traverse( node32Index, depth = 0 ) {

			const node16Index = node32Index * 2;
			const isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;
			if ( isLeaf ) {

				const offset = uint32Array[ node32Index + 6 ];
				const count = uint16Array[ node16Index + 14 ];
				callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );

			} else {

				// TODO: use node functions here
				const left = node32Index + BYTES_PER_NODE / 4;
				const right = uint32Array[ node32Index + 6 ];
				const splitAxis = uint32Array[ node32Index + 7 ];
				const stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );

				if ( ! stopTraversal ) {

					_traverse( left, depth + 1 );
					_traverse( right, depth + 1 );

				}

			}

		}

	}

	/* Core Cast Functions */
	raycast( ray, materialOrSide = FrontSide ) {

		const roots = this._roots;
		const geometry = this.geometry;
		const intersects = [];
		const isMaterial = materialOrSide.isMaterial;
		const isArrayMaterial = Array.isArray( materialOrSide );

		const groups = geometry.groups;
		const side = isMaterial ? materialOrSide.side : materialOrSide;
		for ( let i = 0, l = roots.length; i < l; i ++ ) {

			const materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;
			const startCount = intersects.length;

			setBuffer( roots[ i ] );
			raycast( 0, geometry, materialSide, ray, intersects );
			clearBuffer();

			if ( isArrayMaterial ) {

				const materialIndex = groups[ i ].materialIndex;
				for ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {

					intersects[ j ].face.materialIndex = materialIndex;

				}

			}

		}

		return intersects;

	}

	raycastFirst( ray, materialOrSide = FrontSide ) {

		const roots = this._roots;
		const geometry = this.geometry;
		const isMaterial = materialOrSide.isMaterial;
		const isArrayMaterial = Array.isArray( materialOrSide );

		let closestResult = null;

		const groups = geometry.groups;
		const side = isMaterial ? materialOrSide.side : materialOrSide;
		for ( let i = 0, l = roots.length; i < l; i ++ ) {

			const materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;

			setBuffer( roots[ i ] );
			const result = raycastFirst( 0, geometry, materialSide, ray );
			clearBuffer();

			if ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {

				closestResult = result;
				if ( isArrayMaterial ) {

					result.face.materialIndex = groups[ i ].materialIndex;

				}

			}

		}

		return closestResult;

	}

	intersectsGeometry( otherGeometry, geomToMesh ) {

		const geometry = this.geometry;
		let result = false;
		for ( const root of this._roots ) {

			setBuffer( root );
			result = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );
			clearBuffer();

			if ( result ) {

				break;

			}

		}

		return result;

	}

	shapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {

		const geometry = this.geometry;
		if ( callbacks instanceof Function ) {

			if ( _intersectsTriangleFunc ) {

				// Support the previous function signature that provided three sequential index buffer
				// indices here.
				const originalTriangleFunc = _intersectsTriangleFunc;
				_intersectsTriangleFunc = ( tri, index, contained, depth ) => {

					const i3 = index * 3;
					return originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );

				};


			}

			callbacks = {

				boundsTraverseOrder: _orderNodesFunc,
				intersectsBounds: callbacks,
				intersectsTriangle: _intersectsTriangleFunc,
				intersectsRange: null,

			};

			console.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );

		}

		const triangle = trianglePool.getPrimitive();
		let {
			boundsTraverseOrder,
			intersectsBounds,
			intersectsRange,
			intersectsTriangle,
		} = callbacks;

		if ( intersectsRange && intersectsTriangle ) {

			const originalIntersectsRange = intersectsRange;
			intersectsRange = ( offset, count, contained, depth, nodeIndex ) => {

				if ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {

					return iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );

				}

				return true;

			};

		} else if ( ! intersectsRange ) {

			if ( intersectsTriangle ) {

				intersectsRange = ( offset, count, contained, depth ) => {

					return iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );

				};

			} else {

				intersectsRange = ( offset, count, contained ) => {

					return contained;

				};

			}

		}

		let result = false;
		let byteOffset = 0;
		for ( const root of this._roots ) {

			setBuffer( root );
			result = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );
			clearBuffer();

			if ( result ) {

				break;

			}

			byteOffset += root.byteLength;

		}

		trianglePool.releasePrimitive( triangle );

		return result;

	}

	bvhcast( otherBvh, matrixToLocal, callbacks ) {

		// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather
		// than an approach that walks down the tree (see bvhcast.js file for more info).

		let {
			intersectsRanges,
			intersectsTriangles,
		} = callbacks;

		const indexAttr = this.geometry.index;
		const positionAttr = this.geometry.attributes.position;

		const otherIndexAttr = otherBvh.geometry.index;
		const otherPositionAttr = otherBvh.geometry.attributes.position;

		tempMatrix.copy( matrixToLocal ).invert();

		const triangle = trianglePool.getPrimitive();
		const triangle2 = trianglePool.getPrimitive();

		if ( intersectsTriangles ) {

			function iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {

				for ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {

					setTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );
					triangle2.a.applyMatrix4( matrixToLocal );
					triangle2.b.applyMatrix4( matrixToLocal );
					triangle2.c.applyMatrix4( matrixToLocal );
					triangle2.needsUpdate = true;

					for ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {

						setTriangle( triangle, i1 * 3, indexAttr, positionAttr );
						triangle.needsUpdate = true;

						if ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {

							return true;

						}

					}

				}

				return false;

			}

			if ( intersectsRanges ) {

				const originalIntersectsRanges = intersectsRanges;
				intersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {

					if ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {

						return iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );

					}

					return true;

				};

			} else {

				intersectsRanges = iterateOverDoubleTriangles;

			}

		}

		otherBvh.getBoundingBox( aabb2 );
		aabb2.applyMatrix4( matrixToLocal );
		const result = this.shapecast( {

			intersectsBounds: box => aabb2.intersectsBox( box ),

			intersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {

				aabb.copy( box );
				aabb.applyMatrix4( tempMatrix );
				return otherBvh.shapecast( {

					intersectsBounds: box => aabb.intersectsBox( box ),

					intersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {

						return intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );

					},

				} );

			}

		} );

		trianglePool.releasePrimitive( triangle );
		trianglePool.releasePrimitive( triangle2 );
		return result;

	}

	/* Derived Cast Functions */
	intersectsBox( box, boxToMesh ) {

		obb.set( box.min, box.max, boxToMesh );
		obb.needsUpdate = true;

		return this.shapecast(
			{
				intersectsBounds: box => obb.intersectsBox( box ),
				intersectsTriangle: tri => obb.intersectsTriangle( tri )
			}
		);

	}

	intersectsSphere( sphere ) {

		return this.shapecast(
			{
				intersectsBounds: box => sphere.intersectsBox( box ),
				intersectsTriangle: tri => tri.intersectsSphere( sphere )
			}
		);

	}

	closestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {

		if ( ! otherGeometry.boundingBox ) {

			otherGeometry.computeBoundingBox();

		}

		obb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );
		obb.needsUpdate = true;

		const geometry = this.geometry;
		const pos = geometry.attributes.position;
		const index = geometry.index;
		const otherPos = otherGeometry.attributes.position;
		const otherIndex = otherGeometry.index;
		const triangle = trianglePool.getPrimitive();
		const triangle2 = trianglePool.getPrimitive();

		let tempTarget1 = temp1;
		let tempTargetDest1 = temp2;
		let tempTarget2 = null;
		let tempTargetDest2 = null;

		if ( target2 ) {

			tempTarget2 = temp3;
			tempTargetDest2 = temp4;

		}

		let closestDistance = Infinity;
		let closestDistanceTriIndex = null;
		let closestDistanceOtherTriIndex = null;
		tempMatrix.copy( geometryToBvh ).invert();
		obb2.matrix.copy( tempMatrix );
		this.shapecast(
			{

				boundsTraverseOrder: box => {

					return obb.distanceToBox( box );

				},

				intersectsBounds: ( box, isLeaf, score ) => {

					if ( score < closestDistance && score < maxThreshold ) {

						// if we know the triangles of this bounds will be intersected next then
						// save the bounds to use during triangle checks.
						if ( isLeaf ) {

							obb2.min.copy( box.min );
							obb2.max.copy( box.max );
							obb2.needsUpdate = true;

						}

						return true;

					}

					return false;

				},

				intersectsRange: ( offset, count ) => {

					if ( otherGeometry.boundsTree ) {

						// if the other geometry has a bvh then use the accelerated path where we use shapecast to find
						// the closest bounds in the other geometry to check.
						return otherGeometry.boundsTree.shapecast( {
							boundsTraverseOrder: box => {

								return obb2.distanceToBox( box );

							},

							intersectsBounds: ( box, isLeaf, score ) => {

								return score < closestDistance && score < maxThreshold;

							},

							intersectsRange: ( otherOffset, otherCount ) => {

								for ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {

									setTriangle( triangle2, i2, otherIndex, otherPos );
									triangle2.a.applyMatrix4( geometryToBvh );
									triangle2.b.applyMatrix4( geometryToBvh );
									triangle2.c.applyMatrix4( geometryToBvh );
									triangle2.needsUpdate = true;

									for ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {

										setTriangle( triangle, i, index, pos );
										triangle.needsUpdate = true;

										const dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );
										if ( dist < closestDistance ) {

											tempTargetDest1.copy( tempTarget1 );

											if ( tempTargetDest2 ) {

												tempTargetDest2.copy( tempTarget2 );

											}

											closestDistance = dist;
											closestDistanceTriIndex = i / 3;
											closestDistanceOtherTriIndex = i2 / 3;

										}

										// stop traversal if we find a point that's under the given threshold
										if ( dist < minThreshold ) {

											return true;

										}

									}

								}

							},
						} );

					} else {

						// If no bounds tree then we'll just check every triangle.
						const triCount = otherIndex ? otherIndex.count : otherPos.count;
						for ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {

							setTriangle( triangle2, i2, otherIndex, otherPos );
							triangle2.a.applyMatrix4( geometryToBvh );
							triangle2.b.applyMatrix4( geometryToBvh );
							triangle2.c.applyMatrix4( geometryToBvh );
							triangle2.needsUpdate = true;

							for ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {

								setTriangle( triangle, i, index, pos );
								triangle.needsUpdate = true;

								const dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );
								if ( dist < closestDistance ) {

									tempTargetDest1.copy( tempTarget1 );

									if ( tempTargetDest2 ) {

										tempTargetDest2.copy( tempTarget2 );

									}

									closestDistance = dist;
									closestDistanceTriIndex = i / 3;
									closestDistanceOtherTriIndex = i2 / 3;

								}

								// stop traversal if we find a point that's under the given threshold
								if ( dist < minThreshold ) {

									return true;

								}

							}

						}

					}

				},

			}

		);

		trianglePool.releasePrimitive( triangle );
		trianglePool.releasePrimitive( triangle2 );

		if ( closestDistance === Infinity ) return null;

		if ( ! target1.point ) target1.point = tempTargetDest1.clone();
		else target1.point.copy( tempTargetDest1 );
		target1.distance = closestDistance,
		target1.faceIndex = closestDistanceTriIndex;

		if ( target2 ) {

			if ( ! target2.point ) target2.point = tempTargetDest2.clone();
			else target2.point.copy( tempTargetDest2 );
			target2.point.applyMatrix4( tempMatrix );
			tempTargetDest1.applyMatrix4( tempMatrix );
			target2.distance = tempTargetDest1.sub( target2.point ).length();
			target2.faceIndex = closestDistanceOtherTriIndex;

		}

		return target1;

	}

	closestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {

		// early out if under minThreshold
		// skip checking if over maxThreshold
		// set minThreshold = maxThreshold to quickly check if a point is within a threshold
		// returns Infinity if no value found
		const minThresholdSq = minThreshold * minThreshold;
		const maxThresholdSq = maxThreshold * maxThreshold;
		let closestDistanceSq = Infinity;
		let closestDistanceTriIndex = null;
		this.shapecast(

			{

				boundsTraverseOrder: box => {

					temp.copy( point ).clamp( box.min, box.max );
					return temp.distanceToSquared( point );

				},

				intersectsBounds: ( box, isLeaf, score ) => {

					return score < closestDistanceSq && score < maxThresholdSq;

				},

				intersectsTriangle: ( tri, triIndex ) => {

					tri.closestPointToPoint( point, temp );
					const distSq = point.distanceToSquared( temp );
					if ( distSq < closestDistanceSq ) {

						temp1.copy( temp );
						closestDistanceSq = distSq;
						closestDistanceTriIndex = triIndex;

					}

					if ( distSq < minThresholdSq ) {

						return true;

					} else {

						return false;

					}

				},

			}

		);

		if ( closestDistanceSq === Infinity ) return null;

		const closestDistance = Math.sqrt( closestDistanceSq );

		if ( ! target.point ) target.point = temp1.clone();
		else target.point.copy( temp1 );
		target.distance = closestDistance,
		target.faceIndex = closestDistanceTriIndex;

		return target;

	}

	getBoundingBox( target ) {

		target.makeEmpty();

		const roots = this._roots;
		roots.forEach( buffer => {

			arrayToBox( 0, new Float32Array( buffer ), tempBox );
			target.union( tempBox );

		} );

		return target;

	}

}

// Deprecation
const originalRaycast = MeshBVH.prototype.raycast;
MeshBVH.prototype.raycast = function ( ...args ) {

	if ( args[ 0 ].isMesh ) {

		console.warn( 'MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.' );
		const [
			mesh, raycaster, ray, intersects,
		] = args;

		const results = originalRaycast.call( this, ray, mesh.material );
		results.forEach( hit => {

			hit = convertRaycastIntersect( hit, mesh, raycaster );
			if ( hit ) {

				intersects.push( hit );

			}

		} );

		return intersects;

	} else {

		return originalRaycast.apply( this, args );

	}

};

const originalRaycastFirst = MeshBVH.prototype.raycastFirst;
MeshBVH.prototype.raycastFirst = function ( ...args ) {

	if ( args[ 0 ].isMesh ) {

		console.warn( 'MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.' );
		const [
			mesh, raycaster, ray,
		] = args;

		return convertRaycastIntersect( originalRaycastFirst.call( this, ray, mesh.material ), mesh, raycaster );

	} else {

		return originalRaycastFirst.apply( this, args );

	}

};

const originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;
MeshBVH.prototype.closestPointToPoint = function ( ...args ) {


	if ( args[ 0 ].isMesh ) {

		console.warn( 'MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.' );

		args.unshift();

		const target = args[ 1 ];
		const result = {};
		args[ 1 ] = result;

		originalClosestPointToPoint.apply( this, args );

		if ( target ) {

			target.copy( result.point );

		}

		return result.distance;

	} else {

		return originalClosestPointToPoint.apply( this, args );

	}

};

const originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;
MeshBVH.prototype.closestPointToGeometry = function ( ...args ) {

	const target1 = args[ 2 ];
	const target2 = args[ 3 ];
	if ( target1 && target1.isVector3 || target2 && target2.isVector3 ) {

		console.warn( 'MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.' );

		const result1 = {};
		const result2 = {};
		const geometryToBvh = args[ 1 ];
		args[ 2 ] = result1;
		args[ 3 ] = result2;

		originalClosestPointToGeometry.apply( this, args );

		if ( target1 ) {

			target1.copy( result1.point );

		}

		if ( target2 ) {

			target2.copy( result2.point ).applyMatrix4( geometryToBvh );

		}

		return result1.distance;

	} else {

		return originalClosestPointToGeometry.apply( this, args );

	}

};

const originalRefit = MeshBVH.prototype.refit;
MeshBVH.prototype.refit = function ( ...args ) {

	const nodeIndices = args[ 0 ];
	const terminationIndices = args[ 1 ];
	if ( terminationIndices && ( terminationIndices instanceof Set || Array.isArray( terminationIndices ) ) ) {

		console.warn( 'MeshBVH: The function signature for "refit" has changed. See docs for new signature.' );

		const newNodeIndices = new Set();
		terminationIndices.forEach( v => newNodeIndices.add( v ) );
		if ( nodeIndices ) {

			nodeIndices.forEach( v => newNodeIndices.add( v ) );

		}

		originalRefit.call( this, newNodeIndices );

	} else {

		originalRefit.apply( this, args );

	}

};

[
	'intersectsGeometry',
	'shapecast',
	'intersectsBox',
	'intersectsSphere',
].forEach( name => {

	const originalFunc = MeshBVH.prototype[ name ];
	MeshBVH.prototype[ name ] = function ( ...args ) {

		if ( args[ 0 ] === null || args[ 0 ].isMesh ) {

			args.shift();
			console.warn( `MeshBVH: The function signature for "${ name }" has changed and no longer takes Mesh. See docs for new signature.` );

		}

		return originalFunc.apply( this, args );

	};

} );

const ray = /* @__PURE__ */ new Ray();
const tmpInverseMatrix = /* @__PURE__ */ new Matrix4();
const origMeshRaycastFunc = Mesh.prototype.raycast;

function acceleratedRaycast( raycaster, intersects ) {

	if ( this.geometry.boundsTree ) {

		if ( this.material === undefined ) return;

		tmpInverseMatrix.copy( this.matrixWorld ).invert();
		ray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );

		const bvh = this.geometry.boundsTree;
		if ( raycaster.firstHitOnly === true ) {

			const hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );
			if ( hit ) {

				intersects.push( hit );

			}

		} else {

			const hits = bvh.raycast( ray, this.material );
			for ( let i = 0, l = hits.length; i < l; i ++ ) {

				const hit = convertRaycastIntersect( hits[ i ], this, raycaster );
				if ( hit ) {

					intersects.push( hit );

				}

			}

		}

	} else {

		origMeshRaycastFunc.call( this, raycaster, intersects );

	}

}

/**
 * Calculates the morphed attributes of a morphed/skinned BufferGeometry.
 * Helpful for Raytracing or Decals.
 * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.
 * @return {Object} An Object with original position/normal attributes and morphed ones.
 */
function computeMorphedAttributes( object ) {

	if ( object.geometry.isBufferGeometry !== true ) {

		console.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );
		return null;

	}

	const _vA = new Vector3();
	const _vB = new Vector3();
	const _vC = new Vector3();

	const _tempA = new Vector3();
	const _tempB = new Vector3();
	const _tempC = new Vector3();

	const _morphA = new Vector3();
	const _morphB = new Vector3();
	const _morphC = new Vector3();

	function _calculateMorphedAttributeData(
		object,
		attribute,
		morphAttribute,
		morphTargetsRelative,
		a,
		b,
		c,
		modifiedAttributeArray
	) {

		_vA.fromBufferAttribute( attribute, a );
		_vB.fromBufferAttribute( attribute, b );
		_vC.fromBufferAttribute( attribute, c );

		const morphInfluences = object.morphTargetInfluences;

		if ( morphAttribute && morphInfluences ) {

			_morphA.set( 0, 0, 0 );
			_morphB.set( 0, 0, 0 );
			_morphC.set( 0, 0, 0 );

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morph = morphAttribute[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morph, a );
				_tempB.fromBufferAttribute( morph, b );
				_tempC.fromBufferAttribute( morph, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );
					_morphB.addScaledVector( _tempB, influence );
					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA ), influence );
					_morphB.addScaledVector( _tempB.sub( _vB ), influence );
					_morphC.addScaledVector( _tempC.sub( _vC ), influence );

				}

			}

			_vA.add( _morphA );
			_vB.add( _morphB );
			_vC.add( _morphC );

		}

		if ( object.isSkinnedMesh ) {

			object.boneTransform( a, _vA );
			object.boneTransform( b, _vB );
			object.boneTransform( c, _vC );

		}

		modifiedAttributeArray[ a * 3 + 0 ] = _vA.x;
		modifiedAttributeArray[ a * 3 + 1 ] = _vA.y;
		modifiedAttributeArray[ a * 3 + 2 ] = _vA.z;
		modifiedAttributeArray[ b * 3 + 0 ] = _vB.x;
		modifiedAttributeArray[ b * 3 + 1 ] = _vB.y;
		modifiedAttributeArray[ b * 3 + 2 ] = _vB.z;
		modifiedAttributeArray[ c * 3 + 0 ] = _vC.x;
		modifiedAttributeArray[ c * 3 + 1 ] = _vC.y;
		modifiedAttributeArray[ c * 3 + 2 ] = _vC.z;

	}

	const geometry = object.geometry;
	const material = object.material;

	let a, b, c;
	const index = geometry.index;
	const positionAttribute = geometry.attributes.position;
	const morphPosition = geometry.morphAttributes.position;
	const morphTargetsRelative = geometry.morphTargetsRelative;
	const normalAttribute = geometry.attributes.normal;
	const morphNormal = geometry.morphAttributes.position;

	const groups = geometry.groups;
	const drawRange = geometry.drawRange;
	let i, j, il, jl;
	let group;
	let start, end;

	const modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );
	const modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );

	if ( index !== null ) {

		// indexed buffer geometry

		if ( Array.isArray( material ) ) {

			for ( i = 0, il = groups.length; i < il; i ++ ) {

				group = groups[ i ];

				start = Math.max( group.start, drawRange.start );
				end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

				for ( j = start, jl = end; j < jl; j += 3 ) {

					a = index.getX( j );
					b = index.getX( j + 1 );
					c = index.getX( j + 2 );

					_calculateMorphedAttributeData(
						object,
						positionAttribute,
						morphPosition,
						morphTargetsRelative,
						a, b, c,
						modifiedPosition
					);

					_calculateMorphedAttributeData(
						object,
						normalAttribute,
						morphNormal,
						morphTargetsRelative,
						a, b, c,
						modifiedNormal
					);

				}

			}

		} else {

			start = Math.max( 0, drawRange.start );
			end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( i = start, il = end; i < il; i += 3 ) {

				a = index.getX( i );
				b = index.getX( i + 1 );
				c = index.getX( i + 2 );

				_calculateMorphedAttributeData(
					object,
					positionAttribute,
					morphPosition,
					morphTargetsRelative,
					a, b, c,
					modifiedPosition
				);

				_calculateMorphedAttributeData(
					object,
					normalAttribute,
					morphNormal,
					morphTargetsRelative,
					a, b, c,
					modifiedNormal
				);

			}

		}

	} else {

		// non-indexed buffer geometry

		if ( Array.isArray( material ) ) {

			for ( i = 0, il = groups.length; i < il; i ++ ) {

				group = groups[ i ];

				start = Math.max( group.start, drawRange.start );
				end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

				for ( j = start, jl = end; j < jl; j += 3 ) {

					a = j;
					b = j + 1;
					c = j + 2;

					_calculateMorphedAttributeData(
						object,
						positionAttribute,
						morphPosition,
						morphTargetsRelative,
						a, b, c,
						modifiedPosition
					);

					_calculateMorphedAttributeData(
						object,
						normalAttribute,
						morphNormal,
						morphTargetsRelative,
						a, b, c,
						modifiedNormal
					);

				}

			}

		} else {

			start = Math.max( 0, drawRange.start );
			end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( i = start, il = end; i < il; i += 3 ) {

				a = i;
				b = i + 1;
				c = i + 2;

				_calculateMorphedAttributeData(
					object,
					positionAttribute,
					morphPosition,
					morphTargetsRelative,
					a, b, c,
					modifiedPosition
				);

				_calculateMorphedAttributeData(
					object,
					normalAttribute,
					morphNormal,
					morphTargetsRelative,
					a, b, c,
					modifiedNormal
				);

			}

		}

	}

	const morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );
	const morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );

	return {

		positionAttribute: positionAttribute,
		normalAttribute: normalAttribute,
		morphedPositionAttribute: morphedPositionAttribute,
		morphedNormalAttribute: morphedNormalAttribute

	};

}

function computeMorphedGeometry(source, target) {
    if (!source.geometry.hasAttribute("normal")) {
        source.geometry.computeVertexNormals();
    }
    const { morphedPositionAttribute, morphedNormalAttribute } = computeMorphedAttributes(source);
    target.groups = [...source.geometry.groups];
    if (source.geometry.index) {
        target.index = source.geometry.index.clone();
    }
    target.deleteAttribute('position');
    target.deleteAttribute('normal');
    target.setAttribute('position', morphedPositionAttribute);
    target.setAttribute('normal', morphedNormalAttribute);
}

// Author: Axel Antoine
/**
 * Mesh object that can be rendered as SVG.
 * Wrapper class around three mesh object that duplicates geometry if needed (i.e.
 * for SkinnedMesh) and computes BVH and HalfEdgeStructure on demand)
 */
class SVGMesh {
    threeMesh;
    morphGeometry;
    hes;
    bvh;
    isUsingBVHForRaycasting = false;
    _originalRaycastFunc;
    constructor(mesh, options = {}) {
        this.threeMesh = mesh;
        this.morphGeometry = new BufferGeometry();
        this._originalRaycastFunc = mesh.raycast;
        this.updateMorphGeometry();
        if (options.replaceMeshRaycastFunc) {
            this.useBVHRaycast(true);
        }
        // Setup HES
        const hesOptions = {
            hashNormals: false,
            ...options?.hesOptions
        };
        this.hes = new HalfEdgeStructure(this.morphGeometry, hesOptions);
        // Setup BVH
        const bvhOptions = {
            maxLeafTris: 1,
            strategy: CENTER,
            ...options?.bvhOptions
        };
        this.bvh = new MeshBVH(this.morphGeometry, bvhOptions);
    }
    updateMorphGeometry() {
        computeMorphedGeometry(this.threeMesh, this.morphGeometry);
    }
    updateBVH(updateMorphGeometry = true) {
        updateMorphGeometry && this.updateMorphGeometry();
        this.bvh.refit();
    }
    updateHES(updateMorphGeometry = true) {
        updateMorphGeometry && this.updateMorphGeometry();
        this.hes.build();
    }
    localToWorld(target) {
        return this.threeMesh.localToWorld(target);
    }
    colorForFaceIndex(faceIndex) {
        if (Array.isArray(this.material)) {
            for (const group of this.morphGeometry.groups) {
                if (group.start <= faceIndex &&
                    faceIndex < (group.start + group.count) &&
                    group.materialIndex != undefined &&
                    group.materialIndex < this.material.length) {
                    return colorForMaterial(this.material[group.materialIndex]);
                }
            }
            return null;
        }
        return colorForMaterial(this.material);
    }
    dispose() {
        this.morphGeometry.dispose();
        this.useBVHRaycast(false);
    }
    useBVHRaycast(use) {
        this.isUsingBVHForRaycasting = use;
        if (use) {
            const bvh = this.bvh;
            this.threeMesh.raycast = function (raycaster, intersects) {
                const oldBVH = this.geometry.boundsTree;
                this.geometry.boundsTree = bvh;
                acceleratedRaycast.call(this, raycaster, intersects);
                this.geometry.boundsTree = oldBVH;
            };
        }
        else {
            this.threeMesh.raycast = this._originalRaycastFunc;
        }
    }
    get material() { return this.threeMesh.material; }
    get matrixWorld() { return this.threeMesh.matrixWorld; }
    get name() { return this.threeMesh.name; }
    set name(name) { this.threeMesh.name = name; }
}
function colorForMaterial(material) {
    const colorMaterial = material;
    return colorMaterial.color;
}

// Author: Axel Antoine
// mail: ax.antoine@gmail.com
// website: https://axantoine.com
// 16/06/2022
class DrawPass {
    name;
    constructor() {
        this.name = this.constructor.name;
    }
}

// Author: Axel Antoine
function getSVGText(text, x, y, fontStyle = {}, strokeStyle = {}, fillStyle = {}) {
    const svgText = new Text();
    svgText.text(text);
    svgText.x(x);
    svgText.y(y);
    svgText.font(fontStyle);
    svgText.stroke(strokeStyle);
    svgText.fill(fillStyle);
    return svgText;
}
function getSVGPath(contour, holes, closed, strokeStyle, fillStyle) {
    const path = new Path();
    let cmds = getSVGPathCommands(contour, closed);
    for (const hole of holes) {
        cmds = cmds.concat(getSVGPathCommands(hole, closed));
    }
    path.plot(new PathArray(cmds));
    if (strokeStyle) {
        path.stroke(strokeStyle);
    }
    else {
        path.stroke('none');
    }
    if (fillStyle) {
        path.fill({ ...fillStyle, rule: "evenodd" });
    }
    else {
        path.fill('none');
    }
    return path;
}
function getSVGPathCommands(points, closed = true) {
    const cmds = new Array();
    let p;
    if (points.length > 0) {
        p = points[0];
        cmds.push(['M', round(p.x), round(p.y)]);
        for (let i = 1; i < points.length; i++) {
            p = points[i];
            cmds.push(['L', round(p.x), round(p.y)]);
        }
        if (closed) {
            cmds.push(['Z']);
        }
    }
    return cmds;
}
function getSVGCircle(cx, cy, radius, strokeStyle = {}, fillStyle = {}) {
    const circle = new Circle();
    circle.center(cx, cy);
    circle.radius(radius);
    circle.stroke(strokeStyle);
    circle.fill(fillStyle);
    return circle;
}

// Author: Axel Antoine
class FillsDrawPass extends DrawPass {
    options;
    fillStyle;
    constructor(fillStyle = {}, options = {}) {
        super();
        this.options = {
            drawRaycastPoint: false,
            drawPolygonId: false,
            useRandomColors: false,
            useFixedFillColor: false,
            ...options
        };
        this.fillStyle = {
            color: "#333333",
            opacity: 1,
            ...fillStyle
        };
    }
    async draw(svg, viewmap) {
        const group = new G({ id: "fills" });
        svg.add(group);
        for (const mesh of viewmap.meshes) {
            const polygons = viewmap.polygons.filter(p => p.mesh === mesh);
            const objectGroup = new G({ id: mesh.name });
            group.add(objectGroup);
            for (const polygon of polygons) {
                drawPolygon(group, polygon, this.options, undefined, this.fillStyle);
            }
        }
    }
}
function drawPolygon(parent, polygon, options, strokeStyle = {}, fillStyle = {}) {
    // Make a copy of the style so we can modify it
    fillStyle = { ...fillStyle };
    // If not using fixed color through the style, use the object color
    if (!options.useFixedFillColor) {
        fillStyle.color = '#' + polygon.color.getHexString();
    }
    if (options.useRandomColors) {
        fillStyle.color = Color.random().toString();
    }
    const path = getSVGPath(polygon.contour, polygon.holes, true, strokeStyle, fillStyle);
    path.id("fill-" + polygon.id);
    parent.add(path);
    if (options.drawRaycastPoint) {
        drawPolygonRaycastPoint(path, polygon);
    }
    if (options.drawPolygonId) {
        drawPolygonId(path, polygon, fillStyle);
    }
}
function drawPolygonRaycastPoint(parent, polygon) {
    const strokeStyle = { color: "black" };
    const fillStyle = { color: "white" };
    const cx = polygon.insidePoint.x;
    const cy = polygon.insidePoint.y;
    const point = getSVGCircle(cx, cy, 2, strokeStyle, fillStyle);
    point.id('raycast-point');
    parent.add(point);
}
function drawPolygonId(parent, polygon, fillStyle) {
    const fontStyle = { size: 8 };
    const delta = 10;
    const x = polygon.insidePoint.x + delta;
    const y = polygon.insidePoint.y + delta;
    const text = getSVGText(String(polygon.id), x, y, fontStyle);
    const box = text.bbox();
    const cx = x + box.width / 2;
    const cy = y + box.height / 2;
    const circle = getSVGCircle(cx, cy, 0.85 * box.width, {}, fillStyle);
    circle.id('polygon-id');
    circle.add(text);
    parent.add(circle);
}

// Author: Axel Antoine
const PointSingularities = Object.values(PointSingularity)
    .filter(singularity => singularity !== PointSingularity.None);
const PointSingularityColor = {
    [PointSingularity.None]: "",
    [PointSingularity.ImageIntersection]: "green",
    [PointSingularity.MeshIntersection]: "red",
    [PointSingularity.CurtainFold]: "blue",
    [PointSingularity.Bifurcation]: "orange",
};
class SingularityPointsDrawPass extends DrawPass {
    options;
    constructor(options = {}) {
        super();
        this.options = {
            drawVisiblePoints: true,
            drawHiddenPoints: false,
            drawLegend: true,
            pointSize: 2,
            ...options
        };
    }
    async draw(svg, viewmap) {
        // Update point visibility to avoid drawing point on hidden contours if only
        // visible contours are drawn
        for (const contour of viewmap.contours) {
            for (const p of contour.points) {
                p.visible = p.visible || contour.visibility === ContourVisibility.Visible;
            }
        }
        const visibilities = [];
        if (this.options.drawVisiblePoints) {
            visibilities.push(true);
        }
        if (this.options.drawHiddenPoints) {
            visibilities.push(false);
        }
        const group = new G({ id: "singularity-points" });
        svg.add(group);
        const strokeStyle = {
            color: 'black'
        };
        const fillStyle = {
            color: "",
        };
        for (const visibility of visibilities) {
            const visibilityGroup = new G({ id: visibility ? "visible" : "hidden" });
            group.add(visibilityGroup);
            for (const singularity of PointSingularities) {
                const points = viewmap.singularityPoints
                    .filter(p => p.singularity === singularity && p.visible === visibility);
                const singularityGroup = new G({ id: singularity });
                visibilityGroup.add(singularityGroup);
                fillStyle.color = PointSingularityColor[singularity];
                for (const p of points) {
                    const svgPoint = getSVGCircle(p.x, p.y, this.options.pointSize, strokeStyle, fillStyle);
                    singularityGroup.add(svgPoint);
                }
            }
        }
        if (this.options.drawLegend &&
            (this.options.drawVisiblePoints || this.options.drawHiddenPoints)) {
            group.add(getLegend());
        }
    }
}
function getLegend() {
    const legend = new G({ id: "singularity-legend" });
    legend.add(getSVGText("Singularities", 10, 10, { size: 15, anchor: 'start' }));
    let y = 40;
    for (const singularity of PointSingularities) {
        const fillColor = PointSingularityColor[singularity];
        legend.add(getSVGCircle(15, y, 8, { color: "black" }, { color: fillColor }));
        legend.add(getSVGText(singularity, 30, y - 10, { size: 15, anchor: 'start' }));
        y += 20;
    }
    return legend;
}

// Author: Axel Antoine
const EdgeNatures = Object.values(EdgeNature)
    .filter(nature => nature !== EdgeNature.None);
class ContoursDrawPass extends DrawPass {
    options;
    strokeStyle;
    constructor(strokeStyle = {}, options = {}) {
        super();
        this.options = {
            drawContourId: false,
            drawRaycastPoint: false,
            useRandomColors: false,
            groupByNature: true,
            ...options
        };
        this.strokeStyle = {
            color: "#000000",
            width: 1,
            dasharray: "",
            linecap: "butt",
            linejoin: "miter",
            opacity: 1,
            dashoffset: 0,
            ...strokeStyle
        };
    }
}
class VisibleContoursDrawPass extends ContoursDrawPass {
    constructor(strokeStyle = {}, options = {}) {
        super(strokeStyle, options);
    }
    async draw(svg, viewmap) {
        const contours = viewmap.contours.filter(contour => contour.visibility === ContourVisibility.Visible);
        const group = new G({ id: "visible-contours" });
        drawContours(group, viewmap, contours, this.options, this.strokeStyle);
        svg.add(group);
    }
}
class HiddenContoursDrawPass extends ContoursDrawPass {
    constructor(strokeStyle = {}, options = {}) {
        super({ color: "#FF0000", dasharray: "2,2", ...strokeStyle }, options);
    }
    async draw(svg, viewmap) {
        const contours = viewmap.contours.filter(contour => contour.visibility === ContourVisibility.Hidden);
        const group = new G({ id: "hidden-contours" });
        svg.add(group);
        drawContours(group, viewmap, contours, this.options, this.strokeStyle);
    }
}
function drawContours(parent, viewmap, contours, options, strokeStyle = {}) {
    // Group the contours by mesh
    for (const mesh of viewmap.meshes) {
        const objectContours = contours.filter(c => c.object === mesh);
        const objectGroup = new G({ id: mesh.name });
        parent.add(objectGroup);
        // Group the contours by nature if required
        if (options.groupByNature) {
            for (const nature of EdgeNatures) {
                const natureContours = objectContours.filter(c => c.nature === nature);
                const natureGroup = new G({ id: nature });
                objectGroup.add(natureGroup);
                for (const contour of natureContours) {
                    drawContour(natureGroup, contour, options, strokeStyle);
                }
            }
        }
        else {
            for (const contour of objectContours) {
                drawContour(objectGroup, contour, options, strokeStyle);
            }
        }
    }
}
function drawContour(parent, contour, options, strokeStyle = {}) {
    if (options.useRandomColors) {
        strokeStyle = { ...strokeStyle };
        strokeStyle.color = Color.random().toString();
    }
    const path = getSVGPath(contour.points, [], false, strokeStyle);
    parent.add(path);
    if (options.drawRaycastPoint) {
        drawContourRaycastPoint(path, contour);
    }
    if (options.drawContourId) {
        drawContourId(path, contour, strokeStyle);
    }
}
function drawContourRaycastPoint(parent, contour) {
    const strokeStyle = { color: "black" };
    const fillStyle = { color: "white" };
    const cx = contour.raycastPoint.x;
    const cy = contour.raycastPoint.y;
    const point = getSVGCircle(cx, cy, 2, strokeStyle, fillStyle);
    point.id('raycast-point');
    parent.add(point);
}
function drawContourId(parent, contour, strokeStyle) {
    const fontStyle = { size: 8 };
    const delta = 10;
    const x = contour.raycastPoint.x + delta;
    const y = contour.raycastPoint.y + delta;
    const text = getSVGText(String(contour.id), x, y, fontStyle);
    const box = text.bbox();
    const cx = x + box.width / 2;
    const cy = y + box.height / 2;
    const circle = getSVGCircle(cx, cy, 0.85 * box.width, {}, strokeStyle);
    circle.id('contour-id');
    circle.add(text);
    parent.add(circle);
}

Element.prototype.addAll = function (children) {
    for (const child of children) {
        this.add(child);
    }
};

class GLTFLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsEmissiveStrengthExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIridescenceExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let content;
		const extensions = {};
		const plugins = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			const magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = LoaderUtils.decodeText( new Uint8Array( data ) );

			}

		}

		const json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new Color$1( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new Color$1( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

		if ( emissiveStrength !== undefined ) {

			materialParams.emissiveIntensity = emissiveStrength;

		}

		return Promise.resolve();

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.iridescenceFactor !== undefined ) {

			materialParams.iridescence = extension.iridescenceFactor;

		}

		if ( extension.iridescenceTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

		}

		if ( extension.iridescenceIor !== undefined ) {

			materialParams.iridescenceIOR = extension.iridescenceIor;

		}

		if ( materialParams.iridescenceThicknessRange === undefined ) {

			materialParams.iridescenceThicknessRange = [ 100, 400 ];

		}

		if ( extension.iridescenceThicknessMinimum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

		}

		if ( extension.iridescenceThicknessMaximum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

		}

		if ( extension.iridescenceThicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new Color$1( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || 0;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new Color$1( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new Color$1( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const result = new ArrayBuffer( count * stride );
				const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = LoaderUtils.decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {

	constructor( params ) {

		super();

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		const specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		const glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		const specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		const glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		const lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.roughness += geometryRoughness;',
			'material.roughness = min( material.roughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		const uniforms = {
			specular: { value: new Color$1().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( const uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	copy( source ) {

		super.copy( source );

		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	}

}


class GLTFMaterialsPbrSpecularGlossinessExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

		this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity'
		];

	}

	getMaterialType() {

		return GLTFMeshStandardSGMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

		materialParams.color = new Color$1( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const pending = [];

		if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

			const array = pbrSpecularGlossiness.diffuseFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, sRGBEncoding ) );

		}

		materialParams.emissive = new Color$1( 0.0, 0.0, 0.0 );
		materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
		materialParams.specular = new Color$1( 1.0, 1.0, 1.0 );

		if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

			materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

		}

		if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

			const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
			pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
			pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef, sRGBEncoding ) );

		}

		return Promise.all( pending );

	}

	createMaterial( materialParams ) {

		const material = new GLTFMeshStandardSGMaterial( materialParams );
		material.fog = true;

		material.color = materialParams.color;

		material.map = materialParams.map === undefined ? null : materialParams.map;

		material.lightMap = null;
		material.lightMapIntensity = 1.0;

		material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
		material.aoMapIntensity = 1.0;

		material.emissive = materialParams.emissive;
		material.emissiveIntensity = materialParams.emissiveIntensity === undefined ? 1.0 : materialParams.emissiveIntensity;
		material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

		material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
		material.bumpScale = 1;

		material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
		material.normalMapType = TangentSpaceNormalMap;

		if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

		material.displacementMap = null;
		material.displacementScale = 1;
		material.displacementBias = 0;

		material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
		material.specular = materialParams.specular;

		material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
		material.glossiness = materialParams.glossiness;

		material.alphaMap = null;

		material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
		material.envMapIntensity = 1.0;

		return material;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

}

GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

	const result = this.resultBuffer;
	const values = this.sampleValues;
	const stride = this.valueSize;

	const stride2 = stride * 2;
	const stride3 = stride * 3;

	const td = t1 - t0;

	const p = ( t - t0 ) / td;
	const pp = p * p;
	const ppp = pp * p;

	const offset1 = i1 * stride3;
	const offset0 = offset1 - stride3;

	const s2 = - 2 * ppp + 3 * pp;
	const s3 = ppp - pp;
	const s0 = 1 - s2;
	const s1 = s3 - pp + p;

	// Layout of keyframe output values for CUBICSPLINE animations:
	//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
	for ( let i = 0; i !== stride; i ++ ) {

		const p0 = values[ offset0 + i + stride ]; // splineVertex_k
		const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
		const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
		const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

		result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

	}

	return result;

};

const _q = new Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: NearestFilter,
	9729: LinearFilter,
	9984: NearestMipmapNearestFilter,
	9985: LinearMipmapNearestFilter,
	9986: NearestMipmapLinearFilter,
	9987: LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: ClampToEdgeWrapping,
	33648: MirroredRepeatWrapping,
	10497: RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: InterpolateLinear,
	STEP: InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.

		const isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;
		const isFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;
		const firefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : - 1;

		if ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {

			this.textureLoader = new TextureLoader( this.options.manager );

		} else {

			this.textureLoader = new ImageBitmapLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadAnimation && ext.loadAnimation( index );

					} );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, encoding ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( encoding !== undefined ) {

				texture.encoding = encoding;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new PointsMaterial();
				Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new LineBasicMaterial();
				Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new Color$1( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

			materialParams.emissive = new Color$1().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding ) );

		}

		return Promise.all( pending ).then( function () {

			let material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new SkinnedMesh( geometry, material )
						: new Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new Line$1( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new Group();

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();
				node.matrixAutoUpdate = true;

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = NumberKeyframeTrack;
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = QuaternionKeyframeTrack;
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = VectorKeyframeTrack;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

				const targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					node.traverse( function ( object ) {

						if ( object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

							return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new AnimationClip( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			const pending = [];

			const meshPromise = parser._invokeOne( function ( ext ) {

				return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

			} );

			if ( meshPromise ) {

				pending.push( meshPromise );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new Bone();

			} else if ( objects.length > 1 ) {

				node = new Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof Material || key instanceof Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

}

function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

	const nodeDef = json.nodes[ nodeId ];

	return parser.getDependency( 'node', nodeId ).then( function ( node ) {

		if ( nodeDef.skin === undefined ) return node;

		// build skeleton here as well

		let skinEntry;

		return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

			skinEntry = skin;

			const pendingJoints = [];

			for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

				pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

			}

			return Promise.all( pendingJoints );

		} ).then( function ( jointNodes ) {

			node.traverse( function ( mesh ) {

				if ( ! mesh.isMesh ) return;

				const bones = [];
				const boneInverses = [];

				for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

					const jointNode = jointNodes[ j ];

					if ( jointNode ) {

						bones.push( jointNode );

						const mat = new Matrix4();

						if ( skinEntry.inverseBindMatrices !== undefined ) {

							mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

						}

						boneInverses.push( mat );

					} else {

						console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

					}

				}

				mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

			} );

			return node;

		} );

	} ).then( function ( node ) {

		// build node hierachy

		parentObject.add( node );

		const pending = [];

		if ( nodeDef.children ) {

			const children = nodeDef.children;

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				const child = children[ i ];
				pending.push( buildNodeHierarchy( child, node, json, parser ) );

			}

		}

		return Promise.all( pending );

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new Vector3();
		const vector = new Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	let index = geometry.getIndex();

	// generate index if not present

	if ( index === null ) {

		const indices = [];

		const position = geometry.getAttribute( 'position' );

		if ( position !== undefined ) {

			for ( let i = 0; i < position.count; i ++ ) {

				indices.push( i );

			}

			geometry.setIndex( indices );
			index = geometry.getIndex();

		} else {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
			return geometry;

		}

	}

	//

	const numberOfTriangles = index.count - 2;
	const newIndices = [];

	if ( drawMode === TriangleFanDrawMode ) {

		// gl.TRIANGLE_FAN

		for ( let i = 1; i <= numberOfTriangles; i ++ ) {

			newIndices.push( index.getX( 0 ) );
			newIndices.push( index.getX( i ) );
			newIndices.push( index.getX( i + 1 ) );

		}

	} else {

		// gl.TRIANGLE_STRIP

		for ( let i = 0; i < numberOfTriangles; i ++ ) {

			if ( i % 2 === 0 ) {

				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i + 2 ) );


			} else {

				newIndices.push( index.getX( i + 2 ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i ) );

			}

		}

	}

	if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

		console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

	}

	// build final geometry

	const newGeometry = geometry.clone();
	newGeometry.setIndex( newIndices );

	return newGeometry;

}

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
 *                                            are most useful.
 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
 *                                            as-is, to `callback` when the throttled-function is executed.
 * @param {object} [options] -              An object to configure options.
 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
 *                                            `delay` milliseconds, the internal counter is reset).
 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
 *                                            callback will never executed if both noLeading = true and noTrailing = true.
 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
 *                                            false (at end), schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function} A new, throttled, function.
 */
function throttle (delay, callback, options) {
  var _ref = options || {},
      _ref$noTrailing = _ref.noTrailing,
      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
      _ref$noLeading = _ref.noLeading,
      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
      _ref$debounceMode = _ref.debounceMode,
      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */


  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel(options) {
    var _ref2 = options || {},
        _ref2$upcomingOnly = _ref2.upcomingOnly,
        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (!noLeading && debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`
       * and noLeading != true.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      if (noLeading) {
        /*
         * In throttle mode with noLeading, if `delay` time has
         * been exceeded, update `lastExec` and schedule `callback`
         * to execute after `delay` ms.
         */
        lastExec = Date.now();

        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        /*
         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
         * `callback`.
         */
        exec();
      }
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                        to `callback` when the debounced-function is executed.
 * @param {object} [options] -           An object to configure options.
 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 *
 * @returns {Function} A new, debounced function.
 */

function debounce (delay, callback, options) {
  var _ref = options || {},
      _ref$atBegin = _ref.atBegin,
      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}

const possibleObjects = {
    "cube": "cube",
    "pig": "pig",
    "torusknot": "torusknot",
};
// Init SVG Renderer
const svgRenderer = new SVGRenderer();
const visibleContoursPass = new VisibleContoursDrawPass();
const hiddenContoursPass = new HiddenContoursDrawPass();
const fillsPass = new FillsDrawPass();
const singularityPass = new SingularityPointsDrawPass();
const params = {
    autoRender: true,
    scene: "cube",
    fills: {
        draw: true,
        style: fillsPass.fillStyle,
        options: fillsPass.options,
    },
    visible_contours: {
        draw: true,
        style: visibleContoursPass.strokeStyle,
        options: visibleContoursPass.options,
    },
    hidden_contours: {
        draw: false,
        style: hiddenContoursPass.strokeStyle,
        options: hiddenContoursPass.options,
    },
    singularityPoints: {
        draw: false,
        options: singularityPass.options,
    }
};
const bgColor = 0x555555;
const sceneDomElement = document.getElementById('scene');
if (!sceneDomElement) {
    throw "Cannot find scene div";
}
const svgDomElement = document.getElementById('svgoutput');
if (!svgDomElement) {
    throw "Cannot find svg output div";
}
let W = sceneDomElement.clientWidth;
let H = sceneDomElement.clientHeight;
// Init renderer
const renderer = new WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(W, H);
renderer.setClearColor(bgColor, 1);
sceneDomElement.appendChild(renderer.domElement);
// Init scene
const scene = new Scene();
const ambientLight = new AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
// Init camera
const camera = new PerspectiveCamera(75, W / H, 0.1, 50);
camera.position.set(3, 3, 3);
camera.far = 100;
camera.updateProjectionMatrix();
// Init camera light
const camLight = new PointLight(0xffffff, 0.5);
camera.add(camLight);
camLight.position.set(0.5, 1, 0);
scene.add(camera);
//##############################################################################
//                                Setup GUI
//##############################################################################
const gui = new GUI$1();
gui.add(params, 'scene', possibleObjects).onChange(setupScene);
let gui_root;
let style_gui;
let options_gui;
let options, style;
// Setup visible and hidden contours gui (same settings basically)
const contours_gui_params = [
    { c_params: params.visible_contours, gui_root: gui.addFolder("Visible Contours") },
    { c_params: params.hidden_contours, gui_root: gui.addFolder("Hidden Contours") }
];
for (const { c_params, gui_root } of contours_gui_params) {
    gui_root.add(c_params, 'draw').onChange(updatePasses);
    style_gui = gui_root.addFolder("Style");
    style = c_params.style;
    style_gui.addColor(style, "color").onChange(updatePasses);
    style_gui.add(style, "width", 0, 20, 0.5).onChange(updatePasses);
    style_gui.add(style, "dasharray").onChange(updatePasses);
    style_gui.add(style, "opacity", 0, 1, 0.05).onChange(updatePasses);
    options_gui = gui_root.addFolder("Options");
    options = c_params.options;
    options_gui.add(options, "useRandomColors").onChange(updatePasses);
    options_gui.add(options, "drawContourId").onChange(updatePasses);
    options_gui.add(options, "groupByNature").onChange(updatePasses);
    options_gui.add(options, "drawRaycastPoint").onChange(updatePasses);
}
// Setup fills gui
gui_root = gui.addFolder("Fills");
gui_root.add(params.fills, 'draw').onChange(updatePasses);
style_gui = gui_root.addFolder("Style");
style = params.fills.style;
style_gui.addColor(style, "color").onChange(updatePasses);
style_gui.add(style, "opacity", 0, 1, 0.05).onChange(updatePasses);
options_gui = gui_root.addFolder("Options");
options = params.fills.options;
options_gui.add(options, "useRandomColors").onChange(updatePasses);
options_gui.add(options, "useFixedFillColor").onChange(updatePasses);
options_gui.add(options, "drawPolygonId").onChange(updatePasses);
options_gui.add(options, "drawRaycastPoint").onChange(updatePasses);
// Setup debug gui
const debug_gui = gui.addFolder("Debug");
// Debug -> Singularity points
gui_root = debug_gui.addFolder("Singularity Points");
gui_root.add(params.singularityPoints, 'draw').onChange(updatePasses);
options_gui = gui_root.addFolder("Options");
options = params.singularityPoints.options;
options_gui.add(options, "drawLegend").onChange(updatePasses);
options_gui.add(options, "pointSize", 0, 20, 0.5).onChange(updatePasses);
options_gui.add(options, "drawVisiblePoints").onChange(updatePasses);
options_gui.add(options, "drawHiddenPoints").onChange(updatePasses);
gui.add(params, 'autoRender').onChange(autoRenderChanged);
gui.add({ 'Render SVG': generateSVG }, 'Render SVG');
gui.open();
//##############################################################################
//                          Setup scene controls
//##############################################################################
const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.addEventListener('change', function () {
    render();
});
window.addEventListener('resize', function () {
    W = sceneDomElement.clientWidth;
    H = sceneDomElement.clientHeight;
    camera.aspect = W / H;
    camera.updateProjectionMatrix();
    renderer.setSize(W, H);
    render();
}, false);
function autoRenderChanged() {
    if (params.autoRender) {
        orbitControls.addEventListener('end', generateSVG);
    }
    else {
        orbitControls.removeEventListener('end', generateSVG);
    }
}
//##############################################################################
//                          Setup svg rendering
//##############################################################################
function updatePasses() {
    svgRenderer.clearDrawPasses();
    if (params.fills.draw) {
        svgRenderer.addDrawPass(fillsPass);
    }
    if (params.hidden_contours.draw) {
        svgRenderer.addDrawPass(hiddenContoursPass);
    }
    if (params.visible_contours.draw) {
        svgRenderer.addDrawPass(visibleContoursPass);
    }
    if (params.singularityPoints.draw) {
        svgRenderer.addDrawPass(singularityPass);
    }
}
const meshMaterial = new MeshPhongMaterial({
    color: 0x333388,
    flatShading: true,
});
function setupScene() {
    // Clean the current scene
    for (const obj of scene.children) {
        obj.removeFromParent();
    }
    scene.add(ambientLight);
    scene.add(camera);
    switch (params.scene) {
        case "torusknot":
            scene.add(new Mesh(new TorusKnotGeometry(), meshMaterial));
            break;
        case "pig":
            loadGLTFObject(window.location + "../../../../objects/pig.gltf");
            break;
        case "cube":
        default:
            scene.add(new Mesh(new BoxGeometry(), meshMaterial));
    }
    render();
}
const loader = new GLTFLoader();
function loadGLTFObject(url) {
    loader.load(url, function (gltf) {
        scene.add(gltf.scene);
        render();
        params.autoRender && generateSVG();
    });
}
function render() {
    gui.updateDisplay();
    renderer.render(scene, camera);
}
const debouncedGenerateSVG = debounce(500, () => {
    const svgMeshes = new Array();
    scene.traverse(obj => {
        if (obj.isMesh) {
            svgMeshes.push(new SVGMesh(obj));
        }
    });
    const info = new SVGRenderInfo();
    svgRenderer.generateSVG(svgMeshes, camera, { w: W, h: H }, {}, info).then(svg => {
        if (svgDomElement) {
            clearHTMLElement(svgDomElement);
            svg.addTo(svgDomElement);
            console.info(info);
        }
    });
});
function generateSVG() {
    debouncedGenerateSVG();
}
function clearHTMLElement(e) {
    let child = e.lastElementChild;
    while (child) {
        e.removeChild(child);
        child = e.lastElementChild;
    }
}
autoRenderChanged();
updatePasses();
setupScene();
params.autoRender && generateSVG();
